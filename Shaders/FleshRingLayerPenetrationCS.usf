// Copyright 2026 LgThx. All Rights Reserved.

// ============================================================================
// FleshRingLayerPenetrationCS.usf - Layer Penetration Resolution
// ============================================================================
// Ensures outer layers (stocking) never penetrate inner layers (skin)
// Uses material-based layer hierarchy for proper ordering
//
// Layer Hierarchy (inner to outer):
//   0 = Skin (base layer)
//   1 = Stocking (directly on skin)
//   2 = Underwear (on stocking)
//   3 = Outerwear (outermost)
//   4 = Unknown (ignored)
// ============================================================================

#include "/Engine/Public/Platform.ush"

// ============================================================================
// Constants
// ============================================================================

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// Layer type constants
#define LAYER_SKIN       0
#define LAYER_STOCKING   1
#define LAYER_UNDERWEAR  2
#define LAYER_OUTERWEAR  3
#define LAYER_UNKNOWN    4

// Small epsilon for floating point comparisons
#define LAYER_EPSILON 0.0001f

// ============================================================================
// Buffer Declarations - Build Triangle Layer Pass
// ============================================================================

// Per-vertex layer types
Buffer<uint> VertexLayerTypes;

// Triangle indices (3 uints per triangle)
Buffer<uint> TriangleIndices;

// Output: Per-triangle layer types
RWBuffer<uint> TriangleLayerTypesRW;

// Number of triangles
uint NumTriangles;

// ============================================================================
// Buffer Declarations - Penetration Resolution Pass
// ============================================================================

// Vertex positions (read/write)
RWBuffer<float> PositionsRW;

// Vertex normals (for push direction)
Buffer<float> Normals;

// Affected vertex indices
Buffer<uint> AffectedIndices;

// Per-triangle layer types (from build pass)
Buffer<uint> TriangleLayerTypes;

// Number of affected vertices
uint NumAffectedVertices;

// Separation parameters
float MinSeparation;        // Base minimum separation (fallback)
float MaxPushDistance;

// Ring geometry for radial direction
float3 RingCenter;
float3 RingAxis;

// ============================================================================
// Dynamic Separation & Bidirectional Push Parameters
// ============================================================================

// Current tightness strength (0~1) - affects layer separation
float TightnessStrength;

// Push ratio: how much each layer moves when penetration is detected
float OuterLayerPushRatio;   // e.g., 0.7 = stocking moves 70% outward
float InnerLayerPushRatio;   // e.g., 0.3 = skin moves 30% inward

// Output: Skin vertex push amounts (for bidirectional push)
RWBuffer<float> SkinPushAmountsRW;

// ============================================================================
// Helper Functions
// ============================================================================

float3 ReadPosition(uint VertexIndex)
{
    uint Base = VertexIndex * 3;
    return float3(PositionsRW[Base], PositionsRW[Base + 1], PositionsRW[Base + 2]);
}

void WritePosition(uint VertexIndex, float3 Pos)
{
    uint Base = VertexIndex * 3;
    PositionsRW[Base + 0] = Pos.x;
    PositionsRW[Base + 1] = Pos.y;
    PositionsRW[Base + 2] = Pos.z;
}

float3 ReadNormal(uint VertexIndex)
{
    uint Base = VertexIndex * 3;
    return float3(Normals[Base], Normals[Base + 1], Normals[Base + 2]);
}

uint3 GetTriangleIndices(uint TriangleIndex)
{
    uint Base = TriangleIndex * 3;
    return uint3(TriangleIndices[Base], TriangleIndices[Base + 1], TriangleIndices[Base + 2]);
}

// Check if layerA should be outside of layerB (layerA > layerB in hierarchy)
bool ShouldBeOutside(uint LayerA, uint LayerB)
{
    // Unknown layers are ignored
    if (LayerA == LAYER_UNKNOWN || LayerB == LAYER_UNKNOWN)
        return false;

    // Layer A should be outside Layer B if A > B in hierarchy
    // Stocking (1) should be outside Skin (0)
    // Underwear (2) should be outside Stocking (1) and Skin (0)
    // etc.
    return LayerA > LayerB;
}

// ============================================================================
// Dynamic Separation Calculation (v2 - Larger Margin)
// ============================================================================
// Larger margin for guaranteed convergence
// Maintains safe separation after multiple iterations
//
// Key change: Minimum separation increased from 0.005cm (0.05mm) to 0.05cm (0.5mm)
// Reason: Prevents residual penetration from cascade effects in Jacobi iteration

float CalculateDynamicSeparation()
{
    // Unit: cm (Unreal default unit)
    // v2: Significantly increased margin for guaranteed convergence
    float MaxSeparation = 0.1f;    // Max separation when loose (1mm = 0.1cm)
    float MinSeparationTight = 0.05f;  // Min separation when tight (0.5mm = 0.05cm)

    // Linear interpolation: stronger tightness = smaller separation
    return lerp(MaxSeparation, MinSeparationTight, saturate(TightnessStrength));
}

// Compute signed distance from point to plane
float SignedDistanceToPlane(float3 Point, float3 PlanePoint, float3 PlaneNormal)
{
    return dot(Point - PlanePoint, PlaneNormal);
}

// Project point onto triangle and check if inside
// Returns: 0 if inside, distance to nearest edge if outside
float PointInTriangle(float3 P, float3 A, float3 B, float3 C, out float3 OutClosestPoint)
{
    float3 AB = B - A;
    float3 AC = C - A;
    float3 AP = P - A;

    float d1 = dot(AB, AP);
    float d2 = dot(AC, AP);

    // Vertex region outside A
    if (d1 <= 0.0f && d2 <= 0.0f)
    {
        OutClosestPoint = A;
        return length(P - A);
    }

    float3 BP = P - B;
    float d3 = dot(AB, BP);
    float d4 = dot(AC, BP);

    // Vertex region outside B
    if (d3 >= 0.0f && d4 <= d3)
    {
        OutClosestPoint = B;
        return length(P - B);
    }

    // Edge region AB
    float vc = d1 * d4 - d3 * d2;
    if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f)
    {
        float v = d1 / (d1 - d3);
        OutClosestPoint = A + v * AB;
        return length(P - OutClosestPoint);
    }

    float3 CP = P - C;
    float d5 = dot(AB, CP);
    float d6 = dot(AC, CP);

    // Vertex region outside C
    if (d6 >= 0.0f && d5 <= d6)
    {
        OutClosestPoint = C;
        return length(P - C);
    }

    // Edge region AC
    float vb = d5 * d2 - d1 * d6;
    if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f)
    {
        float w = d2 / (d2 - d6);
        OutClosestPoint = A + w * AC;
        return length(P - OutClosestPoint);
    }

    // Edge region BC
    float va = d3 * d6 - d5 * d4;
    if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f)
    {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        OutClosestPoint = B + w * (C - B);
        return length(P - OutClosestPoint);
    }

    // Inside triangle
    float denom = 1.0f / (va + vb + vc);
    float v = vb * denom;
    float w = vc * denom;
    OutClosestPoint = A + AB * v + AC * w;
    return 0.0f;  // Inside triangle
}

// Get triangle normal (unnormalized for efficiency, normalized later)
float3 GetTriangleNormal(float3 V0, float3 V1, float3 V2)
{
    float3 E1 = V1 - V0;
    float3 E2 = V2 - V0;
    return cross(E1, E2);
}

// Calculate radial direction from ring axis
float3 GetRadialDirection(float3 Point)
{
    // Project point onto axis
    float3 ToPoint = Point - RingCenter;
    float AxisDist = dot(ToPoint, RingAxis);
    float3 AxisPoint = RingCenter + RingAxis * AxisDist;

    // Radial direction is from axis to point
    float3 Radial = Point - AxisPoint;
    float RadialLen = length(Radial);

    if (RadialLen < LAYER_EPSILON)
        return float3(0, 0, 0);

    return Radial / RadialLen;
}

// ============================================================================
// Build Triangle Layer Types - Main CS
// ============================================================================
// Determines each triangle's layer type from its vertices
// Uses minimum layer type (most inner) as the triangle's layer

[numthreads(THREADGROUP_SIZE, 1, 1)]
void BuildTriangleLayerCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint TriIdx = DispatchThreadId.x;

    if (TriIdx >= NumTriangles)
        return;

    // Get vertex indices
    uint3 Indices = GetTriangleIndices(TriIdx);

    // Get layer types for each vertex
    uint Layer0 = VertexLayerTypes[Indices.x];
    uint Layer1 = VertexLayerTypes[Indices.y];
    uint Layer2 = VertexLayerTypes[Indices.z];

    // Triangle layer = minimum of vertex layers (most inner layer wins)
    // This ensures mixed triangles are treated as the inner layer
    uint TriangleLayer = min(min(Layer0, Layer1), Layer2);

    // If all vertices are Unknown, keep as Unknown
    if (Layer0 == LAYER_UNKNOWN && Layer1 == LAYER_UNKNOWN && Layer2 == LAYER_UNKNOWN)
    {
        TriangleLayer = LAYER_UNKNOWN;
    }

    TriangleLayerTypesRW[TriIdx] = TriangleLayer;
}

// ============================================================================
// Layer Penetration Resolution - Main CS
// ============================================================================
// For each outer-layer vertex, find nearest inner-layer triangle
// If vertex penetrates the triangle, push it outward
//
// Key characteristics:
// - SearchRadius: Based on DynamicSeparation (minimum search range)
// - Separates actual penetration (SignedDist < 0) from proximity (0 < SignedDist < Sep)
// - Processes based on nearest triangle
// - Normal alignment condition: dot > 0.0

[numthreads(THREADGROUP_SIZE, 1, 1)]
void LayerPenetrationCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIdx = DispatchThreadId.x;

    if (ThreadIdx >= NumAffectedVertices)
        return;

    // Get vertex index and its layer type
    uint VertexIdx = AffectedIndices[ThreadIdx];
    uint VertexLayer = VertexLayerTypes[VertexIdx];

    // Skip unknown layer vertices
    if (VertexLayer == LAYER_UNKNOWN)
        return;

    // Skip skin vertices (nothing should be inside skin)
    if (VertexLayer == LAYER_SKIN)
        return;

    // Get current vertex position
    float3 VertexPos = ReadPosition(VertexIdx);

    // ========================================
    // Compute radial direction for alignment check
    // ========================================
    // NOTE: Use radial direction instead of normal buffer (normal may be zero)
    float3 VertexRadialDir = GetRadialDirection(VertexPos);

    // If radial direction is invalid, skip this vertex
    if (length(VertexRadialDir) < LAYER_EPSILON)
        return;

    // ========================================
    // Calculate Dynamic Separation (Tightness-dependent)
    // ========================================
    float DynamicSeparation = CalculateDynamicSeparation();

    // ========================================
    // v5: Significantly expanded search radius
    // ========================================
    // Penetration can be significant due to smoothing etc.
    // Search triangles in sufficiently large range
    float SearchRadius = MaxPushDistance * 4.0f;  // 4x MaxPush (default 4cm)

    // ========================================
    // v2: Find nearest triangle (not max penetration)
    // ========================================
    float NearestDistance = 1e10f;           // Distance to nearest triangle
    float NearestSignedDist = 1e10f;         // Signed distance to that triangle
    float3 NearestPushDirection = float3(0, 0, 0);
    bool bFoundNearbyTriangle = false;

    for (uint TriIdx = 0; TriIdx < NumTriangles; ++TriIdx)
    {
        // Get triangle layer
        uint TriangleLayer = TriangleLayerTypes[TriIdx];

        // Skip if this triangle is not an inner layer relative to vertex
        if (!ShouldBeOutside(VertexLayer, TriangleLayer))
            continue;

        // Get triangle vertices
        uint3 TriIndices = GetTriangleIndices(TriIdx);
        float3 V0 = ReadPosition(TriIndices.x);
        float3 V1 = ReadPosition(TriIndices.y);
        float3 V2 = ReadPosition(TriIndices.z);

        // Quick distance check (bounding sphere)
        float3 TriCenter = (V0 + V1 + V2) / 3.0f;
        float DistToTriCenter = length(VertexPos - TriCenter);

        // Estimate triangle radius
        float TriRadius = max(max(length(V1 - V0), length(V2 - V1)), length(V0 - V2)) * 0.5f;

        if (DistToTriCenter > SearchRadius + TriRadius)
            continue;

        // Get triangle normal
        float3 TriNormal = GetTriangleNormal(V0, V1, V2);
        float TriNormalLen = length(TriNormal);

        if (TriNormalLen < LAYER_EPSILON)
            continue;

        TriNormal /= TriNormalLen;

        // ========================================
        // v5: Triangle-vertex direction based filter (replaces RadialAlignment)
        // ========================================
        // Original RadialAlignment was based on Ring axis, inaccurate for Z-extended regions
        // Instead: Check if triangle normal faces the vertex
        // -> Penetration check is only meaningful if vertex is "in front of" triangle
        float3 TriToVertex = VertexPos - TriCenter;
        float FacingAlignment = dot(normalize(TriToVertex), TriNormal);

        // FacingAlignment > 0: Vertex is in front of triangle (penetration possible)
        // FacingAlignment < 0: Vertex is behind triangle (this triangle is irrelevant)
        // -0.3 allows some tolerance (nearly parallel cases)
        if (FacingAlignment < -0.3f)
            continue;

        // Find closest point on triangle to vertex
        float3 ClosestPoint;
        float DistToEdge = PointInTriangle(VertexPos, V0, V1, V2, ClosestPoint);

        // Calculate signed distance to triangle plane
        float SignedDist = SignedDistanceToPlane(VertexPos, V0, TriNormal);

        // ========================================
        // v2: Find nearest triangle based on actual distance
        // ========================================
        // Calculate actual 3D distance to triangle
        float ActualDistance;
        if (DistToEdge < LAYER_EPSILON)
        {
            // Projected inside triangle area
            ActualDistance = abs(SignedDist);
        }
        else
        {
            // Outside triangle - distance to closest point
            ActualDistance = length(VertexPos - ClosestPoint);
        }

        // Select nearest triangle within search radius
        if (ActualDistance < SearchRadius && ActualDistance < NearestDistance)
        {
            NearestDistance = ActualDistance;
            NearestSignedDist = SignedDist;

            // Push direction: radial from ring axis
            float3 RadialDir = GetRadialDirection(VertexPos);
            if (length(RadialDir) > LAYER_EPSILON)
            {
                NearestPushDirection = RadialDir;
            }
            else
            {
                NearestPushDirection = TriNormal;
            }

            bFoundNearbyTriangle = true;
        }
    }

    // ========================================
    // v2: Improved penetration resolution logic
    // ========================================
    if (bFoundNearbyTriangle)
    {
        float PushAmount = 0.0f;

        if (NearestSignedDist < 0.0f)
        {
            // Case 1: Actual penetration (vertex is behind triangle)
            // Move in front of triangle + dynamic separation
            PushAmount = abs(NearestSignedDist) + DynamicSeparation;
        }
        else if (NearestSignedDist < DynamicSeparation)
        {
            // Case 2: Not penetrating but closer than dynamic separation
            // Push slightly to dynamic separation position
            PushAmount = DynamicSeparation - NearestSignedDist;
        }
        // else: Case 3: Sufficiently far away - do nothing

        // Apply push
        if (PushAmount > LAYER_EPSILON)
        {
            // Limit to max push (using MaxPushDistance parameter, default 2cm)
            PushAmount = min(PushAmount, MaxPushDistance);

            // Apply OuterLayerPushRatio
            float FinalPush = PushAmount * OuterLayerPushRatio;

            // Calculate new position
            float3 NewPos = VertexPos + NearestPushDirection * FinalPush;
            WritePosition(VertexIdx, NewPos);
        }
    }
}
