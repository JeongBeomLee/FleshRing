// Copyright 2026 LgThx. All Rights Reserved.

// ============================================================================
// FleshRing Skinning Compute Shader
// ============================================================================
// Purpose: Apply GPU skinning to cached TightenedBindPose
//
// This shader processes ALL mesh vertices for skinning only.
// Used after TightenedBindPose is cached (runtime phase).
// ============================================================================

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/GpuSkinCommon.ush"
// From GpuSkinCommon.ush:
// - TANGENT_RWBUFFER_FORMAT: SNORM float4 (non-OpenGL) or int4 (OpenGL)
// - TangentBias_SkinCache(): Read conversion (passthrough for SNORM)
// - TangentUnbias_SkinCache(): Write conversion (passthrough for SNORM)

// ============================================================================
// Buffer Declarations
// ============================================================================

// Input: TightenedBindPose (cached, deformed bind pose)
Buffer<float> SourcePositions;

// Input: Original tangent buffer (TangentX=Tangent, TangentZ=Normal)
// Format: 2 x SNORM8x4 per vertex - SRV format handles SNORM->float conversion
Buffer<float4> SourceTangents;

// Input: Recomputed normals from NormalRecomputeCS (optional, for deformed vertices)
// Format: 3 floats per vertex (x, y, z)
// (0,0,0) = not recomputed -> use SourceTangents
Buffer<float> RecomputedNormals;

// Input: Recomputed tangents from TangentRecomputeCS (optional, Gram-Schmidt orthonormalized)
// Format: 8 floats per vertex (TangentX.xyzw + TangentZ.xyzw)
// (0,0,0,0,0,0,0,0) = not recomputed -> use SourceTangents
Buffer<float> RecomputedTangents;

// Output: Skinned vertex positions (current frame)
RWBuffer<float> OutputPositions;

// Output: Previous frame skinned positions for velocity calculation (TAA/TSR)
RWBuffer<float> OutputPreviousPositions;

// Output: Skinned tangents (TangentX=Tangent, TangentZ=Normal)
// TANGENT_RWBUFFER_FORMAT from GpuSkinCommon.ush
// Same approach as Optimus: PF_R16G16B16A16_SNORM (non-OpenGL)
RWBuffer<TANGENT_RWBUFFER_FORMAT> OutputTangents;

// ============================================================================
// Skinning Data (from GpuSkinCommon.ush pattern)
// ============================================================================

// Bone matrices buffer (3 float4 per bone = 3x4 matrix)
// RefToLocal: [Bind Pose Component Space] -> [Animated Component Space]
Buffer<float4> BoneMatrices;

// Previous frame bone matrices for velocity calculation (TAA/TSR)
Buffer<float4> PreviousBoneMatrices;

// Packed bone indices + weights (LOD-wide)
Buffer<uint> InputWeightStream;

// Skinning parameters
uint InputWeightStride;     // Stride in bytes
uint InputWeightIndexSize;  // BoneIndexByteSize | (BoneWeightByteSize << 8)
uint NumBoneInfluences;     // Number of bone influences per vertex

// Section parameters (same as WaveCS)
uint BaseVertexIndex;       // Section's base vertex index in LOD
uint NumVertices;           // Section's vertex count

// Debug/Feature flags
uint bProcessTangents;      // Whether to process tangents (0 = Position only, 1 = Position + Tangent)
uint bProcessPreviousPosition; // Whether to process Previous Position (0 = current only, 1 = current + Previous)
uint bUseRecomputedNormals; // Whether to use recomputed normals (0 = SourceTangents only, 1 = RecomputedNormals priority)
uint bUseRecomputedTangents; // Whether to use recomputed tangents (0 = SourceTangents only, 1 = RecomputedTangents priority)

// Thread Group Size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Skinning Helper Functions - Runtime-based (independent of GPUSKIN_*)
// ============================================================================
// IMPORTANT: GpuSkinCommon.ush functions depend on compile-time GPUSKIN_* macros.
// However, we need to use runtime parameters (InputWeightIndexSize, NumBoneInfluences)
// so we implement our own unpacking functions.
// ============================================================================

// Get bone matrix from buffer (3 float4 = 3x4 matrix)
float3x4 GetBoneMatrix(uint BoneIndex)
{
    uint BufferIndex = BoneIndex * 3;
    return float3x4(
        BoneMatrices[BufferIndex],
        BoneMatrices[BufferIndex + 1],
        BoneMatrices[BufferIndex + 2]
    );
}

// Get previous frame bone matrix from buffer (3 float4 = 3x4 matrix)
float3x4 GetPreviousBoneMatrix(uint BoneIndex)
{
    uint BufferIndex = BoneIndex * 3;
    return float3x4(
        PreviousBoneMatrices[BufferIndex],
        PreviousBoneMatrices[BufferIndex + 1],
        PreviousBoneMatrices[BufferIndex + 2]
    );
}

// Transform position by 3x4 matrix (with translation)
float3 TransformByMatrix(float3x4 Matrix, float3 Position)
{
    float4 Pos4 = float4(Position, 1.0f);
    return float3(
        dot(Matrix[0], Pos4),
        dot(Matrix[1], Pos4),
        dot(Matrix[2], Pos4)
    );
}

// Transform direction by 3x4 matrix (rotation only, no translation)
float3 TransformDirectionByMatrix(float3x4 Matrix, float3 Direction)
{
    // Use only the 3x3 rotation part (ignore translation in w component)
    return float3(
        dot(Matrix[0].xyz, Direction),
        dot(Matrix[1].xyz, Direction),
        dot(Matrix[2].xyz, Direction)
    );
}

// ============================================================================
// Runtime Weight Unpacking Functions
// ============================================================================
// Weight buffer layout (per vertex):
// - Bone indices: NumBoneInfluences * BoneIndexByteSize bytes
// - Bone weights: NumBoneInfluences * BoneWeightByteSize bytes
//
// InputWeightIndexSize format: BoneIndexByteSize | (BoneWeightByteSize << 8)
// ============================================================================

// Get 4 bone indices from weight stream (runtime version)
// setIndex: 0 for first 4, 1 for second 4 (if 8-bone skinning)
uint4 GetBlendIndicesRuntime(uint StreamOffset, uint SetIndex)
{
    // Extract bone index byte size from packed parameter
    uint BoneIndexByteSize = InputWeightIndexSize & 0xFF;

    if (BoneIndexByteSize == 1)
    {
        // 8-bit indices: 4 indices packed into 1 uint32
        uint PackedIndices = InputWeightStream[StreamOffset + SetIndex];
        return uint4(
            (PackedIndices >> 0) & 0xFF,
            (PackedIndices >> 8) & 0xFF,
            (PackedIndices >> 16) & 0xFF,
            (PackedIndices >> 24) & 0xFF
        );
    }
    else
    {
        // 16-bit indices: 2 indices per uint32, so 2 uint32s for 4 indices
        uint BaseOffset = StreamOffset + SetIndex * 2;
        uint Packed0 = InputWeightStream[BaseOffset];
        uint Packed1 = InputWeightStream[BaseOffset + 1];
        return uint4(
            (Packed0 >> 0) & 0xFFFF,
            (Packed0 >> 16) & 0xFFFF,
            (Packed1 >> 0) & 0xFFFF,
            (Packed1 >> 16) & 0xFFFF
        );
    }
}

// Get 4 bone weights from weight stream (runtime version)
// setIndex: 0 for first 4, 1 for second 4 (if 8-bone skinning)
float4 GetBlendWeightsRuntime(uint StreamOffset, uint SetIndex)
{
    // Extract sizes from packed parameter
    uint BoneIndexByteSize = InputWeightIndexSize & 0xFF;
    uint BoneWeightByteSize = (InputWeightIndexSize >> 8) & 0xFF;

    // Calculate offset to weights section
    // Weights come after all indices
    uint IndicesByteSize = NumBoneInfluences * BoneIndexByteSize;
    uint IndicesUintSize = (IndicesByteSize + 3) / 4; // Round up to uint32

    if (BoneWeightByteSize == 1)
    {
        // 8-bit weights: 4 weights packed into 1 uint32
        uint WeightOffset = StreamOffset + IndicesUintSize + SetIndex;
        uint PackedWeights = InputWeightStream[WeightOffset];

        return float4(
            float((PackedWeights >> 0) & 0xFF) / 255.0f,
            float((PackedWeights >> 8) & 0xFF) / 255.0f,
            float((PackedWeights >> 16) & 0xFF) / 255.0f,
            float((PackedWeights >> 24) & 0xFF) / 255.0f
        );
    }
    else
    {
        // 16-bit weights: 2 weights per uint32, so 2 uint32s for 4 weights
        uint WeightBaseOffset = StreamOffset + IndicesUintSize + SetIndex * 2;
        uint Packed0 = InputWeightStream[WeightBaseOffset];
        uint Packed1 = InputWeightStream[WeightBaseOffset + 1];

        return float4(
            float((Packed0 >> 0) & 0xFFFF) / 65535.0f,
            float((Packed0 >> 16) & 0xFFFF) / 65535.0f,
            float((Packed1 >> 0) & 0xFFFF) / 65535.0f,
            float((Packed1 >> 16) & 0xFFFF) / 65535.0f
        );
    }
}

// Compute blended skinning matrix for a vertex (runtime version)
float3x4 ComputeSkinnedMatrix(uint VertexIndex)
{
    // Calculate stream offset for this vertex (in uint32 units)
    uint StreamOffset = VertexIndex * (InputWeightStride / 4);

    // Get first 4 bone influences
    uint4 Indices0 = GetBlendIndicesRuntime(StreamOffset, 0);
    float4 Weights0 = GetBlendWeightsRuntime(StreamOffset, 0);

    // Blend bone matrices with weights
    float3x4 BlendedMatrix = GetBoneMatrix(Indices0.x) * Weights0.x;
    BlendedMatrix += GetBoneMatrix(Indices0.y) * Weights0.y;
    BlendedMatrix += GetBoneMatrix(Indices0.z) * Weights0.z;
    BlendedMatrix += GetBoneMatrix(Indices0.w) * Weights0.w;

    // Get additional 4 bone influences (if 8-bone skinning)
    if (NumBoneInfluences > 4)
    {
        uint4 Indices1 = GetBlendIndicesRuntime(StreamOffset, 1);
        float4 Weights1 = GetBlendWeightsRuntime(StreamOffset, 1);

        BlendedMatrix += GetBoneMatrix(Indices1.x) * Weights1.x;
        BlendedMatrix += GetBoneMatrix(Indices1.y) * Weights1.y;
        BlendedMatrix += GetBoneMatrix(Indices1.z) * Weights1.z;
        BlendedMatrix += GetBoneMatrix(Indices1.w) * Weights1.w;
    }

    return BlendedMatrix;
}

// Compute blended previous frame skinning matrix for a vertex (TAA/TSR velocity)
float3x4 ComputePreviousSkinnedMatrix(uint VertexIndex)
{
    // Calculate stream offset for this vertex (in uint32 units)
    uint StreamOffset = VertexIndex * (InputWeightStride / 4);

    // Get first 4 bone influences
    uint4 Indices0 = GetBlendIndicesRuntime(StreamOffset, 0);
    float4 Weights0 = GetBlendWeightsRuntime(StreamOffset, 0);

    // Blend previous frame bone matrices with weights
    float3x4 BlendedMatrix = GetPreviousBoneMatrix(Indices0.x) * Weights0.x;
    BlendedMatrix += GetPreviousBoneMatrix(Indices0.y) * Weights0.y;
    BlendedMatrix += GetPreviousBoneMatrix(Indices0.z) * Weights0.z;
    BlendedMatrix += GetPreviousBoneMatrix(Indices0.w) * Weights0.w;

    // Get additional 4 bone influences (if 8-bone skinning)
    if (NumBoneInfluences > 4)
    {
        uint4 Indices1 = GetBlendIndicesRuntime(StreamOffset, 1);
        float4 Weights1 = GetBlendWeightsRuntime(StreamOffset, 1);

        BlendedMatrix += GetPreviousBoneMatrix(Indices1.x) * Weights1.x;
        BlendedMatrix += GetPreviousBoneMatrix(Indices1.y) * Weights1.y;
        BlendedMatrix += GetPreviousBoneMatrix(Indices1.z) * Weights1.z;
        BlendedMatrix += GetPreviousBoneMatrix(Indices1.w) * Weights1.w;
    }

    return BlendedMatrix;
}

// ============================================================================
// Position Read/Write Helper Functions
// ============================================================================

// Read vertex position from buffer (3 floats per vertex)
float3 ReadPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        SourcePositions[BaseIndex + 0],
        SourcePositions[BaseIndex + 1],
        SourcePositions[BaseIndex + 2]
    );
}

// Write vertex position to buffer (3 floats per vertex)
void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

// Write previous frame vertex position to buffer (3 floats per vertex)
void WritePreviousPosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPreviousPositions[BaseIndex + 0] = Pos.x;
    OutputPreviousPositions[BaseIndex + 1] = Pos.y;
    OutputPreviousPositions[BaseIndex + 2] = Pos.z;
}

// ============================================================================
// Tangent Read/Write Helper Functions
// ============================================================================
// UE5 Tangent buffer format (GpuSkinCommon.ush standard):
// - 2 x float4 per vertex (TangentX, TangentZ)
// - TangentX (index 0): Tangent direction (W unused)
// - TangentZ (index 1): Normal direction + Binormal sign in W
// - Format: PF_R16G16B16A16_SNORM (16-bit per channel)
// - Uses TangentBias_SkinCache / TangentUnbias_SkinCache from GpuSkinCommon.ush
// ============================================================================

// Read recomputed normal from NormalRecomputeCS output buffer
float3 ReadRecomputedNormal(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        RecomputedNormals[BaseIndex + 0],
        RecomputedNormals[BaseIndex + 1],
        RecomputedNormals[BaseIndex + 2]
    );
}

// Check if recomputed normal is valid (not zero vector)
bool IsRecomputedNormalValid(float3 Normal)
{
    // Normalized normals cannot be (0,0,0)
    // (0,0,0) means the normal was not recomputed -> use original
    return dot(Normal, Normal) > 1e-8f;
}

// Read recomputed tangents from TangentRecomputeCS output buffer
// Format: 8 floats per vertex (TangentX.xyzw + TangentZ.xyzw)
// UE standard: TangentX = Tangent (W=0), TangentZ = Normal (W=binormal sign)
void ReadRecomputedTangents(uint VertexIndex, out float3 OutNormal, out float4 OutTangent)
{
    uint BaseIndex = VertexIndex * 8;
    // TangentX = Tangent (W=0)
    float4 TangentX = float4(
        RecomputedTangents[BaseIndex + 0],
        RecomputedTangents[BaseIndex + 1],
        RecomputedTangents[BaseIndex + 2],
        RecomputedTangents[BaseIndex + 3]
    );
    // TangentZ = Normal (W=binormal sign)
    float4 TangentZ = float4(
        RecomputedTangents[BaseIndex + 4],
        RecomputedTangents[BaseIndex + 5],
        RecomputedTangents[BaseIndex + 6],
        RecomputedTangents[BaseIndex + 7]
    );

    OutNormal = TangentZ.xyz;
    OutTangent = float4(TangentX.xyz, TangentZ.w);  // Tangent.xyz + BinormalSign from TangentZ.w
}

// Check if recomputed tangent is valid (not zero vector)
bool IsRecomputedTangentValid(float3 Normal, float3 Tangent)
{
    // If both normal and tangent are valid (non-zero), the tangent is recomputed
    return (dot(Normal, Normal) > 1e-8f) && (dot(Tangent, Tangent) > 1e-8f);
}

// Read TangentX (Tangent) and TangentZ (Normal) from buffer
// GpuSkinCommon.ush standard: TangentX=Tangent(Index 0), TangentZ=Normal(Index 1)
void ReadTangents(uint VertexIndex, out float3 OutNormal, out float4 OutTangent)
{
    uint BaseIndex = VertexIndex * 2;
    // Use TangentBias_SkinCache from GpuSkinCommon.ush (passthrough for SNORM, converts for OpenGL)
    float4 TangentX = TangentBias_SkinCache(SourceTangents[BaseIndex + 0]);  // Tangent
    float4 TangentZ = TangentBias_SkinCache(SourceTangents[BaseIndex + 1]);  // Normal + BinormalSign

    OutNormal = TangentZ.xyz;
    OutTangent = float4(TangentX.xyz, TangentZ.w);  // Tangent.xyz + BinormalSign from TangentZ.w
}

// Read tangents with optional recomputed normal/tangent override
void ReadTangentsWithRecomputedNormalAndTangent(uint VertexIndex, out float3 OutNormal, out float4 OutTangent)
{
    // First read original tangents as base
    ReadTangents(VertexIndex, OutNormal, OutTangent);

    // Priority: RecomputedTangents > RecomputedNormals > SourceTangents

    // If using recomputed tangents (includes both normal and tangent from TangentRecomputeCS)
    if (bUseRecomputedTangents != 0)
    {
        float3 RecomputedN;
        float4 RecomputedT;
        ReadRecomputedTangents(VertexIndex, RecomputedN, RecomputedT);

        if (IsRecomputedTangentValid(RecomputedN, RecomputedT.xyz))
        {
            // Use both recomputed normal and tangent (Gram-Schmidt orthonormalized)
            OutNormal = RecomputedN;
            OutTangent = RecomputedT;
            return;
        }
    }

    // Fallback: If using recomputed normals only
    if (bUseRecomputedNormals != 0)
    {
        float3 RecomputedNormal = ReadRecomputedNormal(VertexIndex);
        if (IsRecomputedNormalValid(RecomputedNormal))
        {
            OutNormal = RecomputedNormal;
        }
    }
}

// Backward compatibility wrapper function
void ReadTangentsWithRecomputedNormal(uint VertexIndex, out float3 OutNormal, out float4 OutTangent)
{
    ReadTangentsWithRecomputedNormalAndTangent(VertexIndex, OutNormal, OutTangent);
}

// Safe normalize: returns default if input is zero/near-zero
float3 SafeNormalize(float3 V, float3 Default)
{
    float LenSq = dot(V, V);
    return LenSq > 1e-8f ? V * rsqrt(LenSq) : Default;
}

// Write TangentX (Tangent) and TangentZ (Normal) to buffer
// GpuSkinCommon.ush standard: TangentX=Tangent(Index 0), TangentZ=Normal(Index 1)
void WriteTangents(uint VertexIndex, float3 Normal, float4 Tangent)
{
    uint BaseIndex = VertexIndex * 2;

    // TangentX (Index 0): Tangent direction (safe normalized) with W=0
    // Use (1,0,0) as default if zero vector
    float3 SafeTangentDir = SafeNormalize(Tangent.xyz, float3(1, 0, 0));
    float4 TangentX = float4(SafeTangentDir, 0.0f);

    // TangentZ (Index 1): Normal (safe normalized) with binormal sign preserved in W
    // Use (0,0,1) as default if zero vector
    float3 SafeNormal = SafeNormalize(Normal, float3(0, 0, 1));
    float4 TangentZ = float4(SafeNormal, Tangent.w);

    // Use TangentUnbias_SkinCache from GpuSkinCommon.ush (passthrough for SNORM, converts for OpenGL)
    OutputTangents[BaseIndex + 0] = TangentUnbias_SkinCache(TangentX);
    OutputTangents[BaseIndex + 1] = TangentUnbias_SkinCache(TangentZ);
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    // Local vertex index within this Section's dispatch
    uint LocalVertexIndex = DispatchThreadId.x;

    // Bounds check: process only this Section's vertices
    if (LocalVertexIndex >= NumVertices)
    {
        return;
    }

    // Global vertex index in LOD (for buffer access)
    uint GlobalVertexIndex = BaseVertexIndex + LocalVertexIndex;

    // ========================================
    // Step 1: Read Input Data
    // ========================================
    // Position: TightenedBindPose (cached)
    float3 TightenedPos = ReadPosition(GlobalVertexIndex);

    // ========================================
    // Step 2: Compute Skinning Matrix
    // ========================================
    // IMPORTANT: Use GlobalVertexIndex for InputWeightStream access
    float3x4 SkinMatrix = ComputeSkinnedMatrix(GlobalVertexIndex);

    // ========================================
    // Step 3: Apply GPU Skinning to Position
    // ========================================
    float3 SkinnedPos = TransformByMatrix(SkinMatrix, TightenedPos);

    // ========================================
    // Step 4: Write Current Position Output
    // ========================================
    WritePosition(GlobalVertexIndex, SkinnedPos);

    // ========================================
    // Step 5: Compute & Write Previous Position (for TAA/TSR velocity)
    // ========================================
    // Previous Position is needed for motion vector calculation
    // velocity = CurrentPosition - PreviousPosition
    if (bProcessPreviousPosition != 0)
    {
        // Compute previous frame skinning matrix using previous bone matrices
        float3x4 PreviousSkinMatrix = ComputePreviousSkinnedMatrix(GlobalVertexIndex);

        // Apply previous skinning to TightenedBindPose
        float3 PreviousSkinnedPos = TransformByMatrix(PreviousSkinMatrix, TightenedPos);

        WritePreviousPosition(GlobalVertexIndex, PreviousSkinnedPos);
    }

    // ========================================
    // Step 6: Tangent processing (optional)
    // ========================================
    // Tangent processing is optional (controlled by bProcessTangents flag)
    if (bProcessTangents != 0)
    {
        // Read tangents (with optional recomputed normal override)
        float3 SourceNormal;
        float4 OriginalTangent;
        ReadTangentsWithRecomputedNormal(GlobalVertexIndex, SourceNormal, OriginalTangent);

        // Transform tangents by skinning matrix (rotation only)
        float3 SkinnedNormal = TransformDirectionByMatrix(SkinMatrix, SourceNormal);
        float3 SkinnedTangentDir = TransformDirectionByMatrix(SkinMatrix, OriginalTangent.xyz);
        float4 SkinnedTangent = float4(SkinnedTangentDir, OriginalTangent.w);

        WriteTangents(GlobalVertexIndex, SkinnedNormal, SkinnedTangent);
    }
}
