// Copyright 2026 LgThx. All Rights Reserved.

// ============================================================================
// FleshRing Skinning Compute Shader
// FleshRing 스키닝 컴퓨트 셰이더
// ============================================================================
// Purpose: Apply GPU skinning to cached TightenedBindPose
// 목적: 캐싱된 TightenedBindPose에 GPU 스키닝 적용
//
// This shader processes ALL mesh vertices for skinning only.
// Used after TightenedBindPose is cached (runtime phase).
// 이 셰이더는 모든 메시 버텍스에 스키닝만 적용합니다.
// TightenedBindPose가 캐싱된 이후 런타임에서 사용됩니다.
// ============================================================================

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/GpuSkinCommon.ush"
// GpuSkinCommon.ush에서 가져오는 것들:
// - TANGENT_RWBUFFER_FORMAT: SNORM float4 (non-OpenGL) 또는 int4 (OpenGL)
// - TangentBias_SkinCache(): 읽기 시 변환 (SNORM은 passthrough)
// - TangentUnbias_SkinCache(): 쓰기 시 변환 (SNORM은 passthrough)

// ============================================================================
// Buffer Declarations
// 버퍼 선언
// ============================================================================

// Input: TightenedBindPose (cached, deformed bind pose)
// 입력: TightenedBindPose (캐싱된, 변형된 바인드 포즈)
Buffer<float> SourcePositions;

// Input: Original tangent buffer (TangentX=Tangent, TangentZ=Normal)
// 입력: 원본 탄젠트 버퍼 (TangentX=탄젠트, TangentZ=노멀)
// Format: 2 x SNORM8x4 per vertex - SRV format handles SNORM->float conversion
// SRV 포맷이 SNORM->float 변환을 처리
Buffer<float4> SourceTangents;

// Input: Recomputed normals from NormalRecomputeCS (optional, for deformed vertices)
// 입력: NormalRecomputeCS에서 재계산된 노멀 (선택적, 변형된 버텍스용)
// Format: 3 floats per vertex (x, y, z)
// (0,0,0) = 재계산되지 않음 → SourceTangents 사용
Buffer<float> RecomputedNormals;

// Input: Recomputed tangents from TangentRecomputeCS (optional, Gram-Schmidt orthonormalized)
// 입력: TangentRecomputeCS에서 재계산된 탄젠트 (선택적, Gram-Schmidt 정규직교화)
// Format: 8 floats per vertex (TangentX.xyzw + TangentZ.xyzw)
// (0,0,0,0,0,0,0,0) = 재계산되지 않음 → SourceTangents 사용
Buffer<float> RecomputedTangents;

// Output: Skinned vertex positions (current frame)
// 출력: 스키닝된 버텍스 위치 (현재 프레임)
RWBuffer<float> OutputPositions;

// Output: Previous frame skinned positions for velocity calculation (TAA/TSR)
// TAA/TSR용 이전 프레임 스키닝된 위치 출력 (velocity 계산용)
RWBuffer<float> OutputPreviousPositions;

// Output: Skinned tangents (TangentX=Tangent, TangentZ=Normal)
// 출력: 스키닝된 탄젠트 - TANGENT_RWBUFFER_FORMAT from GpuSkinCommon.ush
// Optimus와 동일한 방식: PF_R16G16B16A16_SNORM (non-OpenGL)
RWBuffer<TANGENT_RWBUFFER_FORMAT> OutputTangents;

// ============================================================================
// Skinning Data (from GpuSkinCommon.ush pattern)
// 스키닝 데이터 (GpuSkinCommon.ush 패턴)
// ============================================================================

// Bone matrices buffer (3 float4 per bone = 3x4 matrix)
// RefToLocal: [Bind Pose Component Space] -> [Animated Component Space]
// 본 행렬 버퍼 (본당 3개의 float4 = 3x4 행렬)
Buffer<float4> BoneMatrices;

// Previous frame bone matrices for velocity calculation (TAA/TSR)
// TAA/TSR용 이전 프레임 본 행렬 (velocity 계산용)
Buffer<float4> PreviousBoneMatrices;

// Packed bone indices + weights (LOD-wide)
// 패킹된 본 인덱스 + 웨이트 (LOD 전체)
Buffer<uint> InputWeightStream;

// Skinning parameters
// 스키닝 파라미터
uint InputWeightStride;     // Stride in bytes / 바이트 단위 스트라이드
uint InputWeightIndexSize;  // BoneIndexByteSize | (BoneWeightByteSize << 8)
uint NumBoneInfluences;     // Number of bone influences per vertex / 버텍스당 본 영향 수

// Section parameters (like WaveCS)
// Section 파라미터 (WaveCS와 동일)
uint BaseVertexIndex;       // Section's base vertex index in LOD / LOD 내 Section 시작 인덱스
uint NumVertices;           // Section's vertex count / Section 버텍스 수

// Debug/Feature flags
// 디버그/기능 플래그
uint bProcessTangents;      // 탄젠트 처리 여부 (0 = Position만, 1 = Position + Tangent)
uint bProcessPreviousPosition; // Previous Position 처리 여부 (0 = 현재만, 1 = 현재 + Previous)
uint bUseRecomputedNormals; // 재계산된 노멀 사용 여부 (0 = SourceTangents만, 1 = RecomputedNormals 우선)
uint bUseRecomputedTangents; // 재계산된 탄젠트 사용 여부 (0 = SourceTangents만, 1 = RecomputedTangents 우선)

// Thread Group Size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Skinning Helper Functions - Runtime-based (GPUSKIN_* 무관)
// 스키닝 헬퍼 함수 - 런타임 기반 (컴파일 타임 매크로 미사용)
// ============================================================================
// IMPORTANT: GpuSkinCommon.ush의 함수들은 컴파일 타임 GPUSKIN_* 매크로에 의존합니다.
// 하지만 우리는 런타임 파라미터 (InputWeightIndexSize, NumBoneInfluences)를 사용해야 하므로
// 자체 언패킹 함수를 구현합니다.
// ============================================================================

// Get bone matrix from buffer (3 float4 = 3x4 matrix)
// 버퍼에서 본 행렬 가져오기 (3 float4 = 3x4 행렬)
float3x4 GetBoneMatrix(uint BoneIndex)
{
    uint BufferIndex = BoneIndex * 3;
    return float3x4(
        BoneMatrices[BufferIndex],
        BoneMatrices[BufferIndex + 1],
        BoneMatrices[BufferIndex + 2]
    );
}

// Get previous frame bone matrix from buffer (3 float4 = 3x4 matrix)
// 이전 프레임 본 행렬 가져오기 (3 float4 = 3x4 행렬)
float3x4 GetPreviousBoneMatrix(uint BoneIndex)
{
    uint BufferIndex = BoneIndex * 3;
    return float3x4(
        PreviousBoneMatrices[BufferIndex],
        PreviousBoneMatrices[BufferIndex + 1],
        PreviousBoneMatrices[BufferIndex + 2]
    );
}

// Transform position by 3x4 matrix (with translation)
// 3x4 행렬로 위치 변환 (이동 포함)
float3 TransformByMatrix(float3x4 Matrix, float3 Position)
{
    float4 Pos4 = float4(Position, 1.0f);
    return float3(
        dot(Matrix[0], Pos4),
        dot(Matrix[1], Pos4),
        dot(Matrix[2], Pos4)
    );
}

// Transform direction by 3x4 matrix (rotation only, no translation)
// 3x4 행렬로 방향 변환 (회전만, 이동 없음)
float3 TransformDirectionByMatrix(float3x4 Matrix, float3 Direction)
{
    // Use only the 3x3 rotation part (ignore translation in w component)
    // 3x3 회전 부분만 사용 (w 컴포넌트의 이동은 무시)
    return float3(
        dot(Matrix[0].xyz, Direction),
        dot(Matrix[1].xyz, Direction),
        dot(Matrix[2].xyz, Direction)
    );
}

// ============================================================================
// Runtime Weight Unpacking Functions
// 런타임 웨이트 언패킹 함수
// ============================================================================
// Weight buffer layout (per vertex):
// - Bone indices: NumBoneInfluences * BoneIndexByteSize bytes
// - Bone weights: NumBoneInfluences * BoneWeightByteSize bytes
//
// InputWeightIndexSize format: BoneIndexByteSize | (BoneWeightByteSize << 8)
// ============================================================================

// Get 4 bone indices from weight stream (runtime version)
// 웨이트 스트림에서 4개 본 인덱스 가져오기 (런타임 버전)
// setIndex: 0 for first 4, 1 for second 4 (if 8-bone skinning)
uint4 GetBlendIndicesRuntime(uint StreamOffset, uint SetIndex)
{
    // Extract bone index byte size from packed parameter
    uint BoneIndexByteSize = InputWeightIndexSize & 0xFF;

    if (BoneIndexByteSize == 1)
    {
        // 8-bit indices: 4 indices packed into 1 uint32
        // 8비트 인덱스: 4개 인덱스가 1개의 uint32에 패킹됨
        uint PackedIndices = InputWeightStream[StreamOffset + SetIndex];
        return uint4(
            (PackedIndices >> 0) & 0xFF,
            (PackedIndices >> 8) & 0xFF,
            (PackedIndices >> 16) & 0xFF,
            (PackedIndices >> 24) & 0xFF
        );
    }
    else
    {
        // 16-bit indices: 2 indices per uint32, so 2 uint32s for 4 indices
        // 16비트 인덱스: uint32당 2개 인덱스, 4개 인덱스에 2개 uint32
        uint BaseOffset = StreamOffset + SetIndex * 2;
        uint Packed0 = InputWeightStream[BaseOffset];
        uint Packed1 = InputWeightStream[BaseOffset + 1];
        return uint4(
            (Packed0 >> 0) & 0xFFFF,
            (Packed0 >> 16) & 0xFFFF,
            (Packed1 >> 0) & 0xFFFF,
            (Packed1 >> 16) & 0xFFFF
        );
    }
}

// Get 4 bone weights from weight stream (runtime version)
// 웨이트 스트림에서 4개 본 웨이트 가져오기 (런타임 버전)
// setIndex: 0 for first 4, 1 for second 4 (if 8-bone skinning)
float4 GetBlendWeightsRuntime(uint StreamOffset, uint SetIndex)
{
    // Extract sizes from packed parameter
    // 패킹된 파라미터에서 크기 추출
    uint BoneIndexByteSize = InputWeightIndexSize & 0xFF;
    uint BoneWeightByteSize = (InputWeightIndexSize >> 8) & 0xFF;

    // Calculate offset to weights section
    // Weights come after all indices
    // 웨이트는 모든 인덱스 뒤에 위치
    uint IndicesByteSize = NumBoneInfluences * BoneIndexByteSize;
    uint IndicesUintSize = (IndicesByteSize + 3) / 4; // Round up to uint32

    if (BoneWeightByteSize == 1)
    {
        // 8-bit weights: 4 weights packed into 1 uint32
        // 8비트 웨이트: 4개 웨이트가 1개의 uint32에 패킹됨
        uint WeightOffset = StreamOffset + IndicesUintSize + SetIndex;
        uint PackedWeights = InputWeightStream[WeightOffset];

        return float4(
            float((PackedWeights >> 0) & 0xFF) / 255.0f,
            float((PackedWeights >> 8) & 0xFF) / 255.0f,
            float((PackedWeights >> 16) & 0xFF) / 255.0f,
            float((PackedWeights >> 24) & 0xFF) / 255.0f
        );
    }
    else
    {
        // 16-bit weights: 2 weights per uint32, so 2 uint32s for 4 weights
        // 16비트 웨이트: uint32당 2개 웨이트, 4개 웨이트에 2개 uint32
        uint WeightBaseOffset = StreamOffset + IndicesUintSize + SetIndex * 2;
        uint Packed0 = InputWeightStream[WeightBaseOffset];
        uint Packed1 = InputWeightStream[WeightBaseOffset + 1];

        return float4(
            float((Packed0 >> 0) & 0xFFFF) / 65535.0f,
            float((Packed0 >> 16) & 0xFFFF) / 65535.0f,
            float((Packed1 >> 0) & 0xFFFF) / 65535.0f,
            float((Packed1 >> 16) & 0xFFFF) / 65535.0f
        );
    }
}

// Compute blended skinning matrix for a vertex (runtime version)
// 버텍스의 블렌딩된 스키닝 행렬 계산 (런타임 버전)
float3x4 ComputeSkinnedMatrix(uint VertexIndex)
{
    // Calculate stream offset for this vertex (in uint32 units)
    // 이 버텍스의 스트림 오프셋 계산 (uint32 단위)
    uint StreamOffset = VertexIndex * (InputWeightStride / 4);

    // Get first 4 bone influences
    // 첫 4개 본 영향 가져오기
    uint4 Indices0 = GetBlendIndicesRuntime(StreamOffset, 0);
    float4 Weights0 = GetBlendWeightsRuntime(StreamOffset, 0);

    // Blend bone matrices with weights
    // 본 행렬을 웨이트로 블렌딩
    float3x4 BlendedMatrix = GetBoneMatrix(Indices0.x) * Weights0.x;
    BlendedMatrix += GetBoneMatrix(Indices0.y) * Weights0.y;
    BlendedMatrix += GetBoneMatrix(Indices0.z) * Weights0.z;
    BlendedMatrix += GetBoneMatrix(Indices0.w) * Weights0.w;

    // Get additional 4 bone influences (if 8-bone skinning)
    // 추가 4개 본 영향 가져오기 (8본 스키닝인 경우)
    if (NumBoneInfluences > 4)
    {
        uint4 Indices1 = GetBlendIndicesRuntime(StreamOffset, 1);
        float4 Weights1 = GetBlendWeightsRuntime(StreamOffset, 1);

        BlendedMatrix += GetBoneMatrix(Indices1.x) * Weights1.x;
        BlendedMatrix += GetBoneMatrix(Indices1.y) * Weights1.y;
        BlendedMatrix += GetBoneMatrix(Indices1.z) * Weights1.z;
        BlendedMatrix += GetBoneMatrix(Indices1.w) * Weights1.w;
    }

    return BlendedMatrix;
}

// Compute blended previous frame skinning matrix for a vertex (TAA/TSR velocity)
// 버텍스의 이전 프레임 블렌딩된 스키닝 행렬 계산 (TAA/TSR velocity용)
float3x4 ComputePreviousSkinnedMatrix(uint VertexIndex)
{
    // Calculate stream offset for this vertex (in uint32 units)
    // 이 버텍스의 스트림 오프셋 계산 (uint32 단위)
    uint StreamOffset = VertexIndex * (InputWeightStride / 4);

    // Get first 4 bone influences
    // 첫 4개 본 영향 가져오기
    uint4 Indices0 = GetBlendIndicesRuntime(StreamOffset, 0);
    float4 Weights0 = GetBlendWeightsRuntime(StreamOffset, 0);

    // Blend previous frame bone matrices with weights
    // 이전 프레임 본 행렬을 웨이트로 블렌딩
    float3x4 BlendedMatrix = GetPreviousBoneMatrix(Indices0.x) * Weights0.x;
    BlendedMatrix += GetPreviousBoneMatrix(Indices0.y) * Weights0.y;
    BlendedMatrix += GetPreviousBoneMatrix(Indices0.z) * Weights0.z;
    BlendedMatrix += GetPreviousBoneMatrix(Indices0.w) * Weights0.w;

    // Get additional 4 bone influences (if 8-bone skinning)
    // 추가 4개 본 영향 가져오기 (8본 스키닝인 경우)
    if (NumBoneInfluences > 4)
    {
        uint4 Indices1 = GetBlendIndicesRuntime(StreamOffset, 1);
        float4 Weights1 = GetBlendWeightsRuntime(StreamOffset, 1);

        BlendedMatrix += GetPreviousBoneMatrix(Indices1.x) * Weights1.x;
        BlendedMatrix += GetPreviousBoneMatrix(Indices1.y) * Weights1.y;
        BlendedMatrix += GetPreviousBoneMatrix(Indices1.z) * Weights1.z;
        BlendedMatrix += GetPreviousBoneMatrix(Indices1.w) * Weights1.w;
    }

    return BlendedMatrix;
}

// ============================================================================
// Position Read/Write Helper Functions
// 위치 읽기/쓰기 헬퍼 함수
// ============================================================================

// Read vertex position from buffer (3 floats per vertex)
// 버퍼에서 버텍스 위치 읽기 (버텍스당 3 float)
float3 ReadPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        SourcePositions[BaseIndex + 0],
        SourcePositions[BaseIndex + 1],
        SourcePositions[BaseIndex + 2]
    );
}

// Write vertex position to buffer (3 floats per vertex)
// 버퍼에 버텍스 위치 쓰기 (버텍스당 3 float)
void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

// Write previous frame vertex position to buffer (3 floats per vertex)
// 이전 프레임 버텍스 위치 쓰기 (버텍스당 3 float)
void WritePreviousPosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPreviousPositions[BaseIndex + 0] = Pos.x;
    OutputPreviousPositions[BaseIndex + 1] = Pos.y;
    OutputPreviousPositions[BaseIndex + 2] = Pos.z;
}

// ============================================================================
// Tangent Read/Write Helper Functions
// 탄젠트 읽기/쓰기 헬퍼 함수
// ============================================================================
// UE5 Tangent buffer format (GpuSkinCommon.ush 표준):
// - 2 x float4 per vertex (TangentX, TangentZ)
// - TangentX (index 0): Tangent direction (W unused)
// - TangentZ (index 1): Normal direction + Binormal sign in W
// - Format: PF_R16G16B16A16_SNORM (16-bit per channel)
// - GpuSkinCommon.ush의 TangentBias_SkinCache / TangentUnbias_SkinCache 사용
// ============================================================================

// Read recomputed normal from NormalRecomputeCS output buffer
// NormalRecomputeCS 출력 버퍼에서 재계산된 노멀 읽기
float3 ReadRecomputedNormal(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        RecomputedNormals[BaseIndex + 0],
        RecomputedNormals[BaseIndex + 1],
        RecomputedNormals[BaseIndex + 2]
    );
}

// Check if recomputed normal is valid (not zero vector)
// 재계산된 노멀이 유효한지 확인 (0 벡터가 아닌지)
bool IsRecomputedNormalValid(float3 Normal)
{
    // Normalized normals cannot be (0,0,0)
    // (0,0,0) means the normal was not recomputed → use original
    // 정규화된 노멀은 (0,0,0)이 될 수 없음
    // (0,0,0)은 재계산되지 않았음을 의미 → 원본 사용
    return dot(Normal, Normal) > 1e-8f;
}

// Read recomputed tangents from TangentRecomputeCS output buffer
// TangentRecomputeCS 출력 버퍼에서 재계산된 탄젠트 읽기
// Format: 8 floats per vertex (TangentX.xyzw + TangentZ.xyzw)
// UE 표준: TangentX = Tangent (W=0), TangentZ = Normal (W=binormal sign)
void ReadRecomputedTangents(uint VertexIndex, out float3 OutNormal, out float4 OutTangent)
{
    uint BaseIndex = VertexIndex * 8;
    // TangentX = Tangent (W=0)
    float4 TangentX = float4(
        RecomputedTangents[BaseIndex + 0],
        RecomputedTangents[BaseIndex + 1],
        RecomputedTangents[BaseIndex + 2],
        RecomputedTangents[BaseIndex + 3]
    );
    // TangentZ = Normal (W=binormal sign)
    float4 TangentZ = float4(
        RecomputedTangents[BaseIndex + 4],
        RecomputedTangents[BaseIndex + 5],
        RecomputedTangents[BaseIndex + 6],
        RecomputedTangents[BaseIndex + 7]
    );

    OutNormal = TangentZ.xyz;
    OutTangent = float4(TangentX.xyz, TangentZ.w);  // Tangent.xyz + BinormalSign from TangentZ.w
}

// Check if recomputed tangent is valid (not zero vector)
// 재계산된 탄젠트가 유효한지 확인 (0 벡터가 아닌지)
bool IsRecomputedTangentValid(float3 Normal, float3 Tangent)
{
    // If both normal and tangent are valid (non-zero), the tangent is recomputed
    // 노멀과 탄젠트 둘 다 유효하면(0이 아니면), 재계산된 탄젠트임
    return (dot(Normal, Normal) > 1e-8f) && (dot(Tangent, Tangent) > 1e-8f);
}

// Read TangentX (Tangent) and TangentZ (Normal) from buffer
// 버퍼에서 TangentX (탄젠트)와 TangentZ (노멀) 읽기
// GpuSkinCommon.ush 표준: TangentX=Tangent(Index 0), TangentZ=Normal(Index 1)
void ReadTangents(uint VertexIndex, out float3 OutNormal, out float4 OutTangent)
{
    uint BaseIndex = VertexIndex * 2;
    // Use TangentBias_SkinCache from GpuSkinCommon.ush (passthrough for SNORM, converts for OpenGL)
    float4 TangentX = TangentBias_SkinCache(SourceTangents[BaseIndex + 0]);  // Tangent
    float4 TangentZ = TangentBias_SkinCache(SourceTangents[BaseIndex + 1]);  // Normal + BinormalSign

    OutNormal = TangentZ.xyz;
    OutTangent = float4(TangentX.xyz, TangentZ.w);  // Tangent.xyz + BinormalSign from TangentZ.w
}

// Read tangents with optional recomputed normal/tangent override
// 선택적으로 재계산된 노멀/탄젠트로 대체하여 읽기
void ReadTangentsWithRecomputedNormalAndTangent(uint VertexIndex, out float3 OutNormal, out float4 OutTangent)
{
    // First read original tangents as base
    // 먼저 원본 탄젠트를 기본값으로 읽기
    ReadTangents(VertexIndex, OutNormal, OutTangent);

    // Priority: RecomputedTangents > RecomputedNormals > SourceTangents
    // 우선순위: 재계산된 탄젠트 > 재계산된 노멀 > 원본 탄젠트

    // If using recomputed tangents (includes both normal and tangent from TangentRecomputeCS)
    // 재계산된 탄젠트 사용 시 (NormalRecomputeCS + TangentRecomputeCS 결과 포함)
    if (bUseRecomputedTangents != 0)
    {
        float3 RecomputedN;
        float4 RecomputedT;
        ReadRecomputedTangents(VertexIndex, RecomputedN, RecomputedT);

        if (IsRecomputedTangentValid(RecomputedN, RecomputedT.xyz))
        {
            // Use both recomputed normal and tangent (Gram-Schmidt orthonormalized)
            // 재계산된 노멀과 탄젠트 둘 다 사용 (Gram-Schmidt 정규직교화됨)
            OutNormal = RecomputedN;
            OutTangent = RecomputedT;
            return;
        }
    }

    // Fallback: If using recomputed normals only
    // 폴백: 재계산된 노멀만 사용하는 경우
    if (bUseRecomputedNormals != 0)
    {
        float3 RecomputedNormal = ReadRecomputedNormal(VertexIndex);
        if (IsRecomputedNormalValid(RecomputedNormal))
        {
            OutNormal = RecomputedNormal;
        }
    }
}

// 하위 호환용 래퍼 함수
void ReadTangentsWithRecomputedNormal(uint VertexIndex, out float3 OutNormal, out float4 OutTangent)
{
    ReadTangentsWithRecomputedNormalAndTangent(VertexIndex, OutNormal, OutTangent);
}

// Safe normalize: returns default if input is zero/near-zero
// 안전한 정규화: 입력이 0이면 기본값 반환
float3 SafeNormalize(float3 V, float3 Default)
{
    float LenSq = dot(V, V);
    return LenSq > 1e-8f ? V * rsqrt(LenSq) : Default;
}

// Write TangentX (Tangent) and TangentZ (Normal) to buffer
// 버퍼에 TangentX (탄젠트)와 TangentZ (노멀) 쓰기
// GpuSkinCommon.ush 표준: TangentX=Tangent(Index 0), TangentZ=Normal(Index 1)
void WriteTangents(uint VertexIndex, float3 Normal, float4 Tangent)
{
    uint BaseIndex = VertexIndex * 2;

    // TangentX (Index 0): Tangent direction (safe normalized) with W=0
    // 0 벡터면 (1,0,0) 기본값 사용
    float3 SafeTangentDir = SafeNormalize(Tangent.xyz, float3(1, 0, 0));
    float4 TangentX = float4(SafeTangentDir, 0.0f);

    // TangentZ (Index 1): Normal (safe normalized) with binormal sign preserved in W
    // 0 벡터면 (0,0,1) 기본값 사용
    float3 SafeNormal = SafeNormalize(Normal, float3(0, 0, 1));
    float4 TangentZ = float4(SafeNormal, Tangent.w);

    // Use TangentUnbias_SkinCache from GpuSkinCommon.ush (passthrough for SNORM, converts for OpenGL)
    OutputTangents[BaseIndex + 0] = TangentUnbias_SkinCache(TangentX);
    OutputTangents[BaseIndex + 1] = TangentUnbias_SkinCache(TangentZ);
}

// ============================================================================
// Main Compute Shader
// 메인 컴퓨트 셰이더
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    // Local vertex index within this Section's dispatch
    // 이 Section 디스패치 내의 로컬 버텍스 인덱스
    uint LocalVertexIndex = DispatchThreadId.x;

    // Bounds check: process only this Section's vertices
    // 범위 체크: 이 Section의 버텍스만 처리
    if (LocalVertexIndex >= NumVertices)
    {
        return;
    }

    // Global vertex index in LOD (for buffer access)
    // LOD 내 글로벌 버텍스 인덱스 (버퍼 접근용)
    uint GlobalVertexIndex = BaseVertexIndex + LocalVertexIndex;

    // ========================================
    // Step 1: Read Input Data
    // 1단계: 입력 데이터 읽기
    // ========================================
    // Position: TightenedBindPose (cached)
    float3 TightenedPos = ReadPosition(GlobalVertexIndex);

    // ========================================
    // Step 2: Compute Skinning Matrix
    // 2단계: 스키닝 행렬 계산
    // ========================================
    // IMPORTANT: Use GlobalVertexIndex for InputWeightStream access
    // 중요: InputWeightStream 접근에는 GlobalVertexIndex 사용
    float3x4 SkinMatrix = ComputeSkinnedMatrix(GlobalVertexIndex);

    // ========================================
    // Step 3: Apply GPU Skinning to Position
    // 3단계: GPU 스키닝을 Position에 적용
    // ========================================
    float3 SkinnedPos = TransformByMatrix(SkinMatrix, TightenedPos);

    // ========================================
    // Step 4: Write Current Position Output
    // 4단계: 현재 Position 출력 쓰기
    // ========================================
    WritePosition(GlobalVertexIndex, SkinnedPos);

    // ========================================
    // Step 5: Compute & Write Previous Position (for TAA/TSR velocity)
    // 5단계: 이전 Position 계산 및 쓰기 (TAA/TSR velocity용)
    // ========================================
    // Previous Position is needed for motion vector calculation
    // velocity = CurrentPosition - PreviousPosition
    // 이전 Position은 모션 벡터 계산에 필요함
    if (bProcessPreviousPosition != 0)
    {
        // Compute previous frame skinning matrix using previous bone matrices
        // 이전 프레임 본 행렬을 사용하여 이전 스키닝 행렬 계산
        float3x4 PreviousSkinMatrix = ComputePreviousSkinnedMatrix(GlobalVertexIndex);

        // Apply previous skinning to TightenedBindPose
        // TightenedBindPose에 이전 스키닝 적용
        float3 PreviousSkinnedPos = TransformByMatrix(PreviousSkinMatrix, TightenedPos);

        WritePreviousPosition(GlobalVertexIndex, PreviousSkinnedPos);
    }

    // ========================================
    // Step 6: Tangent processing (optional)
    // 6단계: 탄젠트 처리 (선택적)
    // ========================================
    // Tangent processing is optional (controlled by bProcessTangents flag)
    // 탄젠트 처리는 선택적 (bProcessTangents 플래그로 제어)
    if (bProcessTangents != 0)
    {
        // Read tangents (with optional recomputed normal override)
        // 탄젠트 읽기 (선택적으로 재계산된 노멀로 대체)
        float3 SourceNormal;
        float4 OriginalTangent;
        ReadTangentsWithRecomputedNormal(GlobalVertexIndex, SourceNormal, OriginalTangent);

        // Transform tangents by skinning matrix (rotation only)
        // 스키닝 행렬로 탄젠트 변환 (회전만)
        float3 SkinnedNormal = TransformDirectionByMatrix(SkinMatrix, SourceNormal);
        float3 SkinnedTangentDir = TransformDirectionByMatrix(SkinMatrix, OriginalTangent.xyz);
        float4 SkinnedTangent = float4(SkinnedTangentDir, OriginalTangent.w);

        WriteTangents(GlobalVertexIndex, SkinnedNormal, SkinnedTangent);
    }
}
