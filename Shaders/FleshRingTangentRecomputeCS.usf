// Copyright 2026 LgThx. All Rights Reserved.

// ============================================================================
// FleshRing Tangent Recompute Compute Shader
// ============================================================================
// Purpose: Recompute tangents using Gram-Schmidt orthonormalization
//
// This shader runs AFTER NormalRecomputeCS, using recomputed normals
// to orthonormalize tangents for TBN matrix consistency.
//
// Algorithm (Gram-Schmidt):
// T' = T - (T·N)N  (make T orthogonal to N)
// T' = normalize(T')
// ============================================================================

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/GpuSkinCommon.ush"

// ============================================================================
// Buffer Declarations
// ============================================================================

// Input: Recomputed normals from NormalRecomputeCS (3 floats per vertex)
Buffer<float> RecomputedNormals;

// Input: Original tangent buffer (TangentX, TangentZ per vertex)
// Format: 2 x SNORM8x4 per vertex (like StaticMeshVertexBuffer)
Buffer<float4> OriginalTangents;

// Input: Affected vertex indices to process
StructuredBuffer<uint> AffectedVertexIndices;

// Output: Recomputed tangents (8 floats per vertex: TangentX.xyzw, TangentZ.xyzw)
RWBuffer<float> OutputTangents;

// ============================================================================
// Parameters
// ============================================================================

uint NumAffectedVertices;   // Number of affected vertices to process
uint NumTotalVertices;      // Total mesh vertex count (for bounds check)

// Thread Group Size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Helper Functions
// ============================================================================

// Read recomputed normal from buffer (3 floats per vertex)
float3 ReadRecomputedNormal(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        RecomputedNormals[BaseIndex + 0],
        RecomputedNormals[BaseIndex + 1],
        RecomputedNormals[BaseIndex + 2]
    );
}

// Read original tangent data from buffer
// NOTE: UE5's StaticMeshVertexBuffer stores:
// Index0=Tangent(TangentX), Index1=Normal+sign(TangentZ)
void ReadOriginalTangents(uint VertexIndex, out float3 OutOriginalNormal, out float4 OutOriginalTangent)
{
    uint BaseIndex = VertexIndex * 2;
    // Use TangentBias_SkinCache from GpuSkinCommon.ush
    float4 TangentX = TangentBias_SkinCache(OriginalTangents[BaseIndex + 0]); // UE5: Tangent
    float4 TangentZ = TangentBias_SkinCache(OriginalTangents[BaseIndex + 1]); // UE5: Normal + binormal sign

    // Gram-Schmidt needs: Normal (to project against) and Tangent (to orthonormalize)
    OutOriginalNormal = TangentZ.xyz;  // Actual Normal is in TangentZ (Index 1)
    OutOriginalTangent = float4(TangentX.xyz, TangentZ.w);  // Actual Tangent is in TangentX (Index 0), binormal sign from TangentZ.w
}

// Write recomputed tangents to buffer (8 floats per vertex)
// NOTE: SkinningCS reads Index0-3 as "Normal" but uses it as Tangent
// To maintain consistency with SourceTangents path:
// - Index 0-3 = actual Tangent
// - Index 4-7 = actual Normal
void WriteTangents(uint VertexIndex, float4 TangentX, float4 TangentZ)
{
    // TangentX parameter = FinalNormal (from MainCS)
    // TangentZ parameter = OrthonormalizedT + BinormalSign (from MainCS)
    uint BaseIndex = VertexIndex * 8;

    // Index 0-3: Write actual Tangent (TangentZ.xyz) so SkinningCS flows it correctly
    OutputTangents[BaseIndex + 0] = TangentZ.x;  // OrthonormalizedT.x
    OutputTangents[BaseIndex + 1] = TangentZ.y;  // OrthonormalizedT.y
    OutputTangents[BaseIndex + 2] = TangentZ.z;  // OrthonormalizedT.z
    OutputTangents[BaseIndex + 3] = 0.0f;        // W unused for tangent

    // Index 4-7: Write actual Normal (TangentX.xyz) + binormal sign
    OutputTangents[BaseIndex + 4] = TangentX.x;  // FinalNormal.x
    OutputTangents[BaseIndex + 5] = TangentX.y;  // FinalNormal.y
    OutputTangents[BaseIndex + 6] = TangentX.z;  // FinalNormal.z
    OutputTangents[BaseIndex + 7] = TangentZ.w;  // binormal sign
}

// Safe normalize with fallback (returns default if zero vector)
float3 SafeNormalize(float3 V, float3 Default)
{
    float LenSq = dot(V, V);
    return LenSq > 1e-8f ? V * rsqrt(LenSq) : Default;
}

// Check if vector is valid (not zero)
bool IsVectorValid(float3 V)
{
    return dot(V, V) > 1e-8f;
}

// ============================================================================
// Gram-Schmidt Orthonormalization
// ============================================================================
// Given normal N and tangent T:
// T' = T - (T·N)N  (make T orthogonal to N)
// T' = normalize(T')
//
// This ensures TBN matrix is orthonormal even when:
// - Normal was recomputed from deformed geometry
// - Tangent is from original (undeformed) geometry
// ============================================================================

float3 GramSchmidtOrthonormalize(float3 N, float3 T)
{
    // Project out N component from T
    float3 T_ortho = T - dot(T, N) * N;

    // Normalize result
    return SafeNormalize(T_ortho, float3(1, 0, 0));
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    // Bounds check: Only process affected vertices
    if (ThreadIndex >= NumAffectedVertices)
    {
        return;
    }

    // Get the actual vertex index
    uint VertexIndex = AffectedVertexIndices[ThreadIndex];

    // Safety check: Ensure vertex index is valid
    if (VertexIndex >= NumTotalVertices)
    {
        return;
    }

    // ========================================
    // Step 1: Read recomputed normal
    // ========================================
    float3 RecomputedN = ReadRecomputedNormal(VertexIndex);

    // If recomputed normal is zero (not recomputed), use original
    float3 OriginalNormal;
    float4 OriginalTangent;
    ReadOriginalTangents(VertexIndex, OriginalNormal, OriginalTangent);

    float3 FinalNormal;
    if (IsVectorValid(RecomputedN))
    {
        FinalNormal = RecomputedN;
    }
    else
    {
        // Fallback to original normal
        FinalNormal = SafeNormalize(OriginalNormal, float3(0, 0, 1));
    }

    // ========================================
    // Step 2: Read original tangent
    // ========================================
    float3 OriginalT = OriginalTangent.xyz;
    float BinormalSign = OriginalTangent.w;

    // ========================================
    // Step 3: Compute tangent using Gram-Schmidt
    // ========================================
    float3 FinalTangent = GramSchmidtOrthonormalize(FinalNormal, OriginalT);

    // ========================================
    // Step 4: Write output
    // ========================================
    // TangentX = Normal (W = 0)
    float4 OutputTangentX = float4(FinalNormal, 0.0f);

    // TangentZ = Tangent (W = binormal sign, preserved from original)
    float4 OutputTangentZ = float4(FinalTangent, BinormalSign);

    WriteTangents(VertexIndex, OutputTangentX, OutputTangentZ);
}
