// Copyright 2026 LgThx. All Rights Reserved.

// SDFSliceVisualize.usf
// Extract Z slice from 3D SDF texture and output as color-mapped 2D texture

#include "/Engine/Public/Platform.ush"

// Input: SDF 3D texture
Texture3D<float> SDFTexture;
SamplerState SDFSampler;

// Output: Color-mapped 2D texture
RWTexture2D<float4> OutputSlice;

// Parameters
int3 SDFResolution;     // SDF texture resolution
int SliceZ;             // Z index to extract
float MaxDisplayDist;   // Maximum distance for color mapping (fully red/blue at this distance)

// Convert SDF value to color
// Negative (inside) = Blue, 0 (surface) = Black, Positive (outside) = Red
float4 SDFToColor(float sdf)
{
    // Normalize: -MaxDisplayDist ~ +MaxDisplayDist -> -1 ~ +1
    float normalized = clamp(sdf / MaxDisplayDist, -1.0f, 1.0f);

    // Apply pow for more extreme colors (faster saturation ramp)
    float t = pow(abs(normalized), 0.4f);

    float3 color;
    if (normalized < 0.0f)
    {
        // Inside (negative): Deep blue
        color = lerp(float3(0.2, 0.2, 0.2), float3(0, 0.3, 1), t);
    }
    else
    {
        // Outside (positive): Deep red
        color = lerp(float3(0.2, 0.2, 0.2), float3(1, 0.1, 0), t);
    }

    // Highlight surface area (SDF approx 0): Black outline
    float surfaceThreshold = 0.03f;
    if (abs(normalized) < surfaceThreshold)
    {
        color = float3(0, 0, 0);
    }

    return float4(color, 1.0f);
}

[numthreads(8, 8, 1)]
void MainCS(uint3 ThreadId : SV_DispatchThreadID)
{
    // Range check
    if (ThreadId.x >= (uint)SDFResolution.x || ThreadId.y >= (uint)SDFResolution.y)
        return;

    // Z slice range check
    int clampedZ = clamp(SliceZ, 0, SDFResolution.z - 1);

    // Read SDF value from 3D texture
    int3 texCoord = int3(ThreadId.x, ThreadId.y, clampedZ);
    float sdf = SDFTexture.Load(int4(texCoord, 0));

    // Convert to color and output
    OutputSlice[ThreadId.xy] = SDFToColor(sdf);
}
