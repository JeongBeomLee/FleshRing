// Copyright 2026 LgThx. All Rights Reserved.

// FleshRing Debug Point Pixel Shader
// GPU circular debug point rendering
//
// Purpose: Render circular points with influence-based color gradient

#include "/Engine/Private/Common.ush"

// Pixel shader input (from vertex shader)
struct FPSInput
{
    float4 Position : SV_POSITION;
    float2 UV : TEXCOORD0;
    float Influence : TEXCOORD1;
    nointerpolation uint ColorMode : TEXCOORD2;  // Color mode: 0 = Tightness, 1 = Bulge
    nointerpolation uint RingIndex : TEXCOORD3;  // Ring index (for visibility filtering)
};

// Visibility mask for ring filtering (unlimited ring support)
// Bitmask array for ring visibility filtering
// Each uint32 element is a visibility bitmask for 32 rings
// Element[0] = Ring 0-31, Element[1] = Ring 32-63, ...
StructuredBuffer<uint> RingVisibilityMask;
uint NumVisibilityMaskElements;

// Main pixel shader
void MainPS(
    FPSInput Input,
    out float4 OutColor : SV_Target0)
{
    // ========================================
    // Step 0: Ring visibility check (unlimited ring support)
    // ========================================
    // Each uint32 element is a visibility bitmask for 32 rings
    // MaskIndex = RingIndex / 32, BitIndex = RingIndex % 32
    uint RingIndex = Input.RingIndex;
    uint MaskIndex = RingIndex / 32u;
    uint BitIndex = RingIndex % 32u;

    // Mask array range check and visibility filtering
    if (MaskIndex < NumVisibilityMaskElements)
    {
        uint VisibleMask = RingVisibilityMask[MaskIndex];
        uint RingBit = 1u << BitIndex;

        if ((VisibleMask & RingBit) == 0u)
        {
            discard;
        }
    }
    else
    {
        // Outside mask array range - treat as invisible
        discard;
    }

    // ========================================
    // Step 0.5: Invalid point check
    // ========================================
    // Influence <= 0 means invalid/skip (e.g., early return in BulgeCS)
    if (Input.Influence <= 0.0)
    {
        discard;
    }

    // ========================================
    // Step 1: Circular mask
    // ========================================
    // UV is 0~1, center is (0.5, 0.5)
    float2 Center = float2(0.5, 0.5);
    float Dist = length(Input.UV - Center);

    // Discard pixels outside the circle
    if (Dist > 0.5)
    {
        discard;
    }

    // ========================================
    // Step 2: Influence-based color gradient
    // ========================================
    // ColorMode 0: Tightness - Blue (0) -> Green (0.5) -> Red (1)
    // ColorMode 1: Bulge - Cyan (0) -> Magenta (1)
    float3 FillColor;
    float Influence = saturate(Input.Influence);

    if (Input.ColorMode == 0)
    {
        // Tightness mode: Blue -> Green -> Red
        if (Influence < 0.5)
        {
            // Blue -> Green (0.0 ~ 0.5)
            float T = Influence * 2.0;  // 0~1 range
            FillColor = lerp(float3(0.0, 0.0, 1.0), float3(0.0, 1.0, 0.0), T);
        }
        else
        {
            // Green -> Red (0.5 ~ 1.0)
            float T = (Influence - 0.5) * 2.0;  // 0~1 range
            FillColor = lerp(float3(0.0, 1.0, 0.0), float3(1.0, 0.0, 0.0), T);
        }
    }
    else
    {
        // Bulge mode: Cyan -> Magenta
        FillColor = lerp(float3(0.0, 1.0, 1.0), float3(1.0, 0.0, 1.0), Influence);
    }

    // ========================================
    // Step 3: Black outline (outer edge)
    // ========================================
    // Outline at outer edge (0.38 ~ 0.48 radius)
    float3 OutlineColor = float3(0.0, 0.0, 0.0);
    float OutlineStart = 0.38;

    // Fill color inside, outline color at edge
    float OutlineFactor = smoothstep(OutlineStart, OutlineStart + 0.03, Dist);
    float3 Color = lerp(FillColor, OutlineColor, OutlineFactor);

    // Output final color (solid edge, no fade)
    OutColor = float4(Color, 1.0);
}
