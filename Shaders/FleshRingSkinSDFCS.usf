// Copyright 2026 LgThx. All Rights Reserved.

// ============================================================================
// FleshRingSkinSDFCS.usf - Skin SDF Based Layer Separation
// ============================================================================
// 스킨 버텍스들의 위치/노멀로 implicit surface를 정의하고,
// 스타킹 버텍스가 스킨 안쪽에 있으면 바깥으로 밀어냄
//
// 핵심 알고리즘:
// 1. 각 스타킹 버텍스에 대해 가장 가까운 스킨 버텍스 찾기
// 2. SignedDist = dot(stocking_pos - skin_pos, skin_normal)
// 3. SignedDist < MinSeparation이면 바깥으로 밀어냄
//
// 장점:
// - 삼각형 검색보다 간단하고 빠름
// - 노멀 기반으로 안쪽/바깥쪽 확실히 판단
// - 완전한 레이어 상하관계 보장
// ============================================================================

#include "/Engine/Public/Platform.ush"

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

#define EPSILON 0.0001f

// ============================================================================
// Buffer Declarations
// ============================================================================

// 버텍스 위치 (읽기/쓰기)
RWBuffer<float> PositionsRW;

// 스킨 버텍스 인덱스
Buffer<uint> SkinVertexIndices;

// 스킨 버텍스 노멀 (변형 후, 또는 방사 방향 사용)
Buffer<float> SkinNormals;

// 스타킹 버텍스 인덱스
Buffer<uint> StockingVertexIndices;

// 파라미터
uint NumStockingVertices;
uint NumSkinVertices;
uint NumTotalVertices;
float MinSeparation;      // 최소 분리 거리 (이 아래로 관통 시 밀어냄)
float TargetSeparation;   // 목표 분리 거리 (접촉 유지용)
float MaxPushDistance;    // 최대 밀어내기 거리 (per iteration)
float MaxPullDistance;    // 최대 당기기 거리 (부유 방지)
uint MaxIterations;       // 최대 반복 횟수 (조기 종료 가능)
float3 RingAxis;
float3 RingCenter;

// ============================================================================
// Helper Functions
// ============================================================================

float3 ReadPosition(uint VertexIndex)
{
    uint Base = VertexIndex * 3;
    return float3(PositionsRW[Base], PositionsRW[Base + 1], PositionsRW[Base + 2]);
}

void WritePosition(uint VertexIndex, float3 Pos)
{
    uint Base = VertexIndex * 3;
    PositionsRW[Base + 0] = Pos.x;
    PositionsRW[Base + 1] = Pos.y;
    PositionsRW[Base + 2] = Pos.z;
}

float3 ReadSkinNormal(uint SkinIdx)
{
    uint Base = SkinIdx * 3;
    return float3(SkinNormals[Base], SkinNormals[Base + 1], SkinNormals[Base + 2]);
}

// Ring 축 기준 방사 방향 계산
float3 GetRadialDirection(float3 Point)
{
    float3 ToPoint = Point - RingCenter;
    float AxisDist = dot(ToPoint, RingAxis);
    float3 AxisPoint = RingCenter + RingAxis * AxisDist;

    float3 Radial = Point - AxisPoint;
    float RadialLen = length(Radial);

    if (RadialLen < EPSILON)
        return float3(0, 0, 0);

    return Radial / RadialLen;
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void SkinSDFLayerSeparationCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint StockingIdx = DispatchThreadId.x;

    if (StockingIdx >= NumStockingVertices)
        return;

    uint StockingVertIdx = StockingVertexIndices[StockingIdx];
    float3 StockingPos = ReadPosition(StockingVertIdx);

    // 스타킹의 축 방향 높이 및 반경
    float3 ToStocking = StockingPos - RingCenter;
    float StockingHeight = dot(ToStocking, RingAxis);
    float StockingRadius = length(ToStocking - RingAxis * StockingHeight);

    // Push 방향 = 방사 방향
    float3 PushDir = GetRadialDirection(StockingPos);
    if (length(PushDir) < EPSILON)
        return;

    // ========================================
    // 같은 높이 범위의 스킨 중 가장 큰 반경 찾기
    // ========================================
    float HeightTolerance = 1.0f;  // 높이 허용 범위 (cm)
    float MaxSkinRadius = 0.0f;
    bool bFoundValidSkin = false;

    for (uint i = 0; i < NumSkinVertices; ++i)
    {
        uint SkinVertIdx = SkinVertexIndices[i];
        float3 SkinPos = ReadPosition(SkinVertIdx);

        float3 ToSkin = SkinPos - RingCenter;
        float SkinHeight = dot(ToSkin, RingAxis);

        // 높이 차이가 너무 크면 스킵
        float HeightDiff = abs(SkinHeight - StockingHeight);
        if (HeightDiff > HeightTolerance)
            continue;

        float SkinRadius = length(ToSkin - RingAxis * SkinHeight);

        // 같은 높이 범위에서 가장 큰 반경
        if (SkinRadius > MaxSkinRadius)
        {
            MaxSkinRadius = SkinRadius;
            bFoundValidSkin = true;
        }
    }

    if (!bFoundValidSkin)
        return;

    // ========================================
    // 분리 판정 (스타킹 반경 vs 최대 스킨 반경)
    // ========================================
    float RadialDist = StockingRadius - MaxSkinRadius;

    if (RadialDist < TargetSeparation)
    {
        float PushAmount = TargetSeparation - RadialDist;
        PushAmount = min(PushAmount, MaxPushDistance);
        StockingPos += PushDir * PushAmount;
    }

    WritePosition(StockingVertIdx, StockingPos);
}
