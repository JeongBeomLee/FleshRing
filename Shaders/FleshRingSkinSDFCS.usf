// Copyright 2026 LgThx. All Rights Reserved.

// ============================================================================
// FleshRingSkinSDFCS.usf - Skin SDF Based Layer Separation
// ============================================================================
// Define implicit surface from skin vertex positions/normals,
// push stocking vertices outward if they are inside the skin
//
// Core Algorithm:
// 1. For each stocking vertex, find the nearest skin vertex
// 2. SignedDist = dot(stocking_pos - skin_pos, skin_normal)
// 3. If SignedDist < MinSeparation, push outward
//
// Advantages:
// - Simpler and faster than triangle search
// - Normal-based reliable inside/outside determination
// - Guarantees complete layer hierarchy
// ============================================================================

#include "/Engine/Public/Platform.ush"

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

#define EPSILON 0.0001f

// ============================================================================
// Buffer Declarations
// ============================================================================

// Vertex positions (read/write)
RWBuffer<float> PositionsRW;

// Skin vertex indices
Buffer<uint> SkinVertexIndices;

// Skin vertex normals (after deformation, or use radial direction)
Buffer<float> SkinNormals;

// Stocking vertex indices
Buffer<uint> StockingVertexIndices;

// Parameters
uint NumStockingVertices;
uint NumSkinVertices;
uint NumTotalVertices;
float MinSeparation;      // Minimum separation distance (push if penetrating below this)
float TargetSeparation;   // Target separation distance (for maintaining contact)
float MaxPushDistance;    // Maximum push distance (per iteration)
float MaxPullDistance;    // Maximum pull distance (prevent floating)
uint MaxIterations;       // Maximum iteration count (can terminate early)
float3 RingAxis;
float3 RingCenter;

// ============================================================================
// Helper Functions
// ============================================================================

float3 ReadPosition(uint VertexIndex)
{
    uint Base = VertexIndex * 3;
    return float3(PositionsRW[Base], PositionsRW[Base + 1], PositionsRW[Base + 2]);
}

void WritePosition(uint VertexIndex, float3 Pos)
{
    uint Base = VertexIndex * 3;
    PositionsRW[Base + 0] = Pos.x;
    PositionsRW[Base + 1] = Pos.y;
    PositionsRW[Base + 2] = Pos.z;
}

float3 ReadSkinNormal(uint SkinIdx)
{
    uint Base = SkinIdx * 3;
    return float3(SkinNormals[Base], SkinNormals[Base + 1], SkinNormals[Base + 2]);
}

// Calculate radial direction relative to Ring axis
float3 GetRadialDirection(float3 Point)
{
    float3 ToPoint = Point - RingCenter;
    float AxisDist = dot(ToPoint, RingAxis);
    float3 AxisPoint = RingCenter + RingAxis * AxisDist;

    float3 Radial = Point - AxisPoint;
    float RadialLen = length(Radial);

    if (RadialLen < EPSILON)
        return float3(0, 0, 0);

    return Radial / RadialLen;
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void SkinSDFLayerSeparationCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint StockingIdx = DispatchThreadId.x;

    if (StockingIdx >= NumStockingVertices)
        return;

    uint StockingVertIdx = StockingVertexIndices[StockingIdx];
    float3 StockingPos = ReadPosition(StockingVertIdx);

    // Stocking's axial height and radius
    float3 ToStocking = StockingPos - RingCenter;
    float StockingHeight = dot(ToStocking, RingAxis);
    float StockingRadius = length(ToStocking - RingAxis * StockingHeight);

    // Push direction = radial direction
    float3 PushDir = GetRadialDirection(StockingPos);
    if (length(PushDir) < EPSILON)
        return;

    // ========================================
    // Find maximum skin radius at same height range
    // ========================================
    float HeightTolerance = 1.0f;  // Height tolerance (cm)
    float MaxSkinRadius = 0.0f;
    bool bFoundValidSkin = false;

    for (uint i = 0; i < NumSkinVertices; ++i)
    {
        uint SkinVertIdx = SkinVertexIndices[i];
        float3 SkinPos = ReadPosition(SkinVertIdx);

        float3 ToSkin = SkinPos - RingCenter;
        float SkinHeight = dot(ToSkin, RingAxis);

        // Skip if height difference is too large
        float HeightDiff = abs(SkinHeight - StockingHeight);
        if (HeightDiff > HeightTolerance)
            continue;

        float SkinRadius = length(ToSkin - RingAxis * SkinHeight);

        // Find maximum radius at same height range
        if (SkinRadius > MaxSkinRadius)
        {
            MaxSkinRadius = SkinRadius;
            bFoundValidSkin = true;
        }
    }

    if (!bFoundValidSkin)
        return;

    // ========================================
    // Separation check (stocking radius vs max skin radius)
    // ========================================
    float RadialDist = StockingRadius - MaxSkinRadius;

    if (RadialDist < TargetSeparation)
    {
        float PushAmount = TargetSeparation - RadialDist;
        PushAmount = min(PushAmount, MaxPushDistance);
        StockingPos += PushDir * PushAmount;
    }

    WritePosition(StockingVertIdx, StockingPos);
}
