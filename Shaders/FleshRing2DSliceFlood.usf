// Copyright 2026 LgThx. All Rights Reserved.

// FleshRing2DSliceFlood.usf
// 2D Slice Flood Fill - Flood from XY boundary in each Z slice to detect donut holes
// Unreached "outside" regions = donut holes = convert to inside

#include "/Engine/Public/Platform.ush"

// Pass 1: 2D Flood initialization
// Mark XY boundaries as "outside seeds" in each Z slice
// Only voxels with SDF > 0 (outside) are propagation targets
Texture3D<float> InputSDF;
RWTexture3D<uint> FloodMask;
int3 GridResolution;

[numthreads(8, 8, 8)]
void Initialize2DFloodCS(uint3 ThreadId : SV_DispatchThreadID)
{
    if (any(ThreadId >= (uint3)GridResolution))
        return;

    float sdf = InputSDF[ThreadId];

    // Mark as seed if on XY boundary and SDF > 0 (outside)
    bool isXYBoundary =
        ThreadId.x == 0 || ThreadId.x == (uint)(GridResolution.x - 1) ||
        ThreadId.y == 0 || ThreadId.y == (uint)(GridResolution.y - 1);

    if (isXYBoundary && sdf > 0.0f)
    {
        FloodMask[ThreadId] = 1u;  // Reachable from outside
    }
    else
    {
        FloodMask[ThreadId] = 0u;  // Undetermined
    }
}

// Pass 2-N: 2D Flood propagation (independent per Z slice)
// Check only 4-direction neighbors (up, down, left, right) within same Z
Texture3D<uint> FloodMaskInput;
RWTexture3D<uint> FloodMaskOutput;
Texture3D<float> SDFForFlood;

[numthreads(8, 8, 8)]
void Flood2DPassCS(uint3 ThreadId : SV_DispatchThreadID)
{
    if (any(ThreadId >= (uint3)GridResolution))
        return;

    // Already marked as outside - keep as is
    uint currentMask = FloodMaskInput[ThreadId];
    if (currentMask == 1u)
    {
        FloodMaskOutput[ThreadId] = 1u;
        return;
    }

    // SDF <= 0 (inside/surface) - no propagation
    float sdf = SDFForFlood[ThreadId];
    if (sdf <= 0.0f)
    {
        FloodMaskOutput[ThreadId] = 0u;
        return;
    }

    // Check 4-direction neighbors (same Z slice only!)
    // Up(+Y), Down(-Y), Left(-X), Right(+X)
    int2 neighbors[4] = {
        int2( 0,  1),  // Up
        int2( 0, -1),  // Down
        int2(-1,  0),  // Left
        int2( 1,  0)   // Right
    };

    [unroll]
    for (int i = 0; i < 4; i++)
    {
        int3 neighborPos = int3(
            (int)ThreadId.x + neighbors[i].x,
            (int)ThreadId.y + neighbors[i].y,
            (int)ThreadId.z  // Z is fixed!
        );

        // Range check
        if (all(neighborPos >= 0) && all(neighborPos < GridResolution))
        {
            if (FloodMaskInput[neighborPos] == 1u)
            {
                // Reachable from outside -> mark as outside
                FloodMaskOutput[ThreadId] = 1u;
                return;
            }
        }
    }

    // Unreachable -> keep undetermined
    FloodMaskOutput[ThreadId] = 0u;
}

// Pass Z-Vote: Propagate donut hole via Z-axis voting
// For each XY coordinate, check FloodMask across all Z
// If majority is "inside(0)", set all Z at that XY to "inside(0)"
// This propagates donut hole detection from center slices to top/bottom
Texture3D<uint> VoteMaskInput;
RWTexture3D<uint> VoteMaskOutput;
Texture3D<float> SDFForVote;

[numthreads(8, 8, 1)]
void ZAxisVoteCS(uint3 ThreadId : SV_DispatchThreadID)
{
    // Process XY only (iterate through all Z)
    if (ThreadId.x >= (uint)GridResolution.x || ThreadId.y >= (uint)GridResolution.y)
        return;

    // Tally votes for all Z at this XY coordinate
    int insideVotes = 0;   // Inside(0) votes
    int outsideVotes = 0;  // Outside(1) votes

    for (int z = 0; z < GridResolution.z; z++)
    {
        int3 pos = int3(ThreadId.x, ThreadId.y, z);
        float sdf = SDFForVote[pos];

        // Only voxels with SDF > 0 (outside region) participate in voting
        // SDF <= 0 (inside mesh) is excluded from voting
        if (sdf > 0.0f)
        {
            uint mask = VoteMaskInput[pos];
            if (mask == 0u)
                insideVotes++;   // Unreached in 2D Flood = donut hole candidate
            else
                outsideVotes++;  // Reached in 2D Flood = true outside
        }
    }

    // Apply voting result: If majority is "inside", set all Z at this XY to inside
    bool majorityInside = (insideVotes > outsideVotes) && (insideVotes > 0);

    for (int z2 = 0; z2 < GridResolution.z; z2++)
    {
        int3 pos = int3(ThreadId.x, ThreadId.y, z2);
        float sdf = SDFForVote[pos];

        if (majorityInside && sdf > 0.0f)
        {
            // This XY is donut hole -> set inside(0) for all Z
            VoteMaskOutput[pos] = 0u;
        }
        else
        {
            // Keep original
            VoteMaskOutput[pos] = VoteMaskInput[pos];
        }
    }
}

// Pass Final: Final sign determination
// 1. Donut hole (unreached + original positive) = flesh space = convert to negative
// 2. Tube inside (original negative) = solid ring = convert to positive
// 3. Outside (reached + original positive) = air = keep positive
Texture3D<uint> FinalFloodMask;
Texture3D<float> OriginalSDF;
RWTexture3D<float> OutputSDF;

[numthreads(8, 8, 8)]
void Finalize2DFloodCS(uint3 ThreadId : SV_DispatchThreadID)
{
    if (any(ThreadId >= (uint3)GridResolution))
        return;

    float sdf = OriginalSDF[ThreadId];
    uint mask = FinalFloodMask[ThreadId];

    // 1. Donut hole: Unreached(0) + Outside(SDF > 0) = flesh space -> convert to negative
    if (mask == 0u && sdf > 0.0f)
    {
        OutputSDF[ThreadId] = -sdf;
    }
    // 2. Tube inside: Original negative (ray casting determined as inside) = solid ring itself -> set to zero (surface)
    else if (sdf < 0.0f)
    {
        OutputSDF[ThreadId] = 0.0f;
    }
    // 3. Outside: Reached(1) + Outside(SDF > 0) = air -> keep positive
    else
    {
        OutputSDF[ThreadId] = sdf;
    }
}
