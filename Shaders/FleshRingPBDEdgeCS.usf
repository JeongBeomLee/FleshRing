// Copyright 2026 LgThx. All Rights Reserved.

// ============================================================================
// FleshRingPBDEdgeCS.usf - PBD Edge Constraint Compute Shader
// ============================================================================
// Purpose: Maintain edge lengths after deformation (prevent extreme stretching/compression)
//
// Key Concept (Tolerance-based PBD):
//   - Affected Vertices (Tightness region): FIXED (anchors) - no movement
//   - Non-Affected Vertices (extended region): FREE to move within tolerance
//   - Edge constraint only applies when length is outside tolerance range
//
// Algorithm (Jacobi iteration with Tolerance):
//   For each neighbor of this vertex:
//     1. Calculate allowed range: [RestLength * (1-Tolerance), RestLength * (1+Tolerance)]
//     2. If CurrentLength is within range: Error = 0 (no correction)
//     3. If outside range: Error = distance to nearest boundary
//     4. Calculate weights: Anchor = 0, Non-Anchor = 1
//     5. Accumulate correction based on weight ratio
//   Apply: NewPos = CurrentPos + Average(Corrections) * Stiffness
//
// Design:
//   - IsAnchor-based weighting (binary: anchor=fixed, non-anchor=free)
//   - Tolerance dead zone preserves intentional deformation
//   - Only corrects extreme stretching/compression
// ============================================================================

#include "/Engine/Public/Platform.ush"

// ============================================================================
// Constants
// ============================================================================

// Maximum neighbors per vertex
#define MAX_NEIGHBORS 12

// Thread group size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// Small epsilon to avoid division by zero
#define EPSILON 0.0001f

// ============================================================================
// Buffer Declarations
// ============================================================================

// Input: Previous iteration positions (read)
Buffer<float> InputPositions;

// Output: Current iteration positions (write)
RWBuffer<float> OutputPositions;

// Affected vertex indices (smoothing region)
StructuredBuffer<uint> AffectedIndices;

// UV Seam Welding: Representative vertex indices
// All UV seam duplicate vertices share the same representative
StructuredBuffer<uint> RepresentativeIndices;

// Per-vertex anchor flags (1 = Affected/Anchor, 0 = Non-Affected/Free)
// Affected Vertices (Tightness region) are fixed, others move freely
StructuredBuffer<uint> IsAnchorFlags;

// Full mesh anchor map (indexed by absolute vertex index)
// For neighbor anchor lookup (neighbors might not be in current region)
StructuredBuffer<uint> FullVertexAnchorFlags;

// Adjacency with rest lengths
// Format per vertex: [Count, Neighbor0, RestLen0_asUint, Neighbor1, RestLen1_asUint, ...]
// Size per vertex: 1 + MAX_NEIGHBORS * 2 = 25 uints
StructuredBuffer<uint> AdjacencyWithRestLengths;

// ============================================================================
// Parameters
// ============================================================================

uint NumAffectedVertices;
uint NumTotalVertices;
float Stiffness;

// Tolerance ratio (0.0 ~ 0.5)
// Allowed range: [RestLength * (1-Tolerance), RestLength * (1+Tolerance)]
// Example: Tolerance=0.2 -> allow 80%~120% of original length
float Tolerance;

// ============================================================================
// Helper Functions
// ============================================================================

// Read vertex position
float3 ReadPosition(Buffer<float> PositionBuffer, uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        PositionBuffer[BaseIndex + 0],
        PositionBuffer[BaseIndex + 1],
        PositionBuffer[BaseIndex + 2]
    );
}

// Write vertex position
void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

// Get adjacency data offset for a thread
uint GetAdjacencyOffset(uint ThreadIndex)
{
    // Each vertex has: [Count, (Neighbor, RestLen) x MAX_NEIGHBORS]
    // = 1 + MAX_NEIGHBORS * 2 = 25 uints
    return ThreadIndex * (1 + MAX_NEIGHBORS * 2);
}

// Get neighbor count
uint GetNeighborCount(uint AdjacencyOffset)
{
    return AdjacencyWithRestLengths[AdjacencyOffset];
}

// Get neighbor vertex index
uint GetNeighborIndex(uint AdjacencyOffset, uint NeighborSlot)
{
    // Layout: [Count, N0, RestLen0, N1, RestLen1, ...]
    return AdjacencyWithRestLengths[AdjacencyOffset + 1 + NeighborSlot * 2];
}

// Get rest length to neighbor
float GetRestLength(uint AdjacencyOffset, uint NeighborSlot)
{
    // Rest length is stored as uint (reinterpret bits)
    uint RestLenBits = AdjacencyWithRestLengths[AdjacencyOffset + 1 + NeighborSlot * 2 + 1];
    return asfloat(RestLenBits);
}

// ============================================================================
// Tolerance-based Error Calculation
// ============================================================================
// Preserve deformation within tolerance, correct only outside
// - Within range: Error = 0 (preserve deformation)
// - Too short: Error = CurrentLength - MinAllowed (negative, needs stretching)
// - Too long: Error = CurrentLength - MaxAllowed (positive, needs compression)

float CalculateToleranceError(float CurrentLength, float RestLength)
{
    float MinAllowed = RestLength * (1.0f - Tolerance);
    float MaxAllowed = RestLength * (1.0f + Tolerance);

    if (CurrentLength < MinAllowed)
    {
        // Too short -> stretch to minimum allowed length
        return CurrentLength - MinAllowed;  // negative
    }
    else if (CurrentLength > MaxAllowed)
    {
        // Too long -> compress to maximum allowed length
        return CurrentLength - MaxAllowed;  // positive
    }

    // Within tolerance -> no correction
    return 0.0f;
}

// ============================================================================
// PBD Edge Constraint Solver (Tolerance-based)
// ============================================================================

float3 SolveEdgeConstraints(
    uint ThreadIndex,
    uint MyVertexIndex,
    float3 CurrentPos,
    uint MyIsAnchor)
{
    uint AdjacencyOffset = GetAdjacencyOffset(ThreadIndex);
    uint NeighborCount = GetNeighborCount(AdjacencyOffset);

    // No neighbors = no constraints
    if (NeighborCount == 0)
    {
        return float3(0, 0, 0);
    }

    // My weight: Anchor = 0 (fixed), Non-Anchor = 1 (free)
    float MyWeight = (MyIsAnchor == 1) ? 0.0f : 1.0f;

    // If I'm an anchor, no movement at all
    if (MyWeight < EPSILON)
    {
        return float3(0, 0, 0);
    }

    float3 TotalCorrection = float3(0, 0, 0);
    float TotalEdgeCount = 0;

    for (uint i = 0; i < NeighborCount && i < MAX_NEIGHBORS; i++)
    {
        uint NeighborVertexIndex = GetNeighborIndex(AdjacencyOffset, i);

        // Bounds check
        if (NeighborVertexIndex >= NumTotalVertices)
        {
            continue;
        }

        float RestLength = GetRestLength(AdjacencyOffset, i);

        // Skip invalid rest lengths
        if (RestLength < EPSILON)
        {
            continue;
        }

        // Read neighbor position
        float3 NeighborPos = ReadPosition(InputPositions, NeighborVertexIndex);

        // Calculate edge vector and current length
        float3 EdgeVec = NeighborPos - CurrentPos;
        float CurrentLength = length(EdgeVec);

        // Skip degenerate edges
        if (CurrentLength < EPSILON)
        {
            continue;
        }

        // Edge direction (normalized)
        float3 EdgeDir = EdgeVec / CurrentLength;

        // ============================================================================
        // Tolerance-based Error Calculation
        // ============================================================================
        float Error = CalculateToleranceError(CurrentLength, RestLength);

        // Skip if within tolerance (no correction needed)
        if (abs(Error) < EPSILON)
        {
            continue;
        }

        // Neighbor's weight: Anchor = 0, Non-Anchor = 1
        uint NeighborIsAnchor = FullVertexAnchorFlags[NeighborVertexIndex];
        float NeighborWeight = (NeighborIsAnchor == 1) ? 0.0f : 1.0f;

        // Total weight for this edge
        float EdgeTotalWeight = MyWeight + NeighborWeight;

        // Skip if both are anchors (shouldn't happen since we checked MyWeight)
        if (EdgeTotalWeight < EPSILON)
        {
            continue;
        }

        // My ratio of the correction
        // MyWeight=1, NeighborWeight=0 -> MyRatio=1 (I move fully)
        // MyWeight=1, NeighborWeight=1 -> MyRatio=0.5 (split evenly)
        float MyRatio = MyWeight / EdgeTotalWeight;

        // My correction: move toward neighbor if stretched, away if compressed
        float3 Correction = EdgeDir * Error * MyRatio;

        TotalCorrection += Correction;
        TotalEdgeCount += 1.0f;
    }

    // Average the corrections
    if (TotalEdgeCount > 0)
    {
        TotalCorrection /= TotalEdgeCount;
    }

    return TotalCorrection;
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    // Bounds check
    if (ThreadIndex >= NumAffectedVertices)
    {
        return;
    }

    // Get vertex indices
    uint WriteIndex = AffectedIndices[ThreadIndex];
    uint ReadIndex = RepresentativeIndices[ThreadIndex];

    // Safety check
    if (WriteIndex >= NumTotalVertices || ReadIndex >= NumTotalVertices)
    {
        return;
    }

    // Get my anchor status
    uint MyIsAnchor = IsAnchorFlags[ThreadIndex];

    // If I'm an anchor (Affected Vertex), just copy position without modification
    if (MyIsAnchor == 1)
    {
        float3 CurrentPos = ReadPosition(InputPositions, ReadIndex);
        WritePosition(WriteIndex, CurrentPos);
        return;
    }

    // Read current position from REPRESENTATIVE vertex
    float3 CurrentPos = ReadPosition(InputPositions, ReadIndex);

    // Solve edge constraints with tolerance
    float3 Correction = SolveEdgeConstraints(ThreadIndex, ReadIndex, CurrentPos, MyIsAnchor);

    // Apply correction with stiffness
    float3 NewPos = CurrentPos + Correction * Stiffness;

    // Write output to ACTUAL vertex (WriteIndex)
    WritePosition(WriteIndex, NewPos);
}
