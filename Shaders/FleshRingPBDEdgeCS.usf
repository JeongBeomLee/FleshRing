// ============================================================================
// FleshRingPBDEdgeCS.usf - PBD Edge Constraint Compute Shader
// ============================================================================
// Purpose: Maintain edge lengths after deformation (prevent stretching/shrinking)
//
// Key Concept ("Inverse PBD" / Weighted PBD):
//   - High influence vertices (deformed by SDF): FIXED (anchors)
//   - Low influence vertices (boundary/outside): FREE to move
//   - Edge constraint pulls/pushes free vertices to maintain rest lengths
//
// Algorithm (Jacobi iteration):
//   For each neighbor of this vertex:
//     1. Calculate edge error = currentLength - restLength
//     2. Calculate weights: myWeight = 1 - myInfluence, neighborWeight = 1 - neighborInfluence
//     3. Calculate my correction ratio = myWeight / (myWeight + neighborWeight)
//     4. Accumulate correction += direction * error * myRatio
//   Apply: NewPos = CurrentPos + Average(Corrections) * Stiffness
//
// Design:
//   - Operates on SmoothingVertices (expanded region around deformation)
//   - Uses Jacobi iteration for GPU parallelism (read from input, write to output)
//   - Rest lengths stored alongside adjacency data
//   - FullInfluenceMap for neighbor influence lookup (indexed by absolute vertex index)
// ============================================================================

#include "/Engine/Public/Platform.ush"

// ============================================================================
// Constants
// ============================================================================

// Maximum neighbors per vertex
#define MAX_NEIGHBORS 12

// Thread group size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// Small epsilon to avoid division by zero
#define EPSILON 0.0001f

// ============================================================================
// Buffer Declarations
// ============================================================================

// Input: Previous iteration positions (read)
Buffer<float> InputPositions;

// Output: Current iteration positions (write)
RWBuffer<float> OutputPositions;

// Affected vertex indices (smoothing region)
StructuredBuffer<uint> AffectedIndices;

// UV Seam Welding: Representative vertex indices
// UV seam의 모든 duplicate vertex는 같은 representative를 공유
// 이를 통해 같은 위치의 모든 vertex가 동일하게 움직임
StructuredBuffer<uint> RepresentativeIndices;

// Per-vertex influence (for affected vertices, indexed by ThreadIndex)
StructuredBuffer<float> Influences;

// Per-vertex deform amount from TightnessCS (0~1, indexed by ThreadIndex)
// 많이 변형된 버텍스 = 높은 값 = 고정점(앵커), 적게 변형된 버텍스 = 낮은 값 = 자유롭게 이동
StructuredBuffer<float> DeformAmounts;

// Adjacency with rest lengths
// Format per vertex: [Count, Neighbor0, RestLen0_asUint, Neighbor1, RestLen1_asUint, ...]
// Size per vertex: 1 + MAX_NEIGHBORS * 2 = 25 uints
StructuredBuffer<uint> AdjacencyWithRestLengths;

// Full mesh influence map (indexed by absolute vertex index)
// For neighbor influence lookup (neighbors might not be in AffectedIndices)
StructuredBuffer<float> FullInfluenceMap;

// Full mesh deform amount map (indexed by absolute vertex index)
// For neighbor deform amount lookup when bUseDeformAmountWeight=1
// 전체 메시의 변형량 맵 (절대 버텍스 인덱스로 인덱싱)
StructuredBuffer<float> FullDeformAmountMap;

// ============================================================================
// Parameters
// ============================================================================

uint NumAffectedVertices;
uint NumTotalVertices;
float Stiffness;

// Flag to use DeformAmounts instead of Influences for weight calculation
// DeformAmounts 사용 여부 플래그 (0 = Influences 사용, 1 = DeformAmounts 사용)
uint bUseDeformAmountWeight;

// ============================================================================
// Helper Functions
// ============================================================================

// Read vertex position
float3 ReadPosition(Buffer<float> PositionBuffer, uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        PositionBuffer[BaseIndex + 0],
        PositionBuffer[BaseIndex + 1],
        PositionBuffer[BaseIndex + 2]
    );
}

// Write vertex position
void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

// Get adjacency data offset for a thread
uint GetAdjacencyOffset(uint ThreadIndex)
{
    // Each vertex has: [Count, (Neighbor, RestLen) x MAX_NEIGHBORS]
    // = 1 + MAX_NEIGHBORS * 2 = 25 uints
    return ThreadIndex * (1 + MAX_NEIGHBORS * 2);
}

// Get neighbor count
uint GetNeighborCount(uint AdjacencyOffset)
{
    return AdjacencyWithRestLengths[AdjacencyOffset];
}

// Get neighbor vertex index
uint GetNeighborIndex(uint AdjacencyOffset, uint NeighborSlot)
{
    // Layout: [Count, N0, RestLen0, N1, RestLen1, ...]
    return AdjacencyWithRestLengths[AdjacencyOffset + 1 + NeighborSlot * 2];
}

// Get rest length to neighbor
float GetRestLength(uint AdjacencyOffset, uint NeighborSlot)
{
    // Rest length is stored as uint (reinterpret bits)
    uint RestLenBits = AdjacencyWithRestLengths[AdjacencyOffset + 1 + NeighborSlot * 2 + 1];
    return asfloat(RestLenBits);
}

// ============================================================================
// PBD Edge Constraint Solver
// ============================================================================

// Solve all edge constraints for this vertex
// Returns accumulated correction
float3 SolveEdgeConstraints(
    uint ThreadIndex,
    uint ReadIndex,
    float3 CurrentPos,
    float MyInfluence,
    float MyDeformAmount)
{
    uint AdjacencyOffset = GetAdjacencyOffset(ThreadIndex);
    uint NeighborCount = GetNeighborCount(AdjacencyOffset);

    // No neighbors = no constraints
    if (NeighborCount == 0)
    {
        return float3(0, 0, 0);
    }

    // My weight (how much I can move)
    // ============================================================================
    // 가중치 계산 방식 선택:
    // - bUseDeformAmountWeight = 0: 기존 방식 (Influence 기반)
    //   High influence = low weight = fixed (anchor)
    // - bUseDeformAmountWeight = 1: 새 방식 (DeformAmount 기반)
    //   High deform = low weight = fixed (많이 눌린 버텍스는 고정)
    //   Low deform = high weight = free (적게 눌린 버텍스는 자유롭게 이동)
    // ============================================================================
    float MyWeight;
    if (bUseDeformAmountWeight != 0)
    {
        // 새 방식: 변형량 기반 가중치
        // 많이 변형된 버텍스(deformAmount=1)는 weight=0.2 (거의 고정)
        // 적게 변형된 버텍스(deformAmount=0)는 weight=1.0 (자유롭게 이동)
        MyWeight = lerp(1.0f, 0.2f, MyDeformAmount);
    }
    else
    {
        // 기존 방식: Influence 기반 가중치
        MyWeight = 1.0f - MyInfluence;
    }

    // If I'm completely fixed, no movement
    if (MyWeight < EPSILON)
    {
        return float3(0, 0, 0);
    }

    float3 TotalCorrection = float3(0, 0, 0);
    float TotalWeight = 0;

    for (uint i = 0; i < NeighborCount && i < MAX_NEIGHBORS; i++)
    {
        uint NeighborVertexIndex = GetNeighborIndex(AdjacencyOffset, i);

        // Bounds check
        if (NeighborVertexIndex >= NumTotalVertices)
        {
            continue;
        }

        float RestLength = GetRestLength(AdjacencyOffset, i);

        // Skip invalid rest lengths
        if (RestLength < EPSILON)
        {
            continue;
        }

        // Read neighbor position
        float3 NeighborPos = ReadPosition(InputPositions, NeighborVertexIndex);

        // Calculate edge vector and current length
        float3 EdgeVec = NeighborPos - CurrentPos;
        float CurrentLength = length(EdgeVec);

        // Skip degenerate edges
        if (CurrentLength < EPSILON)
        {
            continue;
        }

        // Edge direction (normalized)
        float3 EdgeDir = EdgeVec / CurrentLength;

        // Length error (positive = stretched, negative = compressed)
        float Error = CurrentLength - RestLength;

        // Neighbor's weight calculation
        // 이웃의 가중치 계산 (현재 버텍스와 동일한 방식 사용)
        float NeighborWeight;
        if (bUseDeformAmountWeight != 0)
        {
            // 새 방식: 변형량 기반
            float NeighborDeformAmount = FullDeformAmountMap[NeighborVertexIndex];
            NeighborWeight = lerp(1.0f, 0.2f, NeighborDeformAmount);
        }
        else
        {
            // 기존 방식: Influence 기반
            float NeighborInfluence = FullInfluenceMap[NeighborVertexIndex];
            NeighborWeight = 1.0f - NeighborInfluence;
        }

        // Total weight for this edge
        float EdgeTotalWeight = MyWeight + NeighborWeight;

        // Skip if both are fixed
        if (EdgeTotalWeight < EPSILON)
        {
            continue;
        }

        // My ratio of the correction
        // Higher MyWeight = I move more, NeighborWeight less = neighbor is anchor
        float MyRatio = MyWeight / EdgeTotalWeight;

        // My correction: move toward neighbor if stretched, away if compressed
        // Positive error (stretched) + positive direction = move toward neighbor
        float3 Correction = EdgeDir * Error * MyRatio;

        TotalCorrection += Correction;
        TotalWeight += 1.0f;
    }

    // Average the corrections
    if (TotalWeight > 0)
    {
        TotalCorrection /= TotalWeight;
    }

    return TotalCorrection;
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    // Bounds check
    if (ThreadIndex >= NumAffectedVertices)
    {
        return;
    }

    // =========================================================================
    // UV Seam Welding: 대표 버텍스 기반 읽기/쓰기 분리
    // =========================================================================
    // WriteIndex: 실제로 출력할 버텍스 인덱스 (AffectedIndices에서)
    // ReadIndex: 위치를 읽어올 대표 버텍스 인덱스 (RepresentativeIndices에서)
    //
    // 같은 Position의 모든 UV duplicate들은:
    //   - 같은 ReadIndex를 공유 (같은 위치에서 읽음)
    //   - 각자의 WriteIndex에 출력 (자기 버텍스에 씀)
    // => 결과적으로 모든 duplicate가 동일한 위치로 이동 -> UV seam crack 방지
    uint WriteIndex = AffectedIndices[ThreadIndex];
    uint ReadIndex = RepresentativeIndices[ThreadIndex];

    // Safety check
    if (WriteIndex >= NumTotalVertices || ReadIndex >= NumTotalVertices)
    {
        return;
    }

    // Read current position from REPRESENTATIVE vertex
    float3 CurrentPos = ReadPosition(InputPositions, ReadIndex);

    // Get my influence and deform amount
    float MyInfluence = Influences[ThreadIndex];
    float MyDeformAmount = (bUseDeformAmountWeight != 0) ? DeformAmounts[ThreadIndex] : 0.0f;

    // Solve edge constraints
    float3 Correction = SolveEdgeConstraints(ThreadIndex, ReadIndex, CurrentPos, MyInfluence, MyDeformAmount);

    // Apply correction with stiffness
    float3 NewPos = CurrentPos + Correction * Stiffness;

    // Write output to ACTUAL vertex (WriteIndex)
    WritePosition(WriteIndex, NewPos);
}
