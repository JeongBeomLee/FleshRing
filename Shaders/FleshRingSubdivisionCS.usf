// Copyright 2026 LgThx. All Rights Reserved.

// FleshRing Subdivision - Barycentric Interpolation Compute Shader
//
// CPU determines topology via Red-Green Refinement / LEB,
// GPU only performs actual vertex data interpolation
//
// Role division:
// - CPU: Half-Edge construction, LEB subdivision, Red-Green refinement, topology decisions
// - GPU: Position, Normal, UV, BoneWeight interpolation (massively parallel processing)

#include "/Engine/Private/Common.ush"

// ============================================================================
// Input: Source Mesh Data
// ============================================================================

Buffer<float> SourcePositions;      // x,y,z per vertex
Buffer<float> SourceNormals;        // x,y,z per vertex
Buffer<float> SourceTangents;       // x,y,z,w per vertex (w = binormal sign)
Buffer<float2> SourceUVs;           // u,v per vertex
Buffer<float> SourceBoneWeights;    // NumBoneInfluences floats per vertex
Buffer<uint> SourceBoneIndices;     // NumBoneInfluences uints per vertex

// ============================================================================
// Input: Subdivision Topology (computed on CPU)
// ============================================================================

// New vertex parent info (Structured Buffer)
// x: ParentV0, y: ParentV1, z: ParentV2
Buffer<uint> VertexParentIndices;   // 3 uints per output vertex

// Barycentric coordinates
// x: u, y: v, z: w (u + v + w = 1)
Buffer<float> VertexBarycentrics;   // 3 floats per output vertex

// ============================================================================
// Output: Subdivided Mesh Data
// ============================================================================

RWBuffer<float> OutputPositions;
RWBuffer<float> OutputNormals;
RWBuffer<float> OutputTangents;     // x,y,z,w per vertex (w = binormal sign)
RWBuffer<float2> OutputUVs;
RWBuffer<float> OutputBoneWeights;
RWBuffer<uint> OutputBoneIndices;

// ============================================================================
// Parameters
// ============================================================================

uint NumOutputVertices;
uint NumBoneInfluences;

// ============================================================================
// Helper Functions
// ============================================================================

float3 ReadSourcePosition(uint VertexIndex)
{
    return float3(
        SourcePositions[VertexIndex * 3 + 0],
        SourcePositions[VertexIndex * 3 + 1],
        SourcePositions[VertexIndex * 3 + 2]
    );
}

float3 ReadSourceNormal(uint VertexIndex)
{
    return float3(
        SourceNormals[VertexIndex * 3 + 0],
        SourceNormals[VertexIndex * 3 + 1],
        SourceNormals[VertexIndex * 3 + 2]
    );
}

float4 ReadSourceTangent(uint VertexIndex)
{
    return float4(
        SourceTangents[VertexIndex * 4 + 0],
        SourceTangents[VertexIndex * 4 + 1],
        SourceTangents[VertexIndex * 4 + 2],
        SourceTangents[VertexIndex * 4 + 3]
    );
}

void WriteOutputPosition(uint VertexIndex, float3 Position)
{
    OutputPositions[VertexIndex * 3 + 0] = Position.x;
    OutputPositions[VertexIndex * 3 + 1] = Position.y;
    OutputPositions[VertexIndex * 3 + 2] = Position.z;
}

void WriteOutputNormal(uint VertexIndex, float3 Normal)
{
    OutputNormals[VertexIndex * 3 + 0] = Normal.x;
    OutputNormals[VertexIndex * 3 + 1] = Normal.y;
    OutputNormals[VertexIndex * 3 + 2] = Normal.z;
}

void WriteOutputTangent(uint VertexIndex, float4 Tangent)
{
    OutputTangents[VertexIndex * 4 + 0] = Tangent.x;
    OutputTangents[VertexIndex * 4 + 1] = Tangent.y;
    OutputTangents[VertexIndex * 4 + 2] = Tangent.z;
    OutputTangents[VertexIndex * 4 + 3] = Tangent.w;
}

// ============================================================================
// Main Kernel: Barycentric Interpolation
// ============================================================================

[numthreads(64, 1, 1)]
void BarycentricInterpolationCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint OutputVertexIndex = DispatchThreadId.x;

    if (OutputVertexIndex >= NumOutputVertices)
        return;

    // Read parent vertex indices
    uint ParentV0 = VertexParentIndices[OutputVertexIndex * 3 + 0];
    uint ParentV1 = VertexParentIndices[OutputVertexIndex * 3 + 1];
    uint ParentV2 = VertexParentIndices[OutputVertexIndex * 3 + 2];

    // Read barycentric coordinates
    float u = VertexBarycentrics[OutputVertexIndex * 3 + 0];
    float v = VertexBarycentrics[OutputVertexIndex * 3 + 1];
    float w = VertexBarycentrics[OutputVertexIndex * 3 + 2];

    // ===== Position Interpolation =====
    float3 P0 = ReadSourcePosition(ParentV0);
    float3 P1 = ReadSourcePosition(ParentV1);
    float3 P2 = ReadSourcePosition(ParentV2);

    float3 InterpolatedPosition = P0 * u + P1 * v + P2 * w;
    WriteOutputPosition(OutputVertexIndex, InterpolatedPosition);

    // ===== Normal Interpolation =====
    float3 N0 = ReadSourceNormal(ParentV0);
    float3 N1 = ReadSourceNormal(ParentV1);
    float3 N2 = ReadSourceNormal(ParentV2);

    float3 InterpolatedNormal = normalize(N0 * u + N1 * v + N2 * w);
    WriteOutputNormal(OutputVertexIndex, InterpolatedNormal);

    // ===== UV Interpolation =====
    float2 UV0 = SourceUVs[ParentV0];
    float2 UV1 = SourceUVs[ParentV1];
    float2 UV2 = SourceUVs[ParentV2];

    float2 InterpolatedUV = UV0 * u + UV1 * v + UV2 * w;
    OutputUVs[OutputVertexIndex] = InterpolatedUV;

    // ===== Tangent Interpolation =====
    float4 T0 = ReadSourceTangent(ParentV0);
    float4 T1 = ReadSourceTangent(ParentV1);
    float4 T2 = ReadSourceTangent(ParentV2);

    // Interpolate tangent direction (xyz), take binormal sign (w) from dominant parent
    float3 InterpolatedTangentDir = normalize(T0.xyz * u + T1.xyz * v + T2.xyz * w);

    // Take binormal sign from parent with highest weight
    float BinormalSign = T0.w;
    if (v > u && v > w) BinormalSign = T1.w;
    else if (w > u && w > v) BinormalSign = T2.w;

    WriteOutputTangent(OutputVertexIndex, float4(InterpolatedTangentDir, BinormalSign));

    // ===== Bone Weight Interpolation =====
    for (uint i = 0; i < NumBoneInfluences; ++i)
    {
        float W0 = SourceBoneWeights[ParentV0 * NumBoneInfluences + i];
        float W1 = SourceBoneWeights[ParentV1 * NumBoneInfluences + i];
        float W2 = SourceBoneWeights[ParentV2 * NumBoneInfluences + i];

        float InterpolatedWeight = W0 * u + W1 * v + W2 * w;
        OutputBoneWeights[OutputVertexIndex * NumBoneInfluences + i] = InterpolatedWeight;
    }

    // ===== Bone Index Selection =====
    // Bone index is taken from parent with highest weight
    // (cannot interpolate, so use discrete selection)
    uint DominantParent = ParentV0;
    if (v > u && v > w) DominantParent = ParentV1;
    else if (w > u && w > v) DominantParent = ParentV2;

    for (uint j = 0; j < NumBoneInfluences; ++j)
    {
        OutputBoneIndices[OutputVertexIndex * NumBoneInfluences + j] =
            SourceBoneIndices[DominantParent * NumBoneInfluences + j];
    }
}

// ============================================================================
// Alternative: Edge Midpoint Only (optimized version)
// For edge midpoint only cases - simpler kernel
// ============================================================================

[numthreads(64, 1, 1)]
void EdgeMidpointInterpolationCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint OutputVertexIndex = DispatchThreadId.x;

    if (OutputVertexIndex >= NumOutputVertices)
        return;

    // Edge midpoint uses only 2 parents (V2 is ignored)
    uint ParentV0 = VertexParentIndices[OutputVertexIndex * 3 + 0];
    uint ParentV1 = VertexParentIndices[OutputVertexIndex * 3 + 1];

    // 0.5, 0.5 interpolation
    float3 P0 = ReadSourcePosition(ParentV0);
    float3 P1 = ReadSourcePosition(ParentV1);
    WriteOutputPosition(OutputVertexIndex, (P0 + P1) * 0.5);

    float3 N0 = ReadSourceNormal(ParentV0);
    float3 N1 = ReadSourceNormal(ParentV1);
    WriteOutputNormal(OutputVertexIndex, normalize(N0 + N1));

    float2 UV0 = SourceUVs[ParentV0];
    float2 UV1 = SourceUVs[ParentV1];
    OutputUVs[OutputVertexIndex] = (UV0 + UV1) * 0.5;

    // Average tangent (binormal sign from V0)
    float4 T0 = ReadSourceTangent(ParentV0);
    float4 T1 = ReadSourceTangent(ParentV1);
    float3 InterpolatedTangentDir = normalize(T0.xyz + T1.xyz);
    WriteOutputTangent(OutputVertexIndex, float4(InterpolatedTangentDir, T0.w));

    // Average bone weights
    for (uint i = 0; i < NumBoneInfluences; ++i)
    {
        float W0 = SourceBoneWeights[ParentV0 * NumBoneInfluences + i];
        float W1 = SourceBoneWeights[ParentV1 * NumBoneInfluences + i];
        OutputBoneWeights[OutputVertexIndex * NumBoneInfluences + i] = (W0 + W1) * 0.5;
    }

    // Bone index from higher weight side
    // Simply take from V0 (or add weight comparison logic)
    for (uint j = 0; j < NumBoneInfluences; ++j)
    {
        OutputBoneIndices[OutputVertexIndex * NumBoneInfluences + j] =
            SourceBoneIndices[ParentV0 * NumBoneInfluences + j];
    }
}
