// Copyright 2026 LgThx. All Rights Reserved.

// FleshRingSDFGenerate.usf
// Compute Shader to generate SDF (Signed Distance Field) from mesh triangles
// Sign determination: Multiple Ray Casting (12-direction majority voting for inside/outside)
// Reference: SDFGenerator (https://github.com/AirGuanZ/SDFGenerator)

#include "/Engine/Public/Platform.ush"

// Input data (uploaded from CPU)
StructuredBuffer<float3> MeshVertices;      // Vertex position array
StructuredBuffer<uint3> MeshIndices;        // Triangle indices (v0, v1, v2)
uint TriangleCount;                         // Total triangle count

// Output
RWTexture3D<float> OutputSDF;               // SDF 3D texture

// Parameters
float3 SDFBoundsMin;                        // SDF bounding box minimum
float3 SDFBoundsMax;                        // SDF bounding box maximum
int3 SDFResolution;                         // SDF resolution (e.g., 64x64x64)

// Ray-Triangle intersection test (Moller-Trumbore algorithm)
// Return: true if intersects, false otherwise
bool RayTriangleIntersect(float3 RayOrigin, float3 RayDir, float3 V0, float3 V1, float3 V2)
{
    const float EPSILON = 0.0000001f;

    float3 Edge1 = V1 - V0;
    float3 Edge2 = V2 - V0;

    float3 H = cross(RayDir, Edge2);
    float A = dot(Edge1, H);

    // Ray is parallel to triangle
    if (A > -EPSILON && A < EPSILON)
        return false;

    float F = 1.0f / A;
    float3 S = RayOrigin - V0;
    float U = F * dot(S, H);

    // U range check (0~1)
    if (U < 0.0f || U > 1.0f)
        return false;

    float3 Q = cross(S, Edge1);
    float V = F * dot(RayDir, Q);

    // V range check, U+V <= 1
    if (V < 0.0f || U + V > 1.0f)
        return false;

    // Distance to intersection point (T)
    float T = F * dot(Edge2, Q);

    // Intersection in ray direction (T > 0)
    return T > EPSILON;
}

// Uniformly distributed 12 directions on sphere surface (icosahedron vertex based)
static const float3 RayDirections[12] =
{
    // Icosahedron vertex directions (golden ratio based)
    normalize(float3( 0.000f,  0.526f,  0.851f)),
    normalize(float3( 0.000f,  0.526f, -0.851f)),
    normalize(float3( 0.000f, -0.526f,  0.851f)),
    normalize(float3( 0.000f, -0.526f, -0.851f)),
    normalize(float3( 0.526f,  0.851f,  0.000f)),
    normalize(float3( 0.526f, -0.851f,  0.000f)),
    normalize(float3(-0.526f,  0.851f,  0.000f)),
    normalize(float3(-0.526f, -0.851f,  0.000f)),
    normalize(float3( 0.851f,  0.000f,  0.526f)),
    normalize(float3(-0.851f,  0.000f,  0.526f)),
    normalize(float3( 0.851f,  0.000f, -0.526f)),
    normalize(float3(-0.851f,  0.000f, -0.526f))
};

static const int NumRayDirections = 12;

// Single direction Ray Casting (returns intersection count)
int CountRayIntersections(float3 VoxelPos, float3 RayDir)
{
    int IntersectionCount = 0;

    for (uint i = 0; i < TriangleCount; i++)
    {
        uint3 Indices = MeshIndices[i];
        float3 V0 = MeshVertices[Indices.x];
        float3 V1 = MeshVertices[Indices.y];
        float3 V2 = MeshVertices[Indices.z];

        if (RayTriangleIntersect(VoxelPos, RayDir, V0, V1, V2))
        {
            IntersectionCount++;
        }
    }

    return IntersectionCount;
}

// Multiple Ray Casting - Majority voting for inside/outside
// Cast rays in multiple directions -> determine by majority
// Reference: SDFGenerator (12 rays default)
float DetermineSignByMultipleRayCasting(float3 VoxelPos)
{
    int InsideVotes = 0;
    int OutsideVotes = 0;

    // Cast rays in 12 directions
    for (int r = 0; r < NumRayDirections; r++)
    {
        int intersections = CountRayIntersections(VoxelPos, RayDirections[r]);

        // Odd intersections = inside, even intersections = outside
        if (intersections % 2 == 1)
        {
            InsideVotes++;
        }
        else
        {
            OutsideVotes++;
        }
    }

    // Majority: -1 if majority inside, +1 if majority outside
    return (InsideVotes > OutsideVotes) ? -1.0f : 1.0f;
}

// Point-to-Triangle shortest distance calculation
// Reference: Real-Time Collision Detection (Christer Ericson)
float PointToTriangleDistance(float3 P, float3 A, float3 B, float3 C)
{
    // Triangle edge vectors
    float3 AB = B - A;
    float3 AC = C - A;
    float3 AP = P - A;

    // Vertex A region check
    float d1 = dot(AB, AP);
    float d2 = dot(AC, AP);
    if (d1 <= 0.0f && d2 <= 0.0f)
        return length(P - A);

    // Vertex B region check
    float3 BP = P - B;
    float d3 = dot(AB, BP);
    float d4 = dot(AC, BP);
    if (d3 >= 0.0f && d4 <= d3)
        return length(P - B);

    // Edge AB region check
    float vc = d1 * d4 - d3 * d2;
    if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f)
    {
        float v = d1 / (d1 - d3);
        return length(P - (A + v * AB));
    }

    // Vertex C region check
    float3 CP = P - C;
    float d5 = dot(AB, CP);
    float d6 = dot(AC, CP);
    if (d6 >= 0.0f && d5 <= d6)
        return length(P - C);

    // Edge AC region check
    float vb = d5 * d2 - d1 * d6;
    if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f)
    {
        float w = d2 / (d2 - d6);
        return length(P - (A + w * AC));
    }

    // Edge BC region check
    float va = d3 * d6 - d5 * d4;
    if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f)
    {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return length(P - (B + w * (C - B)));
    }

    // Projects inside triangle
    float denom = 1.0f / (va + vb + vc);
    float v = vb * denom;
    float w = vc * denom;
    float3 ClosestPoint = A + AB * v + AC * w;
    return length(P - ClosestPoint);
}

// Main Compute Shader
[numthreads(8, 8, 8)]
void MainCS(uint3 ThreadId : SV_DispatchThreadID)
{
    // Range check
    if (any(ThreadId >= (uint3)SDFResolution))
        return;

    // Calculate voxel center world coordinate
    float3 VoxelUVW = (float3(ThreadId) + 0.5f) / float3(SDFResolution);
    float3 VoxelWorldPos = SDFBoundsMin + VoxelUVW * (SDFBoundsMax - SDFBoundsMin);

    // 1. Distance calculation: minimum distance to all triangles
    float MinDistance = 999999.0f;

    for (uint i = 0; i < TriangleCount; i++)
    {
        uint3 Indices = MeshIndices[i];
        float3 V0 = MeshVertices[Indices.x];
        float3 V1 = MeshVertices[Indices.y];
        float3 V2 = MeshVertices[Indices.z];

        float Dist = PointToTriangleDistance(VoxelWorldPos, V0, V1, V2);
        MinDistance = min(MinDistance, Dist);
    }

    // 2. Sign determination: Multiple Ray Casting (12-direction majority)
    float Sign = DetermineSignByMultipleRayCasting(VoxelWorldPos);

    // 3. Store SDF value (sign * distance)
    // Donut hole correction is performed in 2D Slice Flood Fill post-processing
    OutputSDF[ThreadId] = Sign * MinDistance;
}
