// Copyright 2026 LgThx. All Rights Reserved.

// ============================================================================
// FleshRingHeatPropagationCS.usf - Heat Propagation Compute Shader
// ============================================================================
// Purpose: Propagate deformation delta from Seeds to Extended region
//
// Algorithm (Delta-based):
//   1. Init:    Seed.delta = CurrentPos - OriginalPos, Non-Seed.delta = 0
//   2. Diffuse: Non-Seed.delta = lerp(delta, neighborAvgDelta, lambda)
//   3. Apply:   Non-Seed.FinalPos = OriginalPos + delta
//
// PassType:
//   0 = Init (compute initial delta)
//   1 = Diffuse (propagate delta)
//   2 = Apply (apply delta to positions)
// ============================================================================

#include "/Engine/Public/Platform.ush"

// ============================================================================
// Constants
// ============================================================================

#define MAX_NEIGHBORS 12

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Buffer Declarations
// ============================================================================

// Pass type: 0=Init, 1=Diffuse, 2=Apply
uint PassType;

// Position buffers (Init/Apply)
Buffer<float> OriginalPositions;    // Bind pose positions (SourceData)
Buffer<float> CurrentPositions;     // Tightened positions (after TightnessCS)
RWBuffer<float> OutputPositions;    // Final output (Apply only)

// Delta buffers (Init/Diffuse)
Buffer<float> DeltaIn;              // Input delta (Diffuse only)
RWBuffer<float> DeltaOut;           // Output delta (Init/Diffuse)

// Extended region data
StructuredBuffer<uint> ExtendedIndices;     // Vertex indices in extended region
StructuredBuffer<uint> IsSeedFlags;         // 1 = Seed (anchor), 0 = Non-Seed
StructuredBuffer<uint> IsBoundarySeedFlags; // 1 = Boundary Seed (has Non-Seed neighbor), 0 = Internal Seed or Non-Seed
StructuredBuffer<uint> IsBarrierFlags;      // 1 = Barrier (blocks heat propagation), 0 = Non-Barrier
StructuredBuffer<uint> AdjacencyData;       // Neighbor info for diffusion

// UV Seam Welding: Representative vertex indices
// RepresentativeIndices[ThreadIndex] = representative vertex index for UV seam welding
// All UV duplicates at same position share the same representative
// Delta is read/written using representative index to ensure UV seam vertices move identically
StructuredBuffer<uint> RepresentativeIndices;

// Parameters
uint NumExtendedVertices;
float HeatLambda;

// ============================================================================
// Helper Functions
// ============================================================================

float3 ReadPosition(Buffer<float> PositionBuffer, uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        PositionBuffer[BaseIndex + 0],
        PositionBuffer[BaseIndex + 1],
        PositionBuffer[BaseIndex + 2]
    );
}

void WritePosition(RWBuffer<float> PositionBuffer, uint VertexIndex, float3 Position)
{
    uint BaseIndex = VertexIndex * 3;
    PositionBuffer[BaseIndex + 0] = Position.x;
    PositionBuffer[BaseIndex + 1] = Position.y;
    PositionBuffer[BaseIndex + 2] = Position.z;
}

// Delta buffers are now full mesh size (NumTotalVertices * 3)
// Use mesh vertex index for delta access
float3 ReadDeltaByVertex(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        DeltaIn[BaseIndex + 0],
        DeltaIn[BaseIndex + 1],
        DeltaIn[BaseIndex + 2]
    );
}

void WriteDeltaByVertex(uint VertexIndex, float3 Delta)
{
    uint BaseIndex = VertexIndex * 3;
    DeltaOut[BaseIndex + 0] = Delta.x;
    DeltaOut[BaseIndex + 1] = Delta.y;
    DeltaOut[BaseIndex + 2] = Delta.z;
}

uint GetNeighborCount(uint AdjacencyOffset)
{
    return AdjacencyData[AdjacencyOffset];
}

// Returns mesh vertex index (not thread index!)
uint GetNeighborVertexIndex(uint AdjacencyOffset, uint NeighborSlot)
{
    return AdjacencyData[AdjacencyOffset + 1 + NeighborSlot];
}

// ============================================================================
// Pass 0: Init - Compute initial delta
// ============================================================================
// Prevents UV duplicate race condition
//
// Problem: UV duplicates at the same position all write to the same RepIndex slot
//          A Non-Seed may overwrite delta with 0 after a Seed writes it
//
// Solution: Only Seeds write delta, Non-Seeds do nothing
//           (buffer is pre-initialized to 0 before dispatch)
//
// [Boundary Seed Propagation] Internal Seeds have delta=0, only boundary Seeds propagate
//
// Problem: Strong deformation from internal Seeds propagates beyond boundary
//          Example: Seed1(-10) --- A --- B --- Seed2(-3)
//                   B receives -8.14, larger deformation than Seed2(-3)
//
// Solution: Only boundary Seeds (Seeds with Non-Seed neighbors) set delta
//           Internal Seeds have delta=0 -> do not propagate
//           Apply Pass uses CurrentPos for Seeds so result is unaffected

void InitPass(uint ThreadIndex)
{
    uint VertexIndex = ExtendedIndices[ThreadIndex];
    uint RepIndex = RepresentativeIndices[ThreadIndex];  // Representative vertex for UV seam welding
    uint IsSeed = IsSeedFlags[ThreadIndex];
    uint IsBoundarySeed = IsBoundarySeedFlags[ThreadIndex];

    // Only boundary Seeds record delta (internal Seeds are not propagation sources)
    if (IsSeed != 0 && IsBoundarySeed != 0)
    {
        // Boundary Seed: delta = deformation amount (CurrentPos - OriginalPos)
        float3 CurrentPos = ReadPosition(CurrentPositions, VertexIndex);
        float3 OriginalPos = ReadPosition(OriginalPositions, VertexIndex);
        float3 Delta = CurrentPos - OriginalPos;

        // Write delta using REPRESENTATIVE vertex index
        WriteDeltaByVertex(RepIndex, Delta);
    }
    // Internal Seed: delta = 0 (do not propagate, buffer already 0)
    // Non-Seed/Barrier: delta = 0 (buffer already 0)
    // -> Apply Pass uses CurrentPos for Seeds so result is unaffected
}

// ============================================================================
// Pass 1: Diffuse - Propagate delta to neighbors (Max-based Propagation)
// ============================================================================
// Original Heat Diffusion problem:
//   lerp(MyDelta, NeighborAvg, lambda) -> diluted by averaging with 0-delta neighbors
//
// New algorithm (Max-based Propagation):
//   1. Find neighbor with largest magnitude delta
//   2. Apply decay for propagation (DecayFactor = 1 - HeatLambda * 0.1)
//   3. Compare with current delta, keep larger (monotonic - never decreases)
//
// Result:
//   - Iteration N = N hops propagation
//   - Exponential decay by hop distance: Delta_n = Delta_0 * DecayFactor^n
//   - DecayFactor=0.95, 50 hops -> ~8% of original retained

void DiffusePass(uint ThreadIndex)
{
    uint RepIndex = RepresentativeIndices[ThreadIndex];  // Representative vertex for UV seam welding
    uint IsSeed = IsSeedFlags[ThreadIndex];
    uint IsBarrier = IsBarrierFlags[ThreadIndex];

    // Read current delta using REPRESENTATIVE vertex index
    float3 MyDelta = ReadDeltaByVertex(RepIndex);

    if (IsSeed != 0)
    {
        // Seed: delta is fixed, no propagation
        WriteDeltaByVertex(RepIndex, MyDelta);
        return;
    }

    if (IsBarrier != 0)
    {
        // Barrier (Tightness): delta = 0 fixed, blocks propagation
        // Barrier acts as a "wall" for heat propagation - neither receives nor transmits delta
        WriteDeltaByVertex(RepIndex, float3(0, 0, 0));
        return;
    }

    // Non-Seed (Non-Barrier): propagate max delta from neighbors
    uint AdjacencyOffset = ThreadIndex * (1 + MAX_NEIGHBORS);
    uint NeighborCount = GetNeighborCount(AdjacencyOffset);

    if (NeighborCount == 0)
    {
        WriteDeltaByVertex(RepIndex, MyDelta);
        return;
    }

    // ================================================================
    // Max-based Propagation: Find neighbor with largest delta
    // ================================================================
    float3 MaxNeighborDelta = float3(0, 0, 0);
    float MaxNeighborLen = 0.0;

    for (uint i = 0; i < NeighborCount && i < MAX_NEIGHBORS; i++)
    {
        // Get neighbor's mesh vertex index from adjacency data
        // Note: Adjacency now stores REPRESENTATIVE vertex index for UV seam welding
        uint NeighborVertexIdx = GetNeighborVertexIndex(AdjacencyOffset, i);

        // Read neighbor's delta
        float3 NeighborDelta = ReadDeltaByVertex(NeighborVertexIdx);
        float NeighborLen = length(NeighborDelta);

        // Find largest magnitude delta
        if (NeighborLen > MaxNeighborLen)
        {
            MaxNeighborLen = NeighborLen;
            MaxNeighborDelta = NeighborDelta;
        }
    }

    // ================================================================
    // Apply decay to calculate propagated value
    // ================================================================
    // Convert HeatLambda to decay: lambda=0.5 -> decay=0.95
    // Formula: decay = 1.0 - HeatLambda * 0.1
    // lambda=0.0 -> decay=1.0 (no decay)
    // lambda=0.5 -> decay=0.95 (5% decay per hop)
    // lambda=1.0 -> decay=0.9 (10% decay per hop)
    float DecayFactor = 1.0 - HeatLambda * 0.1;
    float3 PropagatedDelta = MaxNeighborDelta * DecayFactor;

    // ================================================================
    // Monotonic update: Only accept larger delta (prevent decrease)
    // ================================================================
    float MyLen = length(MyDelta);
    float PropagatedLen = length(PropagatedDelta);

    float3 NewDelta;
    if (PropagatedLen > MyLen)
    {
        // Propagated value is larger - accept it
        NewDelta = PropagatedDelta;
    }
    else
    {
        // Keep existing value (monotonic - never decreases)
        NewDelta = MyDelta;
    }

    // Write delta using REPRESENTATIVE vertex index
    WriteDeltaByVertex(RepIndex, NewDelta);
}

// ============================================================================
// Pass 2: Apply - Apply diffused delta to positions
// ============================================================================

void ApplyPass(uint ThreadIndex)
{
    uint VertexIndex = ExtendedIndices[ThreadIndex];  // Actual vertex index (for output)
    uint RepIndex = RepresentativeIndices[ThreadIndex];  // Representative vertex for UV seam welding
    uint IsSeed = IsSeedFlags[ThreadIndex];
    uint IsBarrier = IsBarrierFlags[ThreadIndex];

    float3 FinalPos;
    if (IsSeed != 0)
    {
        // Seed (Bulge): Keep current deformed position (Bulge result)
        FinalPos = ReadPosition(CurrentPositions, VertexIndex);
    }
    else if (IsBarrier != 0)
    {
        // Barrier (Tightness): Keep current deformed position (Tightness result)
        // Barrier blocks heat propagation but retains its own deformation
        FinalPos = ReadPosition(CurrentPositions, VertexIndex);
    }
    else
    {
        // Non-Seed (Non-Barrier): Original position + propagated delta
        // Delta is read from REPRESENTATIVE (UV seam vertices share same delta)
        float3 OriginalPos = ReadPosition(OriginalPositions, VertexIndex);
        float3 Delta = ReadDeltaByVertex(RepIndex);
        FinalPos = OriginalPos + Delta;
    }

    // Position is output to actual vertex (each UV duplicate outputs to its own slot)
    WritePosition(OutputPositions, VertexIndex, FinalPos);
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    if (ThreadIndex >= NumExtendedVertices)
    {
        return;
    }

    if (PassType == 0)
    {
        InitPass(ThreadIndex);
    }
    else if (PassType == 1)
    {
        DiffusePass(ThreadIndex);
    }
    else if (PassType == 2)
    {
        ApplyPass(ThreadIndex);
    }
}
