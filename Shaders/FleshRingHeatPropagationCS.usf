// ============================================================================
// FleshRingHeatPropagationCS.usf - Heat Propagation Compute Shader
// ============================================================================
// Purpose: Propagate deformation delta from Seeds to Extended region
//
// Algorithm (Delta-based):
//   1. Init:    Seed.delta = CurrentPos - OriginalPos, Non-Seed.delta = 0
//   2. Diffuse: Non-Seed.delta = lerp(delta, neighborAvgDelta, lambda)
//   3. Apply:   Non-Seed.FinalPos = OriginalPos + delta
//
// PassType:
//   0 = Init (compute initial delta)
//   1 = Diffuse (propagate delta)
//   2 = Apply (apply delta to positions)
// ============================================================================

#include "/Engine/Public/Platform.ush"

// ============================================================================
// Constants
// ============================================================================

#define MAX_NEIGHBORS 12

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Buffer Declarations
// ============================================================================

// Pass type: 0=Init, 1=Diffuse, 2=Apply
uint PassType;

// Position buffers (Init/Apply)
Buffer<float> OriginalPositions;    // Bind pose positions (SourceData)
Buffer<float> CurrentPositions;     // Tightened positions (after TightnessCS)
RWBuffer<float> OutputPositions;    // Final output (Apply only)

// Delta buffers (Init/Diffuse)
Buffer<float> DeltaIn;              // Input delta (Diffuse only)
RWBuffer<float> DeltaOut;           // Output delta (Init/Diffuse)

// Extended region data
StructuredBuffer<uint> ExtendedIndices;     // Vertex indices in extended region
StructuredBuffer<uint> IsSeedFlags;         // 1 = Seed (anchor), 0 = Non-Seed
StructuredBuffer<uint> AdjacencyData;       // Neighbor info for diffusion

// UV Seam Welding: Representative vertex indices
// RepresentativeIndices[ThreadIndex] = representative vertex index for UV seam welding
// All UV duplicates at same position share the same representative
// Delta is read/written using representative index to ensure UV seam vertices move identically
StructuredBuffer<uint> RepresentativeIndices;

// Parameters
uint NumExtendedVertices;
float HeatLambda;

// ============================================================================
// Helper Functions
// ============================================================================

float3 ReadPosition(Buffer<float> PositionBuffer, uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        PositionBuffer[BaseIndex + 0],
        PositionBuffer[BaseIndex + 1],
        PositionBuffer[BaseIndex + 2]
    );
}

void WritePosition(RWBuffer<float> PositionBuffer, uint VertexIndex, float3 Position)
{
    uint BaseIndex = VertexIndex * 3;
    PositionBuffer[BaseIndex + 0] = Position.x;
    PositionBuffer[BaseIndex + 1] = Position.y;
    PositionBuffer[BaseIndex + 2] = Position.z;
}

// Delta buffers are now full mesh size (NumTotalVertices * 3)
// Use mesh vertex index for delta access
float3 ReadDeltaByVertex(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        DeltaIn[BaseIndex + 0],
        DeltaIn[BaseIndex + 1],
        DeltaIn[BaseIndex + 2]
    );
}

void WriteDeltaByVertex(uint VertexIndex, float3 Delta)
{
    uint BaseIndex = VertexIndex * 3;
    DeltaOut[BaseIndex + 0] = Delta.x;
    DeltaOut[BaseIndex + 1] = Delta.y;
    DeltaOut[BaseIndex + 2] = Delta.z;
}

uint GetNeighborCount(uint AdjacencyOffset)
{
    return AdjacencyData[AdjacencyOffset];
}

// Returns mesh vertex index (not thread index!)
uint GetNeighborVertexIndex(uint AdjacencyOffset, uint NeighborSlot)
{
    return AdjacencyData[AdjacencyOffset + 1 + NeighborSlot];
}

// ============================================================================
// Pass 0: Init - Compute initial delta
// ============================================================================

void InitPass(uint ThreadIndex)
{
    uint VertexIndex = ExtendedIndices[ThreadIndex];
    uint RepIndex = RepresentativeIndices[ThreadIndex];  // UV seam welding용 대표 버텍스
    uint IsSeed = IsSeedFlags[ThreadIndex];

    float3 Delta;
    if (IsSeed != 0)
    {
        // Seed: delta = deformation amount (CurrentPos - OriginalPos)
        // 위치는 실제 버텍스에서 읽음 (UV별로 다를 수 있음)
        float3 CurrentPos = ReadPosition(CurrentPositions, VertexIndex);
        float3 OriginalPos = ReadPosition(OriginalPositions, VertexIndex);
        Delta = CurrentPos - OriginalPos;
    }
    else
    {
        // Non-Seed: delta = 0 (will receive diffused delta)
        Delta = float3(0, 0, 0);
    }

    // Write delta using REPRESENTATIVE vertex index
    // UV seam의 모든 duplicate가 같은 slot에 쓰므로 동일한 delta 공유
    WriteDeltaByVertex(RepIndex, Delta);
}

// ============================================================================
// Pass 1: Diffuse - Propagate delta to neighbors
// ============================================================================

void DiffusePass(uint ThreadIndex)
{
    uint RepIndex = RepresentativeIndices[ThreadIndex];  // UV seam welding용 대표 버텍스
    uint IsSeed = IsSeedFlags[ThreadIndex];

    // Read current delta using REPRESENTATIVE vertex index
    float3 MyDelta = ReadDeltaByVertex(RepIndex);

    if (IsSeed != 0)
    {
        // Seed: delta is fixed, no diffusion
        WriteDeltaByVertex(RepIndex, MyDelta);
        return;
    }

    // Non-Seed: diffuse delta from neighbors
    uint AdjacencyOffset = ThreadIndex * (1 + MAX_NEIGHBORS);
    uint NeighborCount = GetNeighborCount(AdjacencyOffset);

    if (NeighborCount == 0)
    {
        WriteDeltaByVertex(RepIndex, MyDelta);
        return;
    }

    // Sum neighbor deltas
    float3 NeighborSum = float3(0, 0, 0);
    uint ValidNeighbors = 0;

    for (uint i = 0; i < NeighborCount && i < MAX_NEIGHBORS; i++)
    {
        // Get neighbor's mesh vertex index from adjacency data
        // Note: Adjacency uses mesh vertex index directly (not thread index)
        // UV seam duplicates at same position already share the same delta slot
        uint NeighborVertexIdx = GetNeighborVertexIndex(AdjacencyOffset, i);

        // Read neighbor's delta using mesh vertex index
        // (neighbor의 representative가 자기 자신이면 그대로, 아니면 representative의 delta 읽음)
        float3 NeighborDelta = ReadDeltaByVertex(NeighborVertexIdx);
        NeighborSum += NeighborDelta;
        ValidNeighbors++;
    }

    if (ValidNeighbors == 0)
    {
        WriteDeltaByVertex(RepIndex, MyDelta);
        return;
    }

    // Compute neighbor average and blend
    float3 NeighborAvg = NeighborSum / (float)ValidNeighbors;
    float3 NewDelta = lerp(MyDelta, NeighborAvg, HeatLambda);

    // Write delta using REPRESENTATIVE vertex index
    WriteDeltaByVertex(RepIndex, NewDelta);
}

// ============================================================================
// Pass 2: Apply - Apply diffused delta to positions
// ============================================================================

void ApplyPass(uint ThreadIndex)
{
    uint VertexIndex = ExtendedIndices[ThreadIndex];  // 실제 버텍스 인덱스 (출력용)
    uint RepIndex = RepresentativeIndices[ThreadIndex];  // UV seam welding용 대표 버텍스
    uint IsSeed = IsSeedFlags[ThreadIndex];

    float3 FinalPos;
    if (IsSeed != 0)
    {
        // Seed: 현재 변형된 위치 유지 (Tightness/Bulge 결과)
        FinalPos = ReadPosition(CurrentPositions, VertexIndex);
    }
    else
    {
        // Non-Seed: 원본 위치 + 전파된 delta
        // delta는 REPRESENTATIVE에서 읽음 (UV seam 버텍스들이 동일한 delta 공유)
        float3 OriginalPos = ReadPosition(OriginalPositions, VertexIndex);
        float3 Delta = ReadDeltaByVertex(RepIndex);
        FinalPos = OriginalPos + Delta;
    }

    // 위치는 실제 버텍스에 출력 (각 UV duplicate가 자기 slot에 출력)
    WritePosition(OutputPositions, VertexIndex, FinalPos);
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    if (ThreadIndex >= NumExtendedVertices)
    {
        return;
    }

    if (PassType == 0)
    {
        InitPass(ThreadIndex);
    }
    else if (PassType == 1)
    {
        DiffusePass(ThreadIndex);
    }
    else if (PassType == 2)
    {
        ApplyPass(ThreadIndex);
    }
}
