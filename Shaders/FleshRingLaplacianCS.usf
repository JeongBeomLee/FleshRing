// ============================================================================
// FleshRingLaplacianCS.usf - Laplacian Smoothing Compute Shader
// ============================================================================
// Purpose: Smooth transition at tightness boundaries
// Solves the "jagged edge" problem where some vertices move but neighbors don't
//
// Algorithm: Weighted Laplacian Smoothing
//   NewPos = lerp(CurrentPos, NeighborAverage, Lambda * Influence)
//
// Design:
//   - Operates on AffectedVertices only (not entire mesh)
//   - Uses pre-computed adjacency data from CPU
//   - Supports multiple iterations for stronger smoothing
//   - Preserves original positions for unaffected vertices
// ============================================================================

#include "/Engine/Public/Platform.ush"

// ============================================================================
// Constants
// ============================================================================

// Maximum neighbors per vertex (typical triangular mesh)
#define MAX_NEIGHBORS 12

// Thread group size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Buffer Declarations
// ============================================================================

// Input/Output: Vertex positions (read from, write to same buffer)
// Ping-pong between iterations handled externally
Buffer<float> InputPositions;
RWBuffer<float> OutputPositions;

// Input: Indices of affected vertices to process
StructuredBuffer<uint> AffectedIndices;

// UV Seam Welding: Representative vertex indices
// UV seam의 모든 duplicate vertex는 같은 representative를 공유
// 이를 통해 같은 위치의 모든 vertex가 동일하게 움직임
StructuredBuffer<uint> RepresentativeIndices;

// Input: Per-vertex influence weights (0-1)
// Used to blend between original and smoothed position
StructuredBuffer<float> Influences;

// Per-vertex deform amounts (negative=tightness, positive=bulge)
StructuredBuffer<float> DeformAmounts;

// Input: Per-vertex layer types (optional, for excluding stocking from smoothing)
// 0=Skin, 1=Stocking, 2=Underwear, 3=Outerwear, 4=Unknown
Buffer<uint> VertexLayerTypes;

// Layer type constants (must match EFleshRingLayerType in C++)
#define LAYER_SKIN       0
#define LAYER_STOCKING   1
#define LAYER_UNDERWEAR  2
#define LAYER_OUTERWEAR  3
#define LAYER_UNKNOWN    4

// ============================================================================
// Adjacency Data Structure
// ============================================================================
// GPU-friendly packed structure:
//   [NeighborCount, Neighbor0, Neighbor1, ..., Neighbor11] (13 uints per vertex)
//
// For affected vertices only, indexed by ThreadIndex (not VertexIndex)

StructuredBuffer<uint> AdjacencyData;

// ============================================================================
// Parameters
// ============================================================================

// Number of affected vertices
uint NumAffectedVertices;

// Total mesh vertex count (for bounds checking)
uint NumTotalVertices;

// Smoothing strength (lambda): 0 = no smoothing, 1 = full average
// Typical values: 0.3 - 0.7
float SmoothingLambda;

// Preserve volume: blend factor for volume preservation
// 0 = pure Laplacian, 1 = volume-preserving (HC algorithm style)
float VolumePreservation;

// Bulge smoothing factor (0=no smoothing on bulge, 1=full smoothing)
float BulgeSmoothingFactor;

// Bounds scale (for potential Z falloff, reserved for future use)
float BoundsScale;

// Exclude stocking layer from smoothing (0 = smooth all, 1 = exclude stocking)
uint bExcludeStockingFromSmoothing;

// ============================================================================
// Helper Functions
// ============================================================================

// Read vertex position from buffer (3 floats per vertex)
float3 ReadPosition(Buffer<float> PositionBuffer, uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        PositionBuffer[BaseIndex + 0],
        PositionBuffer[BaseIndex + 1],
        PositionBuffer[BaseIndex + 2]
    );
}

// Write vertex position to buffer (3 floats per vertex)
void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

// Get adjacency data for an affected vertex
// AdjacencyOffset: base offset in AdjacencyData buffer for this thread
// Returns: number of neighbors
uint GetNeighborCount(uint AdjacencyOffset)
{
    return AdjacencyData[AdjacencyOffset];
}

// Get neighbor vertex index
uint GetNeighborIndex(uint AdjacencyOffset, uint NeighborSlot)
{
    // Layout: [Count, N0, N1, N2, ..., N11]
    return AdjacencyData[AdjacencyOffset + 1 + NeighborSlot];
}

// ============================================================================
// Laplacian Smoothing
// ============================================================================

// Compute Laplacian operator: average of neighbors minus current position
// This gives the "umbrella" vector pointing toward local average
float3 ComputeLaplacian(uint ThreadIndex, uint ReadIndex, float3 CurrentPos)
{
    // Adjacency data layout: 13 uints per affected vertex
    uint AdjacencyOffset = ThreadIndex * (1 + MAX_NEIGHBORS);

    uint NeighborCount = GetNeighborCount(AdjacencyOffset);

    // No neighbors = no smoothing possible
    if (NeighborCount == 0)
    {
        return float3(0, 0, 0);
    }

    // Sum neighbor positions
    float3 NeighborSum = float3(0, 0, 0);
    uint ValidNeighbors = 0;

    for (uint i = 0; i < NeighborCount && i < MAX_NEIGHBORS; i++)
    {
        uint NeighborVertexIndex = GetNeighborIndex(AdjacencyOffset, i);

        // Bounds check
        if (NeighborVertexIndex < NumTotalVertices)
        {
            float3 NeighborPos = ReadPosition(InputPositions, NeighborVertexIndex);
            NeighborSum += NeighborPos;
            ValidNeighbors++;
        }
    }

    if (ValidNeighbors == 0)
    {
        return float3(0, 0, 0);
    }

    // Laplacian = neighbor average - current position
    float3 NeighborAverage = NeighborSum / (float)ValidNeighbors;
    return NeighborAverage - CurrentPos;
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    // Bounds check
    if (ThreadIndex >= NumAffectedVertices)
    {
        return;
    }

    // =========================================================================
    // UV Seam Welding: 대표 버텍스 기반 읽기/쓰기 분리
    // =========================================================================
    // WriteIndex: 실제로 출력할 버텍스 인덱스 (AffectedIndices에서)
    // ReadIndex: 위치를 읽어올 대표 버텍스 인덱스 (RepresentativeIndices에서)
    //
    // 같은 Position의 모든 UV duplicate들은:
    //   - 같은 ReadIndex를 공유 (같은 위치에서 읽음)
    //   - 각자의 WriteIndex에 출력 (자기 버텍스에 씀)
    // => 결과적으로 모든 duplicate가 동일한 위치로 이동 -> UV seam crack 방지
    uint WriteIndex = AffectedIndices[ThreadIndex];
    uint ReadIndex = RepresentativeIndices[ThreadIndex];

    // Safety check
    if (WriteIndex >= NumTotalVertices || ReadIndex >= NumTotalVertices)
    {
        return;
    }

    // Read current position from REPRESENTATIVE vertex
    float3 CurrentPos = ReadPosition(InputPositions, ReadIndex);

    // ===== 레이어별 스무딩 제외 =====
    // 스타킹 레이어 제외 옵션이 켜져 있으면 스타킹은 스무딩하지 않음
    if (bExcludeStockingFromSmoothing != 0)
    {
        uint LayerType = VertexLayerTypes[ReadIndex];
        if (LayerType == LAYER_STOCKING)
        {
            // 스타킹: 원래 위치 그대로 출력
            WritePosition(WriteIndex, CurrentPos);
            return;
        }
    }

    // Get influence (how much this vertex should be smoothed)
    float Influence = Influences[ThreadIndex];

    // Skip if influence is negligible
    if (Influence < 0.001)
    {
        WritePosition(WriteIndex, CurrentPos);
        return;
    }

    // ===== Bulge smoothing reduction =====
    // DeformAmounts > 0 means bulge area, reduce smoothing there
    float DeformAmount = DeformAmounts[ThreadIndex];
    float BulgeBlend = 1.0;
    if (DeformAmount > 0.0 && BulgeSmoothingFactor < 1.0)
    {
        // Linear blend: full bulge -> BulgeSmoothingFactor, zero bulge -> 1.0
        BulgeBlend = lerp(1.0, BulgeSmoothingFactor, saturate(DeformAmount));
    }

    // Compute Laplacian (direction toward neighbor average)
    float3 Laplacian = ComputeLaplacian(ThreadIndex, ReadIndex, CurrentPos);

    // Apply weighted Laplacian smoothing
    // Lambda controls overall smoothing strength
    // Influence modulates per-vertex (stronger near tightness boundaries)
    // BulgeBlend reduces smoothing in bulge areas
    float EffectiveLambda = SmoothingLambda * Influence * BulgeBlend;

    float3 SmoothedPos = CurrentPos + Laplacian * EffectiveLambda;

    // Optional: Volume preservation (HC algorithm style)
    // Pulls back toward original position to prevent shrinkage
    // Note: For full HC, would need original bind pose positions as additional input
    if (VolumePreservation > 0.001)
    {
        // Simple approximation: reduce movement magnitude
        float3 Movement = SmoothedPos - CurrentPos;
        SmoothedPos = CurrentPos + Movement * (1.0 - VolumePreservation * 0.5);
    }

    // Write output to ACTUAL vertex (WriteIndex)
    WritePosition(WriteIndex, SmoothedPos);
}
