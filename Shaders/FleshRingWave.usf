// Copyright Epic Games, Inc. All Rights Reserved.
// FleshRing Wave Deformer - GPU Skinning + Jelly Effect

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/GpuSkinCommon.ush"

// ============================================================================
// Buffer Declarations
// ============================================================================

// Vertex Data
Buffer<float> SourcePositions;      // Bind pose positions (3 floats per vertex)
RWBuffer<float> OutputPositions;    // Output positions (3 floats per vertex)

// Skinning Data (same as Optimus Skeleton Data Interface)
Buffer<float4> BoneMatrices;        // Section-specific bone buffer (3 float4 per bone)
Buffer<uint> InputWeightStream;     // Packed bone indices + weights (LOD-wide)
uint BaseVertexIndex;               // Section's base vertex index in LOD
uint NumVertices;                   // Section's vertex count
uint NumBoneInfluences;
uint InputWeightStride;             // Stride in bytes from GetConstantInfluencesVertexStride()
uint InputWeightIndexSize;          // BoneIndexByteSize | (BoneWeightByteSize << 8)

// Jelly Effect Parameters
float WaveAmplitude;
float WaveFrequency;
float Time;
float3 Velocity;
float InertiaStrength;

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Skinning Helper (from Optimus DataInterfaceSkeletonCommon.ush)
// ============================================================================

float3x4 GetBoneMatrix(uint BoneIndex)
{
    uint BufferIndex = BoneIndex * 3;
    return float3x4(BoneMatrices[BufferIndex], BoneMatrices[BufferIndex + 1], BoneMatrices[BufferIndex + 2]);
}

float3 TransformByMatrix(float3x4 Matrix, float3 Position)
{
    float4 Pos4 = float4(Position, 1.0f);
    return float3(
        dot(Matrix[0], Pos4),
        dot(Matrix[1], Pos4),
        dot(Matrix[2], Pos4)
    );
}

float3x4 ComputeSkinnedMatrix(uint GlobalVertexIndex)
{
    // Use UE's built-in functions from GpuSkinCommon.ush
    // GlobalVertexIndex is used for weight buffer (LOD-wide)
    // Bone indices from weights are Section-local, matching Section's BoneBuffer
    uint StreamOffset = GlobalVertexIndex * (InputWeightStride / 4);

    FGPUSkinIndexAndWeight IndicesAndWeights = (FGPUSkinIndexAndWeight)0;

    if (NumBoneInfluences > 0)
    {
        IndicesAndWeights.BlendIndices = GetBlendIndices(InputWeightStream, StreamOffset, 0);
        IndicesAndWeights.BlendWeights = GetBlendWeights(InputWeightStream, StreamOffset, 0, NumBoneInfluences);
    }
    if (NumBoneInfluences > 4)
    {
        IndicesAndWeights.BlendIndices2 = GetBlendIndices(InputWeightStream, StreamOffset, 1);
        IndicesAndWeights.BlendWeights2 = GetBlendWeights(InputWeightStream, StreamOffset, 1, NumBoneInfluences);
    }

    // Compute blended bone matrix (BoneMatrices is Section-specific)
    return ComputeBoneMatrixWithLimitedInfluences(BoneMatrices, IndicesAndWeights, NumBoneInfluences > 4);
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint LocalVertexIndex = DispatchThreadId.x;

    if (LocalVertexIndex >= NumVertices)
    {
        return;
    }

    // Global vertex index for LOD-wide buffers (positions, weights)
    uint GlobalVertexIndex = BaseVertexIndex + LocalVertexIndex;

    // ========================================
    // Step 1: Read Bind Pose Position (LOD-wide buffer)
    // ========================================
    uint PosIndex = GlobalVertexIndex * 3;
    float3 BindPos = float3(
        SourcePositions[PosIndex + 0],
        SourcePositions[PosIndex + 1],
        SourcePositions[PosIndex + 2]
    );

    // ========================================
    // Step 2: Apply GPU Skinning
    // (Weight buffer uses GlobalVertexIndex, BoneBuffer is Section-specific)
    // ========================================

    // GPU Skinning
    float3x4 SkinMatrix = ComputeSkinnedMatrix(GlobalVertexIndex);
    float3 Pos = TransformByMatrix(SkinMatrix, BindPos);

    // ========================================
    // Step 3: Jelly/Wobble Effect
    // ========================================

    float DistXY = sqrt(Pos.x * Pos.x + Pos.y * Pos.y);
    float DistFromCenter = length(Pos);
    float NormDist = DistFromCenter * 0.01f;

    // Velocity-based Inertia
    float Speed = length(Velocity);
    float3 VelDir = Speed > 0.001f ? Velocity / Speed : float3(0, 0, 0);
    float3 PosDir = DistFromCenter > 0.001f ? Pos / DistFromCenter : float3(0, 0, 0);
    float VelAlignment = dot(PosDir, -VelDir);

    float TrailFactor = saturate(VelAlignment * 0.5f + 0.5f);
    float LeadFactor = saturate(-VelAlignment * 0.5f + 0.5f);

    // Clamp speed to prevent extreme deformations
    float NormalizedSpeed = min(Speed * 0.001f, 5.0f);
    float InertiaScale = NormalizedSpeed * InertiaStrength * NormDist;

    // Clamp inertia offset to reasonable range
    float MaxInertiaOffset = 100.0f; // cm
    float3 InertiaOffset = -VelDir * min(InertiaScale * TrailFactor * 50.0f, MaxInertiaOffset);

    // Squash and Stretch (clamped to prevent inversion)
    float StretchAmount = 1.0f + clamp(NormalizedSpeed * InertiaStrength * 0.3f * TrailFactor, 0.0f, 1.0f);
    float SquashAmount = max(1.0f - NormalizedSpeed * InertiaStrength * 0.1f * LeadFactor, 0.5f);

    float VelComponent = dot(Pos, VelDir);
    float3 VelParallel = VelDir * VelComponent;
    float3 VelPerpendicular = Pos - VelParallel;
    float3 StretchedPos = VelParallel * StretchAmount + VelPerpendicular * SquashAmount;

    float SpeedBlend = saturate(NormalizedSpeed * 2.0f);
    Pos = lerp(Pos, StretchedPos, SpeedBlend);
    Pos += InertiaOffset;


    // Multi-frequency Wobble
    float t = Time;
    float freq = WaveFrequency;
    float amp = WaveAmplitude;

    float VelocityWobbleBoost = 1.0f + NormalizedSpeed * InertiaStrength * 0.5f;

    float wobble1 = sin(t * 1.0f + Pos.z * freq * 0.5f) * 0.5f;
    float wobble2 = cos(t * 1.3f + Pos.x * freq * 0.3f) * 0.3f;
    float wobble3 = sin(t * 0.7f + Pos.y * freq * 0.4f) * 0.4f;

    float ripple1 = sin(t * 2.5f + DistXY * freq) * 0.2f;
    float ripple2 = cos(t * 3.1f + Pos.z * freq * 2.0f) * 0.15f;
    float detail = sin(t * 5.0f + (Pos.x + Pos.y + Pos.z) * freq * 1.5f) * 0.1f;

    float totalWobble = (wobble1 + wobble2 + wobble3 + ripple1 + ripple2 + detail) * VelocityWobbleBoost;
    float distanceScale = 1.0f + NormDist * 0.5f;
    float finalScale = 1.0f + totalWobble * amp * 0.01f * distanceScale;

    float phaseX = sin(t * 1.1f + Pos.y * freq * 0.2f);
    float phaseY = cos(t * 0.9f + Pos.z * freq * 0.2f);
    float phaseZ = sin(t * 1.2f + Pos.x * freq * 0.2f);

    float displaceX = phaseX * amp * 0.3f * (1.0f + wobble1 * 0.5f);
    float displaceY = phaseY * amp * 0.3f * (1.0f + wobble2 * 0.5f);
    float displaceZ = phaseZ * amp * 0.5f * (1.0f + wobble3 * 0.5f);

    float3 FinalPos = float3(
        Pos.x * finalScale + displaceX,
        Pos.y * finalScale + displaceY,
        Pos.z * finalScale + displaceZ
    );

    // ========================================
    // Step 4: Write Output (LOD-wide buffer)
    // ========================================
    OutputPositions[PosIndex + 0] = FinalPos.x;
    OutputPositions[PosIndex + 1] = FinalPos.y;
    OutputPositions[PosIndex + 2] = FinalPos.z;
}
