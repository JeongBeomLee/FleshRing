// ============================================================================
// FleshRing Normal Recompute Compute Shader
// FleshRing 노멀 재계산 컴퓨트 셰이더
// ============================================================================
// Purpose: Recompute vertex normals using surface rotation method
// 목적: 표면 회전 방식을 사용하여 버텍스 노멀 재계산
//
// This shader runs AFTER TightnessCS and BulgeCS, using the final deformed positions
// to calculate accurate normals for affected vertices only.
// TightnessCS와 BulgeCS 이후에 실행되며, 최종 변형된 위치를 사용하여
// 영향받은 버텍스에 대해서만 정확한 노멀을 계산합니다.
//
// Algorithm (Surface Rotation Method):
// 알고리즘 (표면 회전 방식):
// 1. For each affected vertex, find all adjacent triangles
//    각 영향받은 버텍스에 대해 모든 인접 삼각형 찾기
// 2. Compute face normal for each adjacent triangle (both original and deformed)
//    각 인접 삼각형에 대해 Face Normal 계산 (원본과 변형 모두)
// 3. Accumulate face normals (area-weighted)
//    Face Normal 누적 (면적 가중)
// 4. Calculate rotation from original face normal to deformed face normal
//    원본 Face Normal에서 변형된 Face Normal로의 회전 계산
// 5. Apply this rotation to the original vertex normal
//    이 회전을 원본 버텍스 노멀에 적용
//
// This preserves smooth shading by adjusting normals based on surface deformation,
// rather than replacing them with flat face normal averages.
// 이 방식은 노말을 평평한 face normal 평균으로 대체하는 대신,
// 표면 변형에 기반하여 조정함으로써 스무스 셰이딩을 보존합니다.
// ============================================================================

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/GpuSkinCommon.ush"

// ============================================================================
// Buffer Declarations
// 버퍼 선언
// ============================================================================

// Input: Deformed vertex positions (from TightnessCS/BulgeCS)
// 입력: 변형된 버텍스 위치 (TightnessCS/BulgeCS 결과)
Buffer<float> DeformedPositions;

// Input: Original vertex positions (bind pose) - for calculating original face normals
// 입력: 원본 버텍스 위치 (바인드 포즈) - 원본 Face Normal 계산용
Buffer<float> OriginalPositions;

// Input: Affected vertex indices to process
// 입력: 처리할 영향받는 버텍스 인덱스
StructuredBuffer<uint> AffectedVertexIndices;

// Input: Adjacency offsets - AdjacencyOffsets[i] = start index in AdjacencyTriangles for vertex i
// 입력: 인접 오프셋 - 각 버텍스의 인접 삼각형 시작 인덱스
// AdjacencyOffsets[i] to AdjacencyOffsets[i+1] = range of adjacent triangles for vertex i
StructuredBuffer<uint> AdjacencyOffsets;

// Input: Flattened list of adjacent triangle indices
// 입력: 인접 삼각형 인덱스의 평탄화된 리스트
StructuredBuffer<uint> AdjacencyTriangles;

// Input: Mesh index buffer (3 indices per triangle)
// 입력: 메시 인덱스 버퍼 (삼각형당 3개 인덱스)
Buffer<uint> IndexBuffer;

// Input: Original tangent buffer (contains normals) - packed SNORM8x4 format
// 입력: 원본 탄젠트 버퍼 (노멀 포함) - 패킹된 SNORM8x4 포맷
// Format: TangentX (Index 0), TangentZ=Normal+BinormalSign (Index 1) per vertex
Buffer<float4> OriginalTangents;

// Output: Recomputed normals (float3 per vertex)
// 출력: 재계산된 노멀 (버텍스당 float3)
RWBuffer<float> OutputNormals;

// ============================================================================
// Parameters
// 파라미터
// ============================================================================

uint NumAffectedVertices;   // Number of affected vertices to process
                            // 처리할 영향받는 버텍스 수
uint NumTotalVertices;      // Total mesh vertex count (for bounds check)
                            // 전체 메시 버텍스 수 (범위 체크용)
uint bUseGeometricMethod;   // 0 = Surface Rotation, 1 = Geometric (Face Normal Average)
                            // 0 = 표면 회전 방식, 1 = 지오메트릭 방식 (Face Normal 평균)

// Thread Group Size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Helper Functions
// 헬퍼 함수
// ============================================================================

// Read deformed vertex position from buffer (3 floats per vertex)
// 버퍼에서 변형된 버텍스 위치 읽기 (버텍스당 3 float)
float3 ReadDeformedPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        DeformedPositions[BaseIndex + 0],
        DeformedPositions[BaseIndex + 1],
        DeformedPositions[BaseIndex + 2]
    );
}

// Read original vertex position from buffer (3 floats per vertex)
// 버퍼에서 원본 버텍스 위치 읽기 (버텍스당 3 float)
float3 ReadOriginalPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        OriginalPositions[BaseIndex + 0],
        OriginalPositions[BaseIndex + 1],
        OriginalPositions[BaseIndex + 2]
    );
}

// Read original normal from tangent buffer (packed SNORM8x4 format)
// 탄젠트 버퍼에서 원본 노멀 읽기 (패킹된 SNORM8x4 포맷)
// Format: TangentX at Index 0, TangentZ (Normal + binormal sign) at Index 1
float3 ReadOriginalNormal(uint VertexIndex)
{
    // TangentZ is at Index 1 (2 float4 per vertex)
    // TangentZ는 Index 1에 있음 (버텍스당 2개의 float4)
    uint BaseIndex = VertexIndex * 2;
    float4 TangentZ = TangentBias_SkinCache(OriginalTangents[BaseIndex + 1]);
    return TangentZ.xyz;  // xyz = normal, w = binormal sign
}

// Write vertex normal to buffer (3 floats per vertex)
// 버퍼에 버텍스 노멀 쓰기 (버텍스당 3 float)
void WriteNormal(uint VertexIndex, float3 Normal)
{
    uint BaseIndex = VertexIndex * 3;
    OutputNormals[BaseIndex + 0] = Normal.x;
    OutputNormals[BaseIndex + 1] = Normal.y;
    OutputNormals[BaseIndex + 2] = Normal.z;
}

// Compute face normal for a triangle (CCW winding = front face in UE)
// 삼각형의 Face Normal 계산 (UE에서 CCW 와인딩 = front face)
// Returns unnormalized normal (length = 2 * triangle area) for area-weighted average
// 면적 가중 평균을 위해 정규화되지 않은 노멀 반환 (길이 = 2 * 삼각형 면적)
//
// IMPORTANT: UE uses LEFT-HANDED coordinate system!
// 중요: UE는 왼손 좌표계를 사용합니다!
// In left-handed system with CCW winding:
// - cross(Edge1, Edge2) points INWARD (wrong direction)
// - cross(Edge2, Edge1) points OUTWARD (correct direction)
// 왼손 좌표계 + CCW 와인딩:
// - cross(Edge1, Edge2) = 내부 방향 (틀림)
// - cross(Edge2, Edge1) = 외부 방향 (맞음)
float3 ComputeFaceNormal(float3 P0, float3 P1, float3 P2)
{
    float3 Edge1 = P1 - P0;
    float3 Edge2 = P2 - P0;
    // Use cross(Edge2, Edge1) for outward normal in UE's left-handed system
    // UE 왼손 좌표계에서 외부 방향 노멀을 위해 cross(Edge2, Edge1) 사용
    return cross(Edge2, Edge1);
}

// Safe normalize with fallback
// 안전한 정규화 (0 벡터 시 기본값 반환)
float3 SafeNormalize(float3 V, float3 Default)
{
    float LenSq = dot(V, V);
    return LenSq > 1e-8f ? V * rsqrt(LenSq) : Default;
}

// ============================================================================
// Rotation Functions (Rodrigues' Rotation Formula)
// 회전 함수 (로드리게스 회전 공식)
// ============================================================================
// Given two unit vectors (From, To), rotate vector V by the same rotation
// that would align From to To.
// 두 단위 벡터(From, To)가 주어지면, From을 To로 정렬하는 것과 동일한
// 회전을 벡터 V에 적용합니다.

// Rotate vector V such that direction From maps to direction To
// From 방향이 To 방향으로 매핑되도록 벡터 V를 회전
float3 RotateVectorByNormalChange(float3 V, float3 From, float3 To)
{
    // Calculate cosine of angle between normals
    // 두 노멀 사이의 각도 코사인 계산
    float cosAngle = dot(From, To);

    // If nearly parallel (no rotation needed)
    // 거의 평행한 경우 (회전 불필요)
    if (cosAngle > 0.9999f)
    {
        return V;
    }

    // If nearly anti-parallel (180 degree rotation)
    // 거의 반대 방향인 경우 (180도 회전)
    if (cosAngle < -0.9999f)
    {
        // Find a perpendicular axis for 180 degree rotation
        // 180도 회전을 위한 수직 축 찾기
        float3 axis = abs(From.x) < 0.9f ?
            normalize(cross(From, float3(1, 0, 0))) :
            normalize(cross(From, float3(0, 1, 0)));
        // Rotate 180 degrees around axis: V -> -V + 2*(V·axis)*axis
        // 축 주위로 180도 회전: V -> -V + 2*(V·axis)*axis
        return 2.0f * dot(V, axis) * axis - V;
    }

    // Standard case: Rodrigues' rotation formula
    // 일반 경우: 로드리게스 회전 공식
    // R(v) = v*cos(θ) + (k×v)*sin(θ) + k*(k·v)*(1-cos(θ))
    // where k is the normalized rotation axis (From × To normalized)

    float3 crossProduct = cross(From, To);
    float sinAngle = length(crossProduct);

    // If sin is too small, no significant rotation
    // sin이 너무 작으면 유의미한 회전 없음
    if (sinAngle < 1e-6f)
    {
        return V;
    }

    float3 axis = crossProduct / sinAngle;  // Normalized rotation axis

    // Rodrigues' formula
    // 로드리게스 공식
    float3 vRotated = V * cosAngle
                    + cross(axis, V) * sinAngle
                    + axis * dot(axis, V) * (1.0f - cosAngle);

    return vRotated;
}

// ============================================================================
// Main Compute Shader
// 메인 컴퓨트 셰이더
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    // Bounds check: Only process affected vertices
    // 범위 체크: 영향받는 버텍스만 처리
    if (ThreadIndex >= NumAffectedVertices)
    {
        return;
    }

    // Get the actual vertex index
    // 실제 버텍스 인덱스 가져오기
    uint VertexIndex = AffectedVertexIndices[ThreadIndex];

    // Safety check: Ensure vertex index is valid
    // 안전 체크: 버텍스 인덱스 유효성 확인
    if (VertexIndex >= NumTotalVertices)
    {
        return;
    }

    // Get adjacent triangle range
    // 인접 삼각형 범위 가져오기
    uint AdjStart = AdjacencyOffsets[ThreadIndex];
    uint AdjEnd = AdjacencyOffsets[ThreadIndex + 1];

    // ========================================
    // Branch by method for optimal performance
    // 최적 성능을 위해 방식별 분기
    // ========================================
    if (bUseGeometricMethod != 0)
    {
        // ========================================
        // Geometric Method: Deformed face normal average only
        // 지오메트릭 방식: 변형된 Face Normal 평균만 계산
        // ========================================
        // Original 데이터 읽기/계산 완전 생략 → 메모리 대역폭 절약

        // No adjacent triangles - use default normal
        // 인접 삼각형 없음 - 기본 노멀 사용
        if (AdjStart >= AdjEnd)
        {
            WriteNormal(VertexIndex, float3(0, 0, 1));
            return;
        }

        float3 DeformedFaceNormalSum = float3(0, 0, 0);

        for (uint i = AdjStart; i < AdjEnd; i++)
        {
            uint TriIndex = AdjacencyTriangles[i];

            uint I0 = IndexBuffer[TriIndex * 3 + 0];
            uint I1 = IndexBuffer[TriIndex * 3 + 1];
            uint I2 = IndexBuffer[TriIndex * 3 + 2];

            if (I0 >= NumTotalVertices || I1 >= NumTotalVertices || I2 >= NumTotalVertices)
            {
                continue;
            }

            // Deformed positions only (Original 생략)
            float3 DefP0 = ReadDeformedPosition(I0);
            float3 DefP1 = ReadDeformedPosition(I1);
            float3 DefP2 = ReadDeformedPosition(I2);

            float3 DefFaceNormal = ComputeFaceNormal(DefP0, DefP1, DefP2);

            // Check for degenerate triangle
            if (dot(DefFaceNormal, DefFaceNormal) < 1e-12f)
            {
                continue;
            }

            DeformedFaceNormalSum += DefFaceNormal;
        }

        // Normalize and write
        float3 FinalNormal = SafeNormalize(DeformedFaceNormalSum, float3(0, 0, 1));
        WriteNormal(VertexIndex, FinalNormal);
    }
    else
    {
        // ========================================
        // Surface Rotation Method: Original + Deformed 모두 필요
        // 표면 회전 방식: 원본과 변형 Face Normal 비교하여 회전량 계산
        // ========================================

        // Get original smooth vertex normal (회전시킬 대상)
        float3 OriginalVertexNormal = ReadOriginalNormal(VertexIndex);

        // If original normal is invalid, fallback
        float OriginalNormalLenSq = dot(OriginalVertexNormal, OriginalVertexNormal);
        if (OriginalNormalLenSq < 1e-8f)
        {
            WriteNormal(VertexIndex, float3(0, 0, 1));
            return;
        }
        OriginalVertexNormal = normalize(OriginalVertexNormal);

        // No adjacent triangles - use original normal
        if (AdjStart >= AdjEnd)
        {
            WriteNormal(VertexIndex, OriginalVertexNormal);
            return;
        }

        float3 OriginalFaceNormalSum = float3(0, 0, 0);
        float3 DeformedFaceNormalSum = float3(0, 0, 0);
        uint ValidFaceCount = 0;

        for (uint i = AdjStart; i < AdjEnd; i++)
        {
            uint TriIndex = AdjacencyTriangles[i];

            uint I0 = IndexBuffer[TriIndex * 3 + 0];
            uint I1 = IndexBuffer[TriIndex * 3 + 1];
            uint I2 = IndexBuffer[TriIndex * 3 + 2];

            if (I0 >= NumTotalVertices || I1 >= NumTotalVertices || I2 >= NumTotalVertices)
            {
                continue;
            }

            // Original positions (Surface Rotation에서만 필요)
            float3 OrigP0 = ReadOriginalPosition(I0);
            float3 OrigP1 = ReadOriginalPosition(I1);
            float3 OrigP2 = ReadOriginalPosition(I2);

            // Deformed positions
            float3 DefP0 = ReadDeformedPosition(I0);
            float3 DefP1 = ReadDeformedPosition(I1);
            float3 DefP2 = ReadDeformedPosition(I2);

            float3 OrigFaceNormal = ComputeFaceNormal(OrigP0, OrigP1, OrigP2);
            float3 DefFaceNormal = ComputeFaceNormal(DefP0, DefP1, DefP2);

            // Check for degenerate triangles
            float OrigFaceNormalLenSq = dot(OrigFaceNormal, OrigFaceNormal);
            float DefFaceNormalLenSq = dot(DefFaceNormal, DefFaceNormal);
            if (OrigFaceNormalLenSq < 1e-12f || DefFaceNormalLenSq < 1e-12f)
            {
                continue;
            }

            OriginalFaceNormalSum += OrigFaceNormal;
            DeformedFaceNormalSum += DefFaceNormal;
            ValidFaceCount++;
        }

        if (ValidFaceCount == 0)
        {
            WriteNormal(VertexIndex, OriginalVertexNormal);
            return;
        }

        float3 OriginalFaceNormalAvg = SafeNormalize(OriginalFaceNormalSum, float3(0, 0, 1));
        float3 DeformedFaceNormalAvg = SafeNormalize(DeformedFaceNormalSum, float3(0, 0, 1));

        // Apply rotation from original to deformed face normal
        float3 RotatedNormal = RotateVectorByNormalChange(
            OriginalVertexNormal,
            OriginalFaceNormalAvg,
            DeformedFaceNormalAvg
        );

        float3 FinalNormal = SafeNormalize(RotatedNormal, OriginalVertexNormal);
        WriteNormal(VertexIndex, FinalNormal);
    }
}
