// Copyright 2026 LgThx. All Rights Reserved.

// ============================================================================
// FleshRing Normal Recompute Compute Shader
// FleshRing 노멀 재계산 컴퓨트 셰이더
// ============================================================================
// Purpose: Recompute vertex normals using various methods
// 목적: 다양한 방식으로 버텍스 노멀 재계산
//
// Supported Methods:
// 지원 방식:
// - Geometric (0): Face Normal average - TBN accurate
// - SurfaceRotation (1): Rotate original normal by face normal change
// - PolarDecomposition (2): Extract pure rotation from deformation gradient
//
// This shader runs AFTER TightnessCS and BulgeCS, using the final deformed positions
// to calculate accurate normals for affected vertices only.
// TightnessCS와 BulgeCS 이후에 실행되며, 최종 변형된 위치를 사용하여
// 영향받은 버텍스에 대해서만 정확한 노멀을 계산합니다.
// ============================================================================

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/GpuSkinCommon.ush"

// ============================================================================
// Mode Constants
// 모드 상수
// ============================================================================
#define MODE_GEOMETRIC          0
#define MODE_SURFACE_ROTATION   1
#define MODE_POLAR_DECOMPOSITION 2  // [DEPRECATED] SurfaceRotation으로 fallback됨

// ============================================================================
// Buffer Declarations
// 버퍼 선언
// ============================================================================

// Input: Deformed vertex positions (from TightnessCS/BulgeCS)
// 입력: 변형된 버텍스 위치 (TightnessCS/BulgeCS 결과)
Buffer<float> DeformedPositions;

// Input: Original vertex positions (bind pose) - for calculating original face normals
// 입력: 원본 버텍스 위치 (바인드 포즈) - 원본 Face Normal 계산용
Buffer<float> OriginalPositions;

// Input: Affected vertex indices to process
// 입력: 처리할 영향받는 버텍스 인덱스
StructuredBuffer<uint> AffectedVertexIndices;

// Input: Adjacency offsets - AdjacencyOffsets[i] = start index in AdjacencyTriangles for vertex i
// 입력: 인접 오프셋 - 각 버텍스의 인접 삼각형 시작 인덱스
// AdjacencyOffsets[i] to AdjacencyOffsets[i+1] = range of adjacent triangles for vertex i
StructuredBuffer<uint> AdjacencyOffsets;

// Input: Flattened list of adjacent triangle indices
// 입력: 인접 삼각형 인덱스의 평탄화된 리스트
StructuredBuffer<uint> AdjacencyTriangles;

// Input: Mesh index buffer (3 indices per triangle)
// 입력: 메시 인덱스 버퍼 (삼각형당 3개 인덱스)
Buffer<uint> IndexBuffer;

// Input: Original tangent buffer (contains normals) - packed SNORM8x4 format
// 입력: 원본 탄젠트 버퍼 (노멀 포함) - 패킹된 SNORM8x4 포맷
// Format: TangentX (Index 0), TangentZ=Normal+BinormalSign (Index 1) per vertex
Buffer<float4> OriginalTangents;

// Output: Recomputed normals (float3 per vertex)
// 출력: 재계산된 노멀 (버텍스당 float3)
RWBuffer<float> OutputNormals;

// Input: Hop distances for each affected vertex (optional, for blending)
// 입력: 각 영향받는 버텍스의 홉 거리 (블렌딩용, 선택적)
StructuredBuffer<int> HopDistances;

// Input: Representative vertex indices for UV seam welding (optional)
// 입력: UV seam welding용 대표 버텍스 인덱스 (선택적)
// Maps each affected vertex to its representative (same position, different UV)
// 각 affected 버텍스를 대표 버텍스에 매핑 (같은 위치, 다른 UV)
StructuredBuffer<uint> RepresentativeIndices;

// ============================================================================
// Parameters
// 파라미터
// ============================================================================

uint NumAffectedVertices;   // Number of affected vertices to process
                            // 처리할 영향받는 버텍스 수
uint NumTotalVertices;      // Total mesh vertex count (for bounds check)
                            // 전체 메시 버텍스 수 (범위 체크용)
uint NormalRecomputeMode;   // 0 = Geometric, 1 = SurfaceRotation, 2 = PolarDecomposition
                            // 0 = 지오메트릭, 1 = 표면 회전, 2 = Polar 분해
uint bEnableHopBlending;    // 0 = off, 1 = on (blend with original at boundary)
                            // 홉 기반 블렌딩: 경계에서 원본 노멀과 블렌드
uint MaxHops;               // Maximum hop distance (for blend factor calculation)
                            // 최대 홉 거리 (블렌드 계수 계산용)
uint FalloffType;           // 0 = Linear, 1 = Quadratic, 2 = Hermite
                            // falloff 타입: 0=선형, 1=2차곡선, 2=Hermite
uint bEnableUVSeamWelding;  // 0 = off, 1 = on (use RepresentativeIndices for UV seam)
                            // UV seam welding: 대표 버텍스의 노멀을 복사
uint bEnableDisplacementBlending;  // 0 = off, 1 = on (blend based on vertex displacement)
                                   // 변위 기반 블렌딩: 버텍스 이동량에 따라 블렌드
float MaxDisplacement;      // Maximum displacement for blend (cm)
                            // 최대 변위 거리 (cm) - 이 거리 이상 이동 시 100% 재계산된 노멀 사용

// Thread Group Size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Helper Functions
// 헬퍼 함수
// ============================================================================

// Apply falloff curve to normalized distance t [0, 1]
// 정규화된 거리 t [0, 1]에 falloff 곡선 적용
// FalloffType: 0 = Linear, 1 = Quadratic, 2 = Hermite (smoothstep)
float ApplyFalloff(float t, uint InFalloffType)
{
    // t: 0 at center (HopDist=0), 1 at boundary (HopDist=MaxHops)
    // t: 중심(HopDist=0)에서 0, 경계(HopDist=MaxHops)에서 1
    t = saturate(t);

    if (InFalloffType == 0)  // Linear
    {
        return t;
    }
    else if (InFalloffType == 1)  // Quadratic
    {
        return t * t;
    }
    else  // Hermite (smoothstep) - default
    {
        // smoothstep: 3t^2 - 2t^3
        return t * t * (3.0 - 2.0 * t);
    }
}

// Read deformed vertex position from buffer (3 floats per vertex)
// 버퍼에서 변형된 버텍스 위치 읽기 (버텍스당 3 float)
float3 ReadDeformedPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        DeformedPositions[BaseIndex + 0],
        DeformedPositions[BaseIndex + 1],
        DeformedPositions[BaseIndex + 2]
    );
}

// Read original vertex position from buffer (3 floats per vertex)
// 버퍼에서 원본 버텍스 위치 읽기 (버텍스당 3 float)
float3 ReadOriginalPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        OriginalPositions[BaseIndex + 0],
        OriginalPositions[BaseIndex + 1],
        OriginalPositions[BaseIndex + 2]
    );
}

// Read original normal from tangent buffer (packed SNORM8x4 format)
// 탄젠트 버퍼에서 원본 노멀 읽기 (패킹된 SNORM8x4 포맷)
// Format: TangentX at Index 0, TangentZ (Normal + binormal sign) at Index 1
float3 ReadOriginalNormal(uint VertexIndex)
{
    // TangentZ is at Index 1 (2 float4 per vertex)
    // TangentZ는 Index 1에 있음 (버텍스당 2개의 float4)
    uint BaseIndex = VertexIndex * 2;
    float4 TangentZ = TangentBias_SkinCache(OriginalTangents[BaseIndex + 1]);
    return TangentZ.xyz;  // xyz = normal, w = binormal sign
}

// Write vertex normal to buffer (3 floats per vertex)
// 버퍼에 버텍스 노멀 쓰기 (버텍스당 3 float)
void WriteNormal(uint VertexIndex, float3 Normal)
{
    uint BaseIndex = VertexIndex * 3;
    OutputNormals[BaseIndex + 0] = Normal.x;
    OutputNormals[BaseIndex + 1] = Normal.y;
    OutputNormals[BaseIndex + 2] = Normal.z;
}

// Compute face normal for a triangle (CCW winding = front face in UE)
// 삼각형의 Face Normal 계산 (UE에서 CCW 와인딩 = front face)
// Returns unnormalized normal (length = 2 * triangle area) for area-weighted average
// 면적 가중 평균을 위해 정규화되지 않은 노멀 반환 (길이 = 2 * 삼각형 면적)
//
// IMPORTANT: UE uses LEFT-HANDED coordinate system!
// 중요: UE는 왼손 좌표계를 사용합니다!
// In left-handed system with CCW winding:
// - cross(Edge1, Edge2) points INWARD (wrong direction)
// - cross(Edge2, Edge1) points OUTWARD (correct direction)
// 왼손 좌표계 + CCW 와인딩:
// - cross(Edge1, Edge2) = 내부 방향 (틀림)
// - cross(Edge2, Edge1) = 외부 방향 (맞음)
float3 ComputeFaceNormal(float3 P0, float3 P1, float3 P2)
{
    float3 Edge1 = P1 - P0;
    float3 Edge2 = P2 - P0;
    // Use cross(Edge2, Edge1) for outward normal in UE's left-handed system
    // UE 왼손 좌표계에서 외부 방향 노멀을 위해 cross(Edge2, Edge1) 사용
    return cross(Edge2, Edge1);
}

// Safe normalize with fallback
// 안전한 정규화 (0 벡터 시 기본값 반환)
float3 SafeNormalize(float3 V, float3 Default)
{
    float LenSq = dot(V, V);
    return LenSq > 1e-8f ? V * rsqrt(LenSq) : Default;
}

// Calculate displacement-based blend factor
// 변위 기반 블렌드 계수 계산
// Returns: 0.0 at zero displacement, 1.0 at MaxDisplacement or beyond
// 반환: 변위 0에서 0.0, MaxDisplacement 이상에서 1.0
float CalculateDisplacementBlendFactor(float3 OrigPos, float3 DefPos)
{
    float Displacement = length(DefPos - OrigPos);
    // Linear interpolation from 0 to MaxDisplacement
    // 0에서 MaxDisplacement까지 선형 보간
    return saturate(Displacement / max(MaxDisplacement, 0.01f));
}

// ============================================================================
// Rotation Functions (Rodrigues' Rotation Formula)
// 회전 함수 (로드리게스 회전 공식)
// ============================================================================
// Given two unit vectors (From, To), rotate vector V by the same rotation
// that would align From to To.
// 두 단위 벡터(From, To)가 주어지면, From을 To로 정렬하는 것과 동일한
// 회전을 벡터 V에 적용합니다.

// Rotate vector V such that direction From maps to direction To
// From 방향이 To 방향으로 매핑되도록 벡터 V를 회전
float3 RotateVectorByNormalChange(float3 V, float3 From, float3 To)
{
    // Calculate cosine of angle between normals
    // 두 노멀 사이의 각도 코사인 계산
    float cosAngle = dot(From, To);

    // If nearly parallel (no rotation needed)
    // 거의 평행한 경우 (회전 불필요)
    if (cosAngle > 0.9999f)
    {
        return V;
    }

    // If nearly anti-parallel (180 degree rotation)
    // 거의 반대 방향인 경우 (180도 회전)
    if (cosAngle < -0.9999f)
    {
        // Find a perpendicular axis for 180 degree rotation
        // 180도 회전을 위한 수직 축 찾기
        float3 axis = abs(From.x) < 0.9f ?
            normalize(cross(From, float3(1, 0, 0))) :
            normalize(cross(From, float3(0, 1, 0)));
        // Rotate 180 degrees around axis: V -> -V + 2*(V·axis)*axis
        // 축 주위로 180도 회전: V -> -V + 2*(V·axis)*axis
        return 2.0f * dot(V, axis) * axis - V;
    }

    // Standard case: Rodrigues' rotation formula
    // 일반 경우: 로드리게스 회전 공식
    // R(v) = v*cos(θ) + (k×v)*sin(θ) + k*(k·v)*(1-cos(θ))
    // where k is the normalized rotation axis (From × To normalized)

    float3 crossProduct = cross(From, To);
    float sinAngle = length(crossProduct);

    // If sin is too small, no significant rotation
    // sin이 너무 작으면 유의미한 회전 없음
    if (sinAngle < 1e-6f)
    {
        return V;
    }

    float3 axis = crossProduct / sinAngle;  // Normalized rotation axis

    // Rodrigues' formula
    // 로드리게스 공식
    float3 vRotated = V * cosAngle
                    + cross(axis, V) * sinAngle
                    + axis * dot(axis, V) * (1.0f - cosAngle);

    return vRotated;
}

// ============================================================================
// [DEPRECATED] Polar Decomposition Functions
// Polar 분해 함수 - DEPRECATED
// ============================================================================
// FleshRing의 작은 symmetric 변형에서 SurfaceRotation과 차이 없음 (< 0.5도)
// 코드 복잡도 대비 실질적 이득 없어 deprecated 처리
// MODE_POLAR_DECOMPOSITION 선택 시 SurfaceRotation으로 fallback됨
//
// 아래 함수들은 향후 버전에서 제거 예정
// ----------------------------------------------------------------------------
/*
// Build orthonormal frame from two edge vectors
// 두 edge 벡터로부터 정규직교 프레임 구축
// Returns: columns are Tangent, Bitangent, Normal
// 반환: 열이 Tangent, Bitangent, Normal인 행렬
float3x3 BuildLocalFrame(float3 Edge1, float3 Edge2)
{
    // Normal = cross(Edge2, Edge1) for UE left-handed system
    // UE 왼손 좌표계를 위해 cross(Edge2, Edge1) 사용
    float3 Normal = cross(Edge2, Edge1);
    float NormalLen = length(Normal);

    if (NormalLen < 1e-8f)
    {
        // Degenerate triangle - return identity
        return float3x3(
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        );
    }

    Normal = Normal / NormalLen;

    // Tangent = normalized Edge1
    float3 Tangent = normalize(Edge1);

    // Bitangent = Normal × Tangent (orthogonal to both)
    float3 Bitangent = cross(Normal, Tangent);

    // Return as column vectors (row-major storage)
    // 열 벡터로 반환 (행 우선 저장)
    return float3x3(
        Tangent.x, Bitangent.x, Normal.x,
        Tangent.y, Bitangent.y, Normal.y,
        Tangent.z, Bitangent.z, Normal.z
    );
}

// Compute rotation matrix from original frame to deformed frame
// 원본 프레임에서 변형 프레임으로의 회전 행렬 계산
// This IS the polar decomposition rotation R (since frames are orthonormal)
// 이것이 Polar 분해의 회전 R임 (프레임이 정규직교이므로)
float3x3 ComputeFrameRotation(float3x3 OrigFrame, float3x3 DefFrame)
{
    // R = DefFrame * OrigFrame^T
    // Since frames are orthonormal, transpose = inverse
    // 프레임이 정규직교이므로 전치 = 역행렬
    float3x3 OrigFrameT = transpose(OrigFrame);
    return mul(DefFrame, OrigFrameT);
}

// Apply 3x3 rotation matrix to vector
// 벡터에 3x3 회전 행렬 적용
float3 ApplyRotation(float3x3 R, float3 V)
{
    return mul(R, V);
}
*/

// ============================================================================
// Main Compute Shader
// 메인 컴퓨트 셰이더
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    // Bounds check: Only process affected vertices
    // 범위 체크: 영향받는 버텍스만 처리
    if (ThreadIndex >= NumAffectedVertices)
    {
        return;
    }

    // Get the actual vertex index
    // 실제 버텍스 인덱스 가져오기
    uint VertexIndex = AffectedVertexIndices[ThreadIndex];

    // Safety check: Ensure vertex index is valid
    // 안전 체크: 버텍스 인덱스 유효성 확인
    if (VertexIndex >= NumTotalVertices)
    {
        return;
    }

    // Get adjacent triangle range
    // 인접 삼각형 범위 가져오기
    // 주의: AdjacencyOffsets는 항상 ThreadIndex로 인덱싱 (VertexIndex가 아님!)
    // RepresentativeIndices는 VertexIndex를 반환하므로 adjacency 접근에 사용하면 안됨
    uint AdjStart = AdjacencyOffsets[ThreadIndex];
    uint AdjEnd = AdjacencyOffsets[ThreadIndex + 1];

    // UV seam welding: 대표 버텍스의 원본 노멀을 사용하여 모든 중복 버텍스가 같은 기준점에서 시작
    // (adjacency는 각자의 것을 사용 - deformed positions가 이미 welding되어 있으므로 결과는 동일)
    uint OriginalNormalReadIndex = (bEnableUVSeamWelding != 0) ? RepresentativeIndices[ThreadIndex] : VertexIndex;

    // ========================================
    // Branch by mode for optimal performance
    // 최적 성능을 위해 모드별 분기
    // ========================================

    if (NormalRecomputeMode == MODE_GEOMETRIC)
    {
        // ========================================
        // Geometric Method: Deformed face normal average only
        // 지오메트릭 방식: 변형된 Face Normal 평균만 계산
        // ========================================
        // Original 데이터 읽기/계산 완전 생략 → 메모리 대역폭 절약

        // No adjacent triangles - use default normal
        // 인접 삼각형 없음 - 기본 노멀 사용
        if (AdjStart >= AdjEnd)
        {
            WriteNormal(VertexIndex, float3(0, 0, 1));
            return;
        }

        float3 DeformedFaceNormalSum = float3(0, 0, 0);

        for (uint i = AdjStart; i < AdjEnd; i++)
        {
            uint TriIndex = AdjacencyTriangles[i];

            uint I0 = IndexBuffer[TriIndex * 3 + 0];
            uint I1 = IndexBuffer[TriIndex * 3 + 1];
            uint I2 = IndexBuffer[TriIndex * 3 + 2];

            if (I0 >= NumTotalVertices || I1 >= NumTotalVertices || I2 >= NumTotalVertices)
            {
                continue;
            }

            // Deformed positions only (Original 생략)
            float3 DefP0 = ReadDeformedPosition(I0);
            float3 DefP1 = ReadDeformedPosition(I1);
            float3 DefP2 = ReadDeformedPosition(I2);

            float3 DefFaceNormal = ComputeFaceNormal(DefP0, DefP1, DefP2);

            // Check for degenerate triangle
            if (dot(DefFaceNormal, DefFaceNormal) < 1e-12f)
            {
                continue;
            }

            DeformedFaceNormalSum += DefFaceNormal;
        }

        // Normalize and write
        float3 FinalNormal = SafeNormalize(DeformedFaceNormalSum, float3(0, 0, 1));

        // ========================================
        // Blending: Hop-based + Displacement-based
        // 블렌딩: 홉 기반 + 변위 기반
        // ========================================
        // Both blending methods can be combined:
        // - Hop blending: fade out at boundary (HopDist near MaxHops)
        // - Displacement blending: fade in with vertex movement
        // Combined: FinalBlendFactor = HopBlendFactor * DisplacementBlendFactor
        // 두 블렌딩 방식 병행 가능:
        // - 홉 블렌딩: 경계(HopDist가 MaxHops에 가까울수록)에서 페이드 아웃
        // - 변위 블렌딩: 버텍스 이동량에 따라 페이드 인
        // 결합: FinalBlendFactor = HopBlendFactor * DisplacementBlendFactor

        bool bNeedsBlending = (bEnableHopBlending != 0 && MaxHops > 0) || (bEnableDisplacementBlending != 0);

        if (bNeedsBlending)
        {
            // UV seam welding: 대표 버텍스의 원본 노멀 사용
            float3 OriginalNormal = SafeNormalize(ReadOriginalNormal(OriginalNormalReadIndex), float3(0, 0, 1));
            float BlendFactor = 1.0;  // Default: 100% recomputed normal

            // Hop-based blending
            // 홉 기반 블렌딩
            if (bEnableHopBlending != 0 && MaxHops > 0)
            {
                // HopDistances는 항상 ThreadIndex로 인덱싱
                int HopDist = HopDistances[ThreadIndex];
                // BlendFactor: 1.0 at center (HopDist=0), 0.0 at boundary (HopDist=MaxHops)
                // 블렌드 계수: 중심(HopDist=0)에서 1.0, 경계(HopDist=MaxHops)에서 0.0
                float t = saturate((float)HopDist / (float)MaxHops);
                float HopBlendFactor = 1.0 - ApplyFalloff(t, FalloffType);
                BlendFactor *= HopBlendFactor;
            }

            // Displacement-based blending
            // 변위 기반 블렌딩
            if (bEnableDisplacementBlending != 0)
            {
                // 현재 버텍스의 원본/변형 위치로 변위 계산
                float3 OrigPos = ReadOriginalPosition(VertexIndex);
                float3 DefPos = ReadDeformedPosition(VertexIndex);
                float DisplacementBlendFactor = CalculateDisplacementBlendFactor(OrigPos, DefPos);
                BlendFactor *= DisplacementBlendFactor;
            }

            FinalNormal = normalize(lerp(OriginalNormal, FinalNormal, BlendFactor));
        }

        WriteNormal(VertexIndex, FinalNormal);
    }
    else // MODE_SURFACE_ROTATION 또는 MODE_POLAR_DECOMPOSITION (deprecated, fallback)
    {
        // ========================================
        // Surface Rotation Method: Original + Deformed 모두 필요
        // 표면 회전 방식: 원본과 변형 Face Normal 비교하여 회전량 계산
        // ========================================
        // Note: MODE_POLAR_DECOMPOSITION도 이 분기에서 처리됨 (deprecated fallback)

        // Get original smooth vertex normal (회전시킬 대상)
        // UV seam welding: 대표 버텍스의 원본 노멀 사용
        float3 OriginalVertexNormal = ReadOriginalNormal(OriginalNormalReadIndex);

        // If original normal is invalid, fallback
        float OriginalNormalLenSq = dot(OriginalVertexNormal, OriginalVertexNormal);
        if (OriginalNormalLenSq < 1e-8f)
        {
            WriteNormal(VertexIndex, float3(0, 0, 1));
            return;
        }
        OriginalVertexNormal = normalize(OriginalVertexNormal);

        // No adjacent triangles - use original normal
        if (AdjStart >= AdjEnd)
        {
            WriteNormal(VertexIndex, OriginalVertexNormal);
            return;
        }

        float3 OriginalFaceNormalSum = float3(0, 0, 0);
        float3 DeformedFaceNormalSum = float3(0, 0, 0);
        uint ValidFaceCount = 0;

        for (uint i = AdjStart; i < AdjEnd; i++)
        {
            uint TriIndex = AdjacencyTriangles[i];

            uint I0 = IndexBuffer[TriIndex * 3 + 0];
            uint I1 = IndexBuffer[TriIndex * 3 + 1];
            uint I2 = IndexBuffer[TriIndex * 3 + 2];

            if (I0 >= NumTotalVertices || I1 >= NumTotalVertices || I2 >= NumTotalVertices)
            {
                continue;
            }

            // Original positions (Surface Rotation에서만 필요)
            float3 OrigP0 = ReadOriginalPosition(I0);
            float3 OrigP1 = ReadOriginalPosition(I1);
            float3 OrigP2 = ReadOriginalPosition(I2);

            // Deformed positions
            float3 DefP0 = ReadDeformedPosition(I0);
            float3 DefP1 = ReadDeformedPosition(I1);
            float3 DefP2 = ReadDeformedPosition(I2);

            float3 OrigFaceNormal = ComputeFaceNormal(OrigP0, OrigP1, OrigP2);
            float3 DefFaceNormal = ComputeFaceNormal(DefP0, DefP1, DefP2);

            // Check for degenerate triangles
            float OrigFaceNormalLenSq = dot(OrigFaceNormal, OrigFaceNormal);
            float DefFaceNormalLenSq = dot(DefFaceNormal, DefFaceNormal);
            if (OrigFaceNormalLenSq < 1e-12f || DefFaceNormalLenSq < 1e-12f)
            {
                continue;
            }

            OriginalFaceNormalSum += OrigFaceNormal;
            DeformedFaceNormalSum += DefFaceNormal;
            ValidFaceCount++;
        }

        if (ValidFaceCount == 0)
        {
            WriteNormal(VertexIndex, OriginalVertexNormal);
            return;
        }

        float3 OriginalFaceNormalAvg = SafeNormalize(OriginalFaceNormalSum, float3(0, 0, 1));
        float3 DeformedFaceNormalAvg = SafeNormalize(DeformedFaceNormalSum, float3(0, 0, 1));

        // Apply rotation from original to deformed face normal
        float3 RotatedNormal = RotateVectorByNormalChange(
            OriginalVertexNormal,
            OriginalFaceNormalAvg,
            DeformedFaceNormalAvg
        );

        float3 FinalNormal = SafeNormalize(RotatedNormal, OriginalVertexNormal);

        // ========================================
        // Blending: Hop-based + Displacement-based
        // 블렌딩: 홉 기반 + 변위 기반
        // ========================================
        // Both blending methods can be combined:
        // - Hop blending: fade out at boundary (HopDist near MaxHops)
        // - Displacement blending: fade in with vertex movement
        // Combined: FinalBlendFactor = HopBlendFactor * DisplacementBlendFactor
        // 두 블렌딩 방식 병행 가능:
        // - 홉 블렌딩: 경계(HopDist가 MaxHops에 가까울수록)에서 페이드 아웃
        // - 변위 블렌딩: 버텍스 이동량에 따라 페이드 인
        // 결합: FinalBlendFactor = HopBlendFactor * DisplacementBlendFactor

        bool bNeedsBlending = (bEnableHopBlending != 0 && MaxHops > 0) || (bEnableDisplacementBlending != 0);

        if (bNeedsBlending)
        {
            float BlendFactor = 1.0;  // Default: 100% recomputed normal

            // Hop-based blending
            // 홉 기반 블렌딩
            if (bEnableHopBlending != 0 && MaxHops > 0)
            {
                // HopDistances는 항상 ThreadIndex로 인덱싱
                int HopDist = HopDistances[ThreadIndex];
                // BlendFactor: 1.0 at center (HopDist=0), 0.0 at boundary (HopDist=MaxHops)
                // 블렌드 계수: 중심(HopDist=0)에서 1.0, 경계(HopDist=MaxHops)에서 0.0
                float t = saturate((float)HopDist / (float)MaxHops);
                float HopBlendFactor = 1.0 - ApplyFalloff(t, FalloffType);
                BlendFactor *= HopBlendFactor;
            }

            // Displacement-based blending
            // 변위 기반 블렌딩
            if (bEnableDisplacementBlending != 0)
            {
                // 현재 버텍스의 원본/변형 위치로 변위 계산
                float3 OrigPos = ReadOriginalPosition(VertexIndex);
                float3 DefPos = ReadDeformedPosition(VertexIndex);
                float DisplacementBlendFactor = CalculateDisplacementBlendFactor(OrigPos, DefPos);
                BlendFactor *= DisplacementBlendFactor;
            }

            FinalNormal = normalize(lerp(OriginalVertexNormal, FinalNormal, BlendFactor));
        }

        WriteNormal(VertexIndex, FinalNormal);
    }
    // [DEPRECATED] MODE_POLAR_DECOMPOSITION는 MODE_SURFACE_ROTATION으로 fallback
    // 위의 else 분기(SurfaceRotation)가 Polar 모드도 처리함

    // ========================================================================
    // [DEPRECATED] 아래는 기존 Polar Decomposition 분기 (주석처리됨)
    // FleshRing의 작은 symmetric 변형에서 SurfaceRotation과 차이 없음 (< 0.5도)
    // 향후 버전에서 완전 제거 예정
    // ========================================================================
    /*
    else // MODE_POLAR_DECOMPOSITION
    {
        // ========================================
        // Polar Decomposition Method
        // Polar 분해 방식
        // ========================================
        // Extract pure rotation R from deformation gradient F
        // 변형 그라디언트 F에서 순수 회전 R 추출
        //
        // Algorithm:
        // 1. For each adjacent triangle, build orthonormal frames from edges
        // 2. Compute rotation R that maps original frame to deformed frame
        // 3. Apply R to original smooth vertex normal
        // 4. Accumulate (area-weighted) and normalize
        //
        // 알고리즘:
        // 1. 각 인접 삼각형에 대해 edge로부터 정규직교 프레임 구축
        // 2. 원본 프레임을 변형 프레임으로 매핑하는 회전 R 계산
        // 3. R을 원본 스무스 버텍스 노멀에 적용
        // 4. 면적 가중 누적 후 정규화

        // Get original smooth vertex normal (회전시킬 대상)
        float3 OriginalVertexNormal = ReadOriginalNormal(VertexIndex);

        // If original normal is invalid, fallback
        float OriginalNormalLenSq = dot(OriginalVertexNormal, OriginalVertexNormal);
        if (OriginalNormalLenSq < 1e-8f)
        {
            WriteNormal(VertexIndex, float3(0, 0, 1));
            return;
        }
        OriginalVertexNormal = normalize(OriginalVertexNormal);

        // No adjacent triangles - use original normal
        if (AdjStart >= AdjEnd)
        {
            WriteNormal(VertexIndex, OriginalVertexNormal);
            return;
        }

        // Accumulate rotated normals (weighted by triangle area)
        // 회전된 노멀 누적 (삼각형 면적으로 가중)
        float3 RotatedNormalSum = float3(0, 0, 0);
        float TotalWeight = 0.0f;

        for (uint i = AdjStart; i < AdjEnd; i++)
        {
            uint TriIndex = AdjacencyTriangles[i];

            uint I0 = IndexBuffer[TriIndex * 3 + 0];
            uint I1 = IndexBuffer[TriIndex * 3 + 1];
            uint I2 = IndexBuffer[TriIndex * 3 + 2];

            if (I0 >= NumTotalVertices || I1 >= NumTotalVertices || I2 >= NumTotalVertices)
            {
                continue;
            }

            // Original positions
            float3 OrigP0 = ReadOriginalPosition(I0);
            float3 OrigP1 = ReadOriginalPosition(I1);
            float3 OrigP2 = ReadOriginalPosition(I2);

            // Deformed positions
            float3 DefP0 = ReadDeformedPosition(I0);
            float3 DefP1 = ReadDeformedPosition(I1);
            float3 DefP2 = ReadDeformedPosition(I2);

            // Compute edge vectors
            float3 OrigEdge1 = OrigP1 - OrigP0;
            float3 OrigEdge2 = OrigP2 - OrigP0;
            float3 DefEdge1 = DefP1 - DefP0;
            float3 DefEdge2 = DefP2 - DefP0;

            // Check for degenerate triangles using cross product magnitude
            float3 OrigCross = cross(OrigEdge2, OrigEdge1);
            float3 DefCross = cross(DefEdge2, DefEdge1);
            float OrigArea = length(OrigCross);
            float DefArea = length(DefCross);

            if (OrigArea < 1e-8f || DefArea < 1e-8f)
            {
                continue;
            }

            // Build orthonormal frames from edges
            // Edge 벡터로부터 정규직교 프레임 구축
            float3x3 OrigFrame = BuildLocalFrame(OrigEdge1, OrigEdge2);
            float3x3 DefFrame = BuildLocalFrame(DefEdge1, DefEdge2);

            // Compute rotation: R = DefFrame * OrigFrame^T
            // This extracts pure rotation (polar decomposition R)
            // 회전 계산: R = DefFrame * OrigFrame^T
            // 순수 회전 추출 (polar 분해의 R)
            float3x3 R = ComputeFrameRotation(OrigFrame, DefFrame);

            // Apply rotation to original vertex normal
            // 원본 버텍스 노멀에 회전 적용
            float3 RotatedNormal = ApplyRotation(R, OriginalVertexNormal);

            // Weight by deformed triangle area (prefer larger triangles)
            // 변형된 삼각형 면적으로 가중 (큰 삼각형 선호)
            float Weight = DefArea;
            RotatedNormalSum += RotatedNormal * Weight;
            TotalWeight += Weight;
        }

        if (TotalWeight < 1e-8f)
        {
            WriteNormal(VertexIndex, OriginalVertexNormal);
            return;
        }

        // Normalize the accumulated result
        // 누적 결과 정규화
        float3 FinalNormal = SafeNormalize(RotatedNormalSum, OriginalVertexNormal);
        WriteNormal(VertexIndex, FinalNormal);
    }
    */
}
