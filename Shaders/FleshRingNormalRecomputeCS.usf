// Copyright 2026 LgThx. All Rights Reserved.

// ============================================================================
// FleshRing Normal Recompute Compute Shader
// ============================================================================
// Purpose: Recompute vertex normals using various methods
//
// Supported Methods:
// - Geometric (0): Face Normal average - TBN accurate
// - SurfaceRotation (1): Rotate original normal by face normal change
//
// This shader runs AFTER TightnessCS and BulgeCS, using the final deformed positions
// to calculate accurate normals for affected vertices only.
// ============================================================================

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/GpuSkinCommon.ush"

// ============================================================================
// Mode Constants
// ============================================================================
#define MODE_GEOMETRIC          0
#define MODE_SURFACE_ROTATION   1

// ============================================================================
// Buffer Declarations
// ============================================================================

// Input: Deformed vertex positions (from TightnessCS/BulgeCS)
Buffer<float> DeformedPositions;

// Input: Original vertex positions (bind pose) - for calculating original face normals
Buffer<float> OriginalPositions;

// Input: Affected vertex indices to process
StructuredBuffer<uint> AffectedVertexIndices;

// Input: Adjacency offsets - AdjacencyOffsets[i] = start index in AdjacencyTriangles for vertex i
// AdjacencyOffsets[i] to AdjacencyOffsets[i+1] = range of adjacent triangles for vertex i
StructuredBuffer<uint> AdjacencyOffsets;

// Input: Flattened list of adjacent triangle indices
StructuredBuffer<uint> AdjacencyTriangles;

// Input: Mesh index buffer (3 indices per triangle)
Buffer<uint> IndexBuffer;

// Input: Original tangent buffer (contains normals) - packed SNORM8x4 format
// Format: TangentX (Index 0), TangentZ=Normal+BinormalSign (Index 1) per vertex
Buffer<float4> OriginalTangents;

// Output: Recomputed normals (float3 per vertex)
RWBuffer<float> OutputNormals;

// Input: Hop distances for each affected vertex (optional, for blending)
StructuredBuffer<int> HopDistances;

// Input: Representative vertex indices for UV seam welding (optional)
// Maps each affected vertex to its representative (same position, different UV)
StructuredBuffer<uint> RepresentativeIndices;

// ============================================================================
// Parameters
// ============================================================================

uint NumAffectedVertices;   // Number of affected vertices to process
uint NumTotalVertices;      // Total mesh vertex count (for bounds check)
uint NormalRecomputeMode;   // 0 = Geometric, 1 = SurfaceRotation
uint bEnableHopBlending;    // 0 = off, 1 = on (blend with original at boundary)
uint MaxHops;               // Maximum hop distance (for blend factor calculation)
uint FalloffType;           // 0 = Linear, 1 = Quadratic, 2 = Hermite
uint bEnableUVSeamWelding;  // 0 = off, 1 = on (use RepresentativeIndices for UV seam)
uint bEnableDisplacementBlending;  // 0 = off, 1 = on (blend based on vertex displacement)
float MaxDisplacement;      // Maximum displacement for blend (cm) - 100% recomputed normal beyond this distance

// Thread Group Size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Helper Functions
// ============================================================================

// Apply falloff curve to normalized distance t [0, 1]
// FalloffType: 0 = Linear, 1 = Quadratic, 2 = Hermite (smoothstep)
float ApplyFalloff(float t, uint InFalloffType)
{
    // t: 0 at center (HopDist=0), 1 at boundary (HopDist=MaxHops)
    t = saturate(t);

    if (InFalloffType == 0)  // Linear
    {
        return t;
    }
    else if (InFalloffType == 1)  // Quadratic
    {
        return t * t;
    }
    else  // Hermite (smoothstep) - default
    {
        // smoothstep: 3t^2 - 2t^3
        return t * t * (3.0 - 2.0 * t);
    }
}

// Read deformed vertex position from buffer (3 floats per vertex)
float3 ReadDeformedPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        DeformedPositions[BaseIndex + 0],
        DeformedPositions[BaseIndex + 1],
        DeformedPositions[BaseIndex + 2]
    );
}

// Read original vertex position from buffer (3 floats per vertex)
float3 ReadOriginalPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        OriginalPositions[BaseIndex + 0],
        OriginalPositions[BaseIndex + 1],
        OriginalPositions[BaseIndex + 2]
    );
}

// Read original normal from tangent buffer (packed SNORM8x4 format)
// Format: TangentX at Index 0, TangentZ (Normal + binormal sign) at Index 1
float3 ReadOriginalNormal(uint VertexIndex)
{
    // TangentZ is at Index 1 (2 float4 per vertex)
    uint BaseIndex = VertexIndex * 2;
    float4 TangentZ = TangentBias_SkinCache(OriginalTangents[BaseIndex + 1]);
    return TangentZ.xyz;  // xyz = normal, w = binormal sign
}

// Write vertex normal to buffer (3 floats per vertex)
void WriteNormal(uint VertexIndex, float3 Normal)
{
    uint BaseIndex = VertexIndex * 3;
    OutputNormals[BaseIndex + 0] = Normal.x;
    OutputNormals[BaseIndex + 1] = Normal.y;
    OutputNormals[BaseIndex + 2] = Normal.z;
}

// Compute face normal for a triangle (CCW winding = front face in UE)
// Returns unnormalized normal (length = 2 * triangle area) for area-weighted average
//
// IMPORTANT: UE uses LEFT-HANDED coordinate system!
// In left-handed system with CCW winding:
// - cross(Edge1, Edge2) points INWARD (wrong direction)
// - cross(Edge2, Edge1) points OUTWARD (correct direction)
float3 ComputeFaceNormal(float3 P0, float3 P1, float3 P2)
{
    float3 Edge1 = P1 - P0;
    float3 Edge2 = P2 - P0;
    // Use cross(Edge2, Edge1) for outward normal in UE's left-handed system
    return cross(Edge2, Edge1);
}

// Safe normalize with fallback
float3 SafeNormalize(float3 V, float3 Default)
{
    float LenSq = dot(V, V);
    return LenSq > 1e-8f ? V * rsqrt(LenSq) : Default;
}

// Calculate displacement-based blend factor
// Returns: 0.0 at zero displacement, 1.0 at MaxDisplacement or beyond
float CalculateDisplacementBlendFactor(float3 OrigPos, float3 DefPos)
{
    float Displacement = length(DefPos - OrigPos);
    // Linear interpolation from 0 to MaxDisplacement
    return saturate(Displacement / max(MaxDisplacement, 0.01f));
}

// ============================================================================
// Rotation Functions (Rodrigues' Rotation Formula)
// ============================================================================
// Given two unit vectors (From, To), rotate vector V by the same rotation
// that would align From to To.

// Rotate vector V such that direction From maps to direction To
float3 RotateVectorByNormalChange(float3 V, float3 From, float3 To)
{
    // Calculate cosine of angle between normals
    float cosAngle = dot(From, To);

    // If nearly parallel (no rotation needed)
    if (cosAngle > 0.9999f)
    {
        return V;
    }

    // If nearly anti-parallel (180 degree rotation)
    if (cosAngle < -0.9999f)
    {
        // Find a perpendicular axis for 180 degree rotation
        float3 axis = abs(From.x) < 0.9f ?
            normalize(cross(From, float3(1, 0, 0))) :
            normalize(cross(From, float3(0, 1, 0)));
        // Rotate 180 degrees around axis: V -> -V + 2*(V.axis)*axis
        return 2.0f * dot(V, axis) * axis - V;
    }

    // Standard case: Rodrigues' rotation formula
    // R(v) = v*cos(theta) + (k x v)*sin(theta) + k*(k.v)*(1-cos(theta))
    // where k is the normalized rotation axis (From x To normalized)

    float3 crossProduct = cross(From, To);
    float sinAngle = length(crossProduct);

    // If sin is too small, no significant rotation
    if (sinAngle < 1e-6f)
    {
        return V;
    }

    float3 axis = crossProduct / sinAngle;  // Normalized rotation axis

    // Rodrigues' formula
    float3 vRotated = V * cosAngle
                    + cross(axis, V) * sinAngle
                    + axis * dot(axis, V) * (1.0f - cosAngle);

    return vRotated;
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    // Bounds check: Only process affected vertices
    if (ThreadIndex >= NumAffectedVertices)
    {
        return;
    }

    // Get the actual vertex index
    uint VertexIndex = AffectedVertexIndices[ThreadIndex];

    // Safety check: Ensure vertex index is valid
    if (VertexIndex >= NumTotalVertices)
    {
        return;
    }

    // Get adjacent triangle range
    // NOTE: AdjacencyOffsets is always indexed by ThreadIndex (not VertexIndex!)
    // RepresentativeIndices returns VertexIndex so it should not be used for adjacency access
    uint AdjStart = AdjacencyOffsets[ThreadIndex];
    uint AdjEnd = AdjacencyOffsets[ThreadIndex + 1];

    // UV seam welding: Use representative vertex's original normal so all duplicate vertices start from the same reference
    // (adjacency uses each vertex's own data - deformed positions are already welded so results are identical)
    uint OriginalNormalReadIndex = (bEnableUVSeamWelding != 0) ? RepresentativeIndices[ThreadIndex] : VertexIndex;

    // ========================================
    // Branch by mode for optimal performance
    // ========================================

    if (NormalRecomputeMode == MODE_GEOMETRIC)
    {
        // ========================================
        // Geometric Method: Deformed face normal average only
        // ========================================
        // Skip reading/computing original data -> saves memory bandwidth

        // ========================================
        // Zero-displacement early-out: Return original normal if no deformation
        // Using face normal average when undeformed would differ from original smooth normal
        // ========================================
        {
            float3 OrigPos = ReadOriginalPosition(VertexIndex);
            float3 DefPos = ReadDeformedPosition(VertexIndex);
            float DisplacementSq = dot(DefPos - OrigPos, DefPos - OrigPos);
            if (DisplacementSq < 1e-10f)
            {
                // No deformation - return original smooth normal as-is
                float3 OriginalNormal = SafeNormalize(ReadOriginalNormal(OriginalNormalReadIndex), float3(0, 0, 1));
                WriteNormal(VertexIndex, OriginalNormal);
                return;
            }
        }

        // No adjacent triangles - use default normal
        if (AdjStart >= AdjEnd)
        {
            WriteNormal(VertexIndex, float3(0, 0, 1));
            return;
        }

        float3 DeformedFaceNormalSum = float3(0, 0, 0);

        for (uint i = AdjStart; i < AdjEnd; i++)
        {
            uint TriIndex = AdjacencyTriangles[i];

            uint I0 = IndexBuffer[TriIndex * 3 + 0];
            uint I1 = IndexBuffer[TriIndex * 3 + 1];
            uint I2 = IndexBuffer[TriIndex * 3 + 2];

            if (I0 >= NumTotalVertices || I1 >= NumTotalVertices || I2 >= NumTotalVertices)
            {
                continue;
            }

            // Deformed positions only (skip original)
            float3 DefP0 = ReadDeformedPosition(I0);
            float3 DefP1 = ReadDeformedPosition(I1);
            float3 DefP2 = ReadDeformedPosition(I2);

            float3 DefFaceNormal = ComputeFaceNormal(DefP0, DefP1, DefP2);

            // Check for degenerate triangle
            if (dot(DefFaceNormal, DefFaceNormal) < 1e-12f)
            {
                continue;
            }

            DeformedFaceNormalSum += DefFaceNormal;
        }

        // Normalize and write
        float3 FinalNormal = SafeNormalize(DeformedFaceNormalSum, float3(0, 0, 1));

        // ========================================
        // Blending: Hop-based + Displacement-based
        // ========================================
        // Both blending methods can be combined:
        // - Hop blending: fade out at boundary (HopDist near MaxHops)
        // - Displacement blending: fade in with vertex movement
        // Combined: FinalBlendFactor = HopBlendFactor * DisplacementBlendFactor

        bool bNeedsBlending = (bEnableHopBlending != 0 && MaxHops > 0) || (bEnableDisplacementBlending != 0);

        if (bNeedsBlending)
        {
            // UV seam welding: Use representative vertex's original normal
            float3 OriginalNormal = SafeNormalize(ReadOriginalNormal(OriginalNormalReadIndex), float3(0, 0, 1));
            float BlendFactor = 1.0;  // Default: 100% recomputed normal

            // Hop-based blending
            if (bEnableHopBlending != 0 && MaxHops > 0)
            {
                // HopDistances is always indexed by ThreadIndex
                int HopDist = HopDistances[ThreadIndex];
                // BlendFactor: 1.0 at center (HopDist=0), 0.0 at boundary (HopDist=MaxHops)
                float t = saturate((float)HopDist / (float)MaxHops);
                float HopBlendFactor = 1.0 - ApplyFalloff(t, FalloffType);
                BlendFactor *= HopBlendFactor;
            }

            // Displacement-based blending
            if (bEnableDisplacementBlending != 0)
            {
                // Calculate displacement using current vertex's original/deformed positions
                float3 OrigPos = ReadOriginalPosition(VertexIndex);
                float3 DefPos = ReadDeformedPosition(VertexIndex);
                float DisplacementBlendFactor = CalculateDisplacementBlendFactor(OrigPos, DefPos);
                BlendFactor *= DisplacementBlendFactor;
            }

            FinalNormal = normalize(lerp(OriginalNormal, FinalNormal, BlendFactor));
        }

        WriteNormal(VertexIndex, FinalNormal);
    }
    else // MODE_SURFACE_ROTATION
    {
        // ========================================
        // Surface Rotation Method: Needs both Original + Deformed
        // ========================================
        // Compare original and deformed face normals to calculate rotation amount

        // Get original smooth vertex normal (the vector to rotate)
        // UV seam welding: Use representative vertex's original normal
        float3 OriginalVertexNormal = ReadOriginalNormal(OriginalNormalReadIndex);

        // If original normal is invalid, fallback
        float OriginalNormalLenSq = dot(OriginalVertexNormal, OriginalVertexNormal);
        if (OriginalNormalLenSq < 1e-8f)
        {
            WriteNormal(VertexIndex, float3(0, 0, 1));
            return;
        }
        OriginalVertexNormal = normalize(OriginalVertexNormal);

        // ========================================
        // Zero-displacement early-out: Return original normal if no deformation
        // Prevents tiny rotations due to numerical errors
        // ========================================
        {
            float3 OrigPos = ReadOriginalPosition(VertexIndex);
            float3 DefPos = ReadDeformedPosition(VertexIndex);
            float DisplacementSq = dot(DefPos - OrigPos, DefPos - OrigPos);
            if (DisplacementSq < 1e-10f)
            {
                // No deformation - return original smooth normal as-is
                WriteNormal(VertexIndex, OriginalVertexNormal);
                return;
            }
        }

        // No adjacent triangles - use original normal
        if (AdjStart >= AdjEnd)
        {
            WriteNormal(VertexIndex, OriginalVertexNormal);
            return;
        }

        float3 OriginalFaceNormalSum = float3(0, 0, 0);
        float3 DeformedFaceNormalSum = float3(0, 0, 0);
        uint ValidFaceCount = 0;

        for (uint i = AdjStart; i < AdjEnd; i++)
        {
            uint TriIndex = AdjacencyTriangles[i];

            uint I0 = IndexBuffer[TriIndex * 3 + 0];
            uint I1 = IndexBuffer[TriIndex * 3 + 1];
            uint I2 = IndexBuffer[TriIndex * 3 + 2];

            if (I0 >= NumTotalVertices || I1 >= NumTotalVertices || I2 >= NumTotalVertices)
            {
                continue;
            }

            // Original positions (only needed for Surface Rotation)
            float3 OrigP0 = ReadOriginalPosition(I0);
            float3 OrigP1 = ReadOriginalPosition(I1);
            float3 OrigP2 = ReadOriginalPosition(I2);

            // Deformed positions
            float3 DefP0 = ReadDeformedPosition(I0);
            float3 DefP1 = ReadDeformedPosition(I1);
            float3 DefP2 = ReadDeformedPosition(I2);

            float3 OrigFaceNormal = ComputeFaceNormal(OrigP0, OrigP1, OrigP2);
            float3 DefFaceNormal = ComputeFaceNormal(DefP0, DefP1, DefP2);

            // Check for degenerate triangles
            float OrigFaceNormalLenSq = dot(OrigFaceNormal, OrigFaceNormal);
            float DefFaceNormalLenSq = dot(DefFaceNormal, DefFaceNormal);
            if (OrigFaceNormalLenSq < 1e-12f || DefFaceNormalLenSq < 1e-12f)
            {
                continue;
            }

            OriginalFaceNormalSum += OrigFaceNormal;
            DeformedFaceNormalSum += DefFaceNormal;
            ValidFaceCount++;
        }

        if (ValidFaceCount == 0)
        {
            WriteNormal(VertexIndex, OriginalVertexNormal);
            return;
        }

        float3 OriginalFaceNormalAvg = SafeNormalize(OriginalFaceNormalSum, float3(0, 0, 1));
        float3 DeformedFaceNormalAvg = SafeNormalize(DeformedFaceNormalSum, float3(0, 0, 1));

        // Apply rotation from original to deformed face normal
        float3 RotatedNormal = RotateVectorByNormalChange(
            OriginalVertexNormal,
            OriginalFaceNormalAvg,
            DeformedFaceNormalAvg
        );

        float3 FinalNormal = SafeNormalize(RotatedNormal, OriginalVertexNormal);

        // ========================================
        // Blending: Hop-based + Displacement-based
        // ========================================
        // Both blending methods can be combined:
        // - Hop blending: fade out at boundary (HopDist near MaxHops)
        // - Displacement blending: fade in with vertex movement
        // Combined: FinalBlendFactor = HopBlendFactor * DisplacementBlendFactor

        bool bNeedsBlending = (bEnableHopBlending != 0 && MaxHops > 0) || (bEnableDisplacementBlending != 0);

        if (bNeedsBlending)
        {
            float BlendFactor = 1.0;  // Default: 100% recomputed normal

            // Hop-based blending
            if (bEnableHopBlending != 0 && MaxHops > 0)
            {
                // HopDistances is always indexed by ThreadIndex
                int HopDist = HopDistances[ThreadIndex];
                // BlendFactor: 1.0 at center (HopDist=0), 0.0 at boundary (HopDist=MaxHops)
                float t = saturate((float)HopDist / (float)MaxHops);
                float HopBlendFactor = 1.0 - ApplyFalloff(t, FalloffType);
                BlendFactor *= HopBlendFactor;
            }

            // Displacement-based blending
            if (bEnableDisplacementBlending != 0)
            {
                // Calculate displacement using current vertex's original/deformed positions
                float3 OrigPos = ReadOriginalPosition(VertexIndex);
                float3 DefPos = ReadDeformedPosition(VertexIndex);
                float DisplacementBlendFactor = CalculateDisplacementBlendFactor(OrigPos, DefPos);
                BlendFactor *= DisplacementBlendFactor;
            }

            FinalNormal = normalize(lerp(OriginalVertexNormal, FinalNormal, BlendFactor));
        }

        WriteNormal(VertexIndex, FinalNormal);
    }
}
