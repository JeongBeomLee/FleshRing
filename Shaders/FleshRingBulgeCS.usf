// Copyright Epic Games, Inc. All Rights Reserved.
// FleshRingBulgeCS.usf - Bulge Pass Compute Shader
// Wendland C2 Kernel 기반 부피 보존 변형 (CPU에서 Falloff 계산)

#include "/Engine/Public/Platform.ush"

// Buffers
Buffer<float> InputPositions;
StructuredBuffer<uint> BulgeVertexIndices;
StructuredBuffer<float> BulgeInfluences;
Buffer<uint> VolumeAccumBuffer;
RWBuffer<float> OutputPositions;

// SDF Parameters
Texture3D<float> SDFTexture;
SamplerState SDFSampler;
float3 SDFBoundsMin;
float3 SDFBoundsMax;
float4x4 ComponentToSDFLocal;

// Bulge Parameters
uint NumBulgeVertices;
uint NumTotalVertices;
float BulgeStrength;
float MaxBulgeDistance;
float FixedPointScale;
int BulgeAxisDirection;  // -1: 음의 축, +1: 양의 축, 0: 양방향
uint RingIndex;          // Ring 인덱스 (VolumeAccumBuffer 슬롯 지정용)

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

static const float SQRT2 = 1.41421356237;

// Position read/write
float3 ReadPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        InputPositions[BaseIndex + 0],
        InputPositions[BaseIndex + 1],
        InputPositions[BaseIndex + 2]
    );
}

void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

float3 TransformToSDFLocal(float3 ComponentPos)
{
    return mul(float4(ComponentPos, 1.0), ComponentToSDFLocal).xyz;
}

float3 TransformDirectionToComponent(float3 LocalDir)
{
    return mul(LocalDir, (float3x3)transpose(ComponentToSDFLocal));
}

// Ring 축: 가장 짧은 SDF 바운드 축
float3 DetectRingAxis()
{
    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;

    if (BoundsSize.x <= BoundsSize.y && BoundsSize.x <= BoundsSize.z)
        return float3(1, 0, 0);
    else if (BoundsSize.y <= BoundsSize.x && BoundsSize.y <= BoundsSize.z)
        return float3(0, 1, 0);
    else
        return float3(0, 0, 1);
}

struct FRingGeometry
{
    float3 Center;
    float3 Axis;
    float EffectWidth;
};

FRingGeometry ComputeRingGeometry()
{
    FRingGeometry Ring;
    Ring.Center = (SDFBoundsMin + SDFBoundsMax) * 0.5;
    Ring.Axis = DetectRingAxis();

    // EffectWidth: CPU의 BoundsExpansionRatio와 맞춤
    // t = axialDist / EffectWidth > 1 이어야 Bulge 영역
    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;
    float minSize = min(BoundsSize.x, min(BoundsSize.y, BoundsSize.z));
    Ring.EffectWidth = minSize * 0.4;

    return Ring;
}


// 순수 방사 방향 (Ring 축에 수직, 바깥으로)
float3 ComputePureRadialDirection(float3 LocalPos, FRingGeometry Ring)
{
    float3 ToVertex = LocalPos - Ring.Center;
    float axialComponent = dot(ToVertex, Ring.Axis);
    float3 RadialVec = ToVertex - Ring.Axis * axialComponent;

    float radialLen = length(RadialVec);
    if (radialLen < 0.0001)
    {
        float3 arbitrary = abs(Ring.Axis.x) < 0.9 ? float3(1, 0, 0) : float3(0, 1, 0);
        return normalize(cross(Ring.Axis, arbitrary));
    }

    return RadialVec / radialLen;
}

// SDF Gradient 계산 (표면 법선 방향)
float3 ComputeSDFGradient(float3 LocalPos)
{
    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;
    float epsilon = max(BoundsSize.x, max(BoundsSize.y, BoundsSize.z)) / 64.0;

    float3 grad;
    float3 uvX1 = saturate((LocalPos + float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize);
    float3 uvX2 = saturate((LocalPos - float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize);
    grad.x = SDFTexture.SampleLevel(SDFSampler, uvX1, 0).r - SDFTexture.SampleLevel(SDFSampler, uvX2, 0).r;

    float3 uvY1 = saturate((LocalPos + float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize);
    float3 uvY2 = saturate((LocalPos - float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize);
    grad.y = SDFTexture.SampleLevel(SDFSampler, uvY1, 0).r - SDFTexture.SampleLevel(SDFSampler, uvY2, 0).r;

    float3 uvZ1 = saturate((LocalPos + float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize);
    float3 uvZ2 = saturate((LocalPos - float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize);
    grad.z = SDFTexture.SampleLevel(SDFSampler, uvZ1, 0).r - SDFTexture.SampleLevel(SDFSampler, uvZ2, 0).r;

    float len = length(grad);
    return (len > 0.0001) ? (grad / len) : float3(0, 0, 1);
}

// 살이 링을 덮는 방향 계산 (Radial 70% + Axial 30%)
// 리서치: 링 윗부분은 위로, 아랫부분은 아래로 밀려나는 느낌
float3 ComputeFleshCoveringDirection(float3 LocalPos, FRingGeometry Ring)
{
    float3 ToVertex = LocalPos - Ring.Center;
    float axialComponent = dot(ToVertex, Ring.Axis);

    // 방사 방향 (바깥으로)
    float3 RadialDir = ComputePureRadialDirection(LocalPos, Ring);

    // 축 방향 (위/아래): 버텍스가 링 위면 위로, 아래면 아래로
    float3 AxialDir = Ring.Axis * sign(axialComponent);

    // 70% Radial + 30% Axial
    float3 CombinedDir = RadialDir * 0.7 + AxialDir * 0.3;

    float len = length(CombinedDir);
    return (len > 0.0001) ? (CombinedDir / len) : RadialDir;
}

// Debug
#define DEBUG_FORCE_BULGE 0
#define DEBUG_IGNORE_VOLUME 0
#define DEBUG_FIXED_STRENGTH 2.0

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    if (ThreadIndex >= NumBulgeVertices)
        return;

    uint VertexIndex = BulgeVertexIndices[ThreadIndex];

    if (VertexIndex >= NumTotalVertices)
        return;

    float3 Pos = ReadPosition(VertexIndex);

#if DEBUG_FORCE_BULGE
    {
        float3 LocalPos = TransformToSDFLocal(Pos);
        FRingGeometry Ring = ComputeRingGeometry();
        float3 BulgeDir = ComputeFleshCoveringDirection(LocalPos, Ring);
        float3 BulgeDirComponent = normalize(TransformDirectionToComponent(BulgeDir));
        WritePosition(VertexIndex, Pos + BulgeDirComponent * 5.0);
        return;
    }
#endif

    float CPUInfluence = BulgeInfluences[ThreadIndex];
    if (CPUInfluence < 0.001)
    {
        WritePosition(VertexIndex, Pos);
        return;
    }

    // Volume Loss (TightnessCS에서 Ring별 Atomic 누적)
    uint VolumeAccumFixed = VolumeAccumBuffer[RingIndex];
    float VolumeLoss = float(VolumeAccumFixed) * FixedPointScale;

    if (VolumeLoss < 0.001)
    {
        WritePosition(VertexIndex, Pos);
        return;
    }

    float3 LocalPos = TransformToSDFLocal(Pos);
    FRingGeometry Ring = ComputeRingGeometry();

    // 축 방향 거리 계산
    float3 ToVertex = LocalPos - Ring.Center;
    float axialComponent = dot(ToVertex, Ring.Axis);

    // 방향 필터링 (BulgeAxisDirection != 0이면 한쪽만 처리)
    if (BulgeAxisDirection != 0)
    {
        int vertexSide = (axialComponent > 0.0) ? 1 : -1;
        if (vertexSide != BulgeAxisDirection)
        {
            WritePosition(VertexIndex, Pos);
            return;
        }
    }


    // CPUInfluence에 BulgeMask가 이미 포함되어 있음
    // GPU는 방사 방향 계산 + Bulge 적용만 수행
    // NOTE: Falloff 계산은 CPU에서 수행 (FFleshRingFalloff::Evaluate)
    // GPU는 미리 계산된 BulgeInfluences 버퍼를 읽기만 함
    // 이점: 버텍스당 1회 계산 + 캐싱, GPU 분기 제거, 런타임 타입 변경 가능

    // Bulge 방향: Radial 70% + Axial 30% (살이 링을 덮는 방향)
    float3 BulgeDirLocal = ComputeFleshCoveringDirection(LocalPos, Ring);
    float3 BulgeDirComponent = TransformDirectionToComponent(BulgeDirLocal);

    float dirLen = length(BulgeDirComponent);
    if (dirLen < 0.0001 || isnan(dirLen) || isinf(dirLen))
    {
        WritePosition(VertexIndex, Pos);
        return;
    }
    BulgeDirComponent = BulgeDirComponent / dirLen;

    // Bulge 계산
    // CPUInfluence = BulgeMask × DistInfluence (CPU에서 사전 계산됨)
#if DEBUG_IGNORE_VOLUME
    float BulgeAmount = DEBUG_FIXED_STRENGTH * CPUInfluence;
#else
    float VolumeFactor = VolumeLoss / max(float(NumBulgeVertices), 1.0);
    float BulgeAmount = VolumeFactor * CPUInfluence * BulgeStrength;
#endif

    BulgeAmount = clamp(BulgeAmount, 0.0, MaxBulgeDistance);

    // 위치 업데이트
    float3 PosDelta = BulgeDirComponent * BulgeAmount;

    if (any(isnan(PosDelta)) || any(isinf(PosDelta)))
    {
        WritePosition(VertexIndex, Pos);
        return;
    }

    float deltaLen = length(PosDelta);
    if (deltaLen > MaxBulgeDistance)
    {
        PosDelta = PosDelta * (MaxBulgeDistance / deltaLen);
    }

    WritePosition(VertexIndex, Pos + PosDelta);
}
