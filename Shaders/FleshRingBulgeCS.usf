// Copyright 2026 LgThx. All Rights Reserved.

// FleshRingBulgeCS.usf - Bulge Pass Compute Shader
// Wendland C2 Kernel based volume-preserving deformation (falloff calculated on CPU)

#include "/Engine/Public/Platform.ush"

// Buffers
Buffer<float> InputPositions;
StructuredBuffer<uint> BulgeVertexIndices;
StructuredBuffer<float> BulgeInfluences;
Buffer<uint> VolumeAccumBuffer;
RWBuffer<float> OutputPositions;

// SDF Parameters
Texture3D<float> SDFTexture;
SamplerState SDFSampler;
float3 SDFBoundsMin;
float3 SDFBoundsMax;
float4x4 ComponentToSDFLocal;

// Bulge Parameters
uint NumBulgeVertices;
uint NumTotalVertices;
float BulgeStrength;
float MaxBulgeDistance;
float FixedPointScale;
int BulgeAxisDirection;  // -1: negative axis, +1: positive axis, 0: both directions
uint RingIndex;          // Ring index (for VolumeAccumBuffer slot)
float BulgeRadialRatio;  // Radial vs Axial direction ratio (0.0~1.0, default 0.7)
float UpperBulgeStrength;  // Upper (axis positive) Bulge strength multiplier
float LowerBulgeStrength;  // Lower (axis negative) Bulge strength multiplier
uint bUseSDFInfluence;   // 0 = VirtualRing (Component Space direct), 1 = SDF mode

// Ring Center/Axis (SDF Local Space) - for SDF mode
float3 SDFLocalRingCenter;
float3 SDFLocalRingAxis;

// Ring Center/Axis (Component Space) - for VirtualRing mode
float3 RingCenter;
float3 RingAxis;
float RingHeight;

// Debug Point Output is handled in DebugPointOutputCS based on final positions

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// Position read/write
float3 ReadPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        InputPositions[BaseIndex + 0],
        InputPositions[BaseIndex + 1],
        InputPositions[BaseIndex + 2]
    );
}

void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

float3 TransformToSDFLocal(float3 ComponentPos)
{
    return mul(float4(ComponentPos, 1.0), ComponentToSDFLocal).xyz;
}

float3 TransformDirectionToComponent(float3 LocalDir)
{
    return mul(LocalDir, (float3x3)transpose(ComponentToSDFLocal));
}

struct FRingGeometry
{
    float3 Center;
    float3 Axis;
    float EffectWidth;
};

FRingGeometry ComputeRingGeometry()
{
    FRingGeometry Ring;

    // Use Ring Center/Axis passed from CPU (accurate position before bounds expansion)
    Ring.Center = SDFLocalRingCenter;
    Ring.Axis = SDFLocalRingAxis;

    // EffectWidth: Matches CPUBoundsExpansionRatio
    // t = axialDist / EffectWidth > 1 means outside Bulge region
    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;
    float minSize = min(BoundsSize.x, min(BoundsSize.y, BoundsSize.z));
    Ring.EffectWidth = minSize * 0.4;

    return Ring;
}

// Pure radial direction (perpendicular to Ring axis, outward)
float3 ComputePureRadialDirection(float3 LocalPos, FRingGeometry Ring)
{
    float3 ToVertex = LocalPos - Ring.Center;
    float axialComponent = dot(ToVertex, Ring.Axis);
    float3 RadialVec = ToVertex - Ring.Axis * axialComponent;

    float radialLen = length(RadialVec);
    if (radialLen < 0.0001)
    {
        float3 arbitrary = abs(Ring.Axis.x) < 0.9 ? float3(1, 0, 0) : float3(0, 1, 0);
        return normalize(cross(Ring.Axis, arbitrary));
    }

    return RadialVec / radialLen;
}

// SDF Gradient calculation (surface normal direction)
// TODO: Currently unused (replaced by ComputeFleshCoveringDirection). Remove after retest if unnecessary.
float3 ComputeSDFGradient(float3 LocalPos)
{
    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;
    float epsilon = max(BoundsSize.x, max(BoundsSize.y, BoundsSize.z)) / 64.0;

    float3 grad;
    float3 uvX1 = saturate((LocalPos + float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize);
    float3 uvX2 = saturate((LocalPos - float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize);
    grad.x = SDFTexture.SampleLevel(SDFSampler, uvX1, 0).r - SDFTexture.SampleLevel(SDFSampler, uvX2, 0).r;

    float3 uvY1 = saturate((LocalPos + float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize);
    float3 uvY2 = saturate((LocalPos - float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize);
    grad.y = SDFTexture.SampleLevel(SDFSampler, uvY1, 0).r - SDFTexture.SampleLevel(SDFSampler, uvY2, 0).r;

    float3 uvZ1 = saturate((LocalPos + float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize);
    float3 uvZ2 = saturate((LocalPos - float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize);
    grad.z = SDFTexture.SampleLevel(SDFSampler, uvZ1, 0).r - SDFTexture.SampleLevel(SDFSampler, uvZ2, 0).r;

    float len = length(grad);
    return (len > 0.0001) ? (grad / len) : float3(0, 0, 1);
}

// Flesh covering direction calculation (Radial + Axial, ratio controlled by BulgeRadialRatio)
// Upper part pushes upward, lower part pushes downward
// SDF mode (SDF Local Space)
float3 ComputeFleshCoveringDirection(float3 LocalPos, FRingGeometry Ring)
{
    float3 ToVertex = LocalPos - Ring.Center;
    float axialComponent = dot(ToVertex, Ring.Axis);

    // Radial direction (outward)
    float3 RadialDir = ComputePureRadialDirection(LocalPos, Ring);

    // Axial direction (up/down): vertex above pushes up, below pushes down
    float3 AxialDir = Ring.Axis * sign(axialComponent);

    // BulgeRadialRatio for Radial, remaining (1-ratio) for Axial
    float3 CombinedDir = RadialDir * BulgeRadialRatio + AxialDir * (1.0 - BulgeRadialRatio);

    float len = length(CombinedDir);
    return (len > 0.0001) ? (CombinedDir / len) : RadialDir;
}

// VirtualRing mode direction calculation (Component Space direct, no SDF transform)
float3 ComputeFleshCoveringDirection_VirtualRing(float3 ComponentPos)
{
    float3 ToVertex = ComponentPos - RingCenter;
    float axialComponent = dot(ToVertex, RingAxis);

    // Radial direction (outward)
    float3 RadialVec = ToVertex - RingAxis * axialComponent;
    float radialLen = length(RadialVec);
    float3 RadialDir;
    if (radialLen < 0.0001)
    {
        // On axis: use arbitrary perpendicular direction
        float3 arbitrary = abs(RingAxis.x) < 0.9 ? float3(1, 0, 0) : float3(0, 1, 0);
        RadialDir = normalize(cross(RingAxis, arbitrary));
    }
    else
    {
        RadialDir = RadialVec / radialLen;
    }

    // Axial direction (up/down): vertex above pushes up, below pushes down
    float3 AxialDir = RingAxis * sign(axialComponent);

    // BulgeRadialRatio for Radial, remaining (1-ratio) for Axial
    float3 CombinedDir = RadialDir * BulgeRadialRatio + AxialDir * (1.0 - BulgeRadialRatio);

    float len = length(CombinedDir);
    return (len > 0.0001) ? (CombinedDir / len) : RadialDir;
}

// Debug
#define DEBUG_FORCE_BULGE 0
#define DEBUG_IGNORE_VOLUME 0
#define DEBUG_FIXED_STRENGTH 2.0

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    if (ThreadIndex >= NumBulgeVertices)
        return;

    uint VertexIndex = BulgeVertexIndices[ThreadIndex];

    if (VertexIndex >= NumTotalVertices)
    {
        return;
    }

    float3 Pos = ReadPosition(VertexIndex);

#if DEBUG_FORCE_BULGE
    {
        float3 LocalPos = TransformToSDFLocal(Pos);
        FRingGeometry Ring = ComputeRingGeometry();
        float3 BulgeDir = ComputeFleshCoveringDirection(LocalPos, Ring);
        float3 BulgeDirComponent = normalize(TransformDirectionToComponent(BulgeDir));
        WritePosition(VertexIndex, Pos + BulgeDirComponent * 5.0);
        return;
    }
#endif

    float CPUInfluence = BulgeInfluences[ThreadIndex];
    if (CPUInfluence < 0.001)
    {
        WritePosition(VertexIndex, Pos);
        return;
    }

    // Volume Loss (Ring-wise Atomic accumulation in TightnessCS)
    uint VolumeAccumFixed = VolumeAccumBuffer[RingIndex];
    float VolumeLoss = float(VolumeAccumFixed) * FixedPointScale;

    if (VolumeLoss < 0.001)
    {
        WritePosition(VertexIndex, Pos);
        return;
    }

    // ===== Direction filtering and Bulge direction calculation: SDF mode vs VirtualRing mode branch =====
    float3 BulgeDirComponent;
    float axialComponentForAsymmetric = 0.0;  // For asymmetric Bulge strength

    if (bUseSDFInfluence != 0)
    {
        // ===== SDF mode: Calculate in SDF Local Space then transform to Component Space =====
        float3 LocalPos = TransformToSDFLocal(Pos);
        FRingGeometry Ring = ComputeRingGeometry();

        // Calculate axial distance (for direction filtering)
        float3 ToVertex = LocalPos - Ring.Center;
        float axialComponent = dot(ToVertex, Ring.Axis);
        axialComponentForAsymmetric = axialComponent;  // For asymmetric strength calculation

        // Direction filtering (if BulgeAxisDirection != 0, process only one side)
        if (BulgeAxisDirection != 0)
        {
            int vertexSide = (axialComponent > 0.0) ? 1 : -1;
            if (vertexSide != BulgeAxisDirection)
            {
                WritePosition(VertexIndex, Pos);
                return;
            }
        }

        // Bulge direction: Calculate in SDF Local Space then transform to Component Space
        float3 BulgeDirLocal = ComputeFleshCoveringDirection(LocalPos, Ring);
        BulgeDirComponent = TransformDirectionToComponent(BulgeDirLocal);
    }
    else
    {
        // ===== VirtualRing mode: Calculate directly in Component Space (no SDF transform) =====

        // Calculate axial distance (for direction filtering)
        float3 ToVertex = Pos - RingCenter;
        float axialComponent = dot(ToVertex, RingAxis);
        axialComponentForAsymmetric = axialComponent;  // For asymmetric strength calculation

        // Direction filtering (if BulgeAxisDirection != 0, process only one side)
        if (BulgeAxisDirection != 0)
        {
            int vertexSide = (axialComponent > 0.0) ? 1 : -1;
            if (vertexSide != BulgeAxisDirection)
            {
                WritePosition(VertexIndex, Pos);
                return;
            }
        }

        // Bulge direction: Calculate directly in Component Space
        BulgeDirComponent = ComputeFleshCoveringDirection_VirtualRing(Pos);
    }

    // Direction vector normalization and validity check
    float dirLen = length(BulgeDirComponent);
    if (dirLen < 0.0001 || isnan(dirLen) || isinf(dirLen))
    {
        WritePosition(VertexIndex, Pos);
        return;
    }
    BulgeDirComponent = BulgeDirComponent / dirLen;

    // Bulge calculation
    // CPUInfluence = BulgeMask x DistInfluence (pre-calculated on CPU)
#if DEBUG_IGNORE_VOLUME
    float BulgeAmount = DEBUG_FIXED_STRENGTH * CPUInfluence;
#else
    float VolumeFactor = VolumeLoss / max(float(NumBulgeVertices), 1.0);
    float BulgeAmount = VolumeFactor * CPUInfluence * BulgeStrength;
#endif

    // Asymmetric Bulge: Apply upper/lower strength multiplier
    float asymmetricMultiplier = (axialComponentForAsymmetric > 0.0) ? UpperBulgeStrength : LowerBulgeStrength;
    BulgeAmount *= asymmetricMultiplier;

    BulgeAmount = clamp(BulgeAmount, 0.0, MaxBulgeDistance);

    // Position update
    float3 PosDelta = BulgeDirComponent * BulgeAmount;

    if (any(isnan(PosDelta)) || any(isinf(PosDelta)))
    {
        WritePosition(VertexIndex, Pos);
        return;
    }

    float deltaLen = length(PosDelta);
    if (deltaLen > MaxBulgeDistance)
    {
        PosDelta = PosDelta * (MaxBulgeDistance / deltaLen);
    }

    // Debug Point Output is handled in DebugPointOutputCS based on final positions

    WritePosition(VertexIndex, Pos + PosDelta);
}
