// Copyright Epic Games, Inc. All Rights Reserved.
// FleshRingBulgeCS.usf - Bulge Pass Compute Shader
// Wendland C2 Kernel 기반 부피 보존 변형 (CPU에서 Falloff 계산)

#include "/Engine/Public/Platform.ush"

// Buffers
Buffer<float> InputPositions;
StructuredBuffer<uint> BulgeVertexIndices;
StructuredBuffer<float> BulgeInfluences;
Buffer<uint> VolumeAccumBuffer;
RWBuffer<float> OutputPositions;

// SDF Parameters
Texture3D<float> SDFTexture;
SamplerState SDFSampler;
float3 SDFBoundsMin;
float3 SDFBoundsMax;
float4x4 ComponentToSDFLocal;

// Bulge Parameters
uint NumBulgeVertices;
uint NumTotalVertices;
float BulgeStrength;
float MaxBulgeDistance;
float FixedPointScale;
int BulgeAxisDirection;  // -1: 음의 축, +1: 양의 축, 0: 양방향
uint RingIndex;          // Ring 인덱스 (VolumeAccumBuffer 슬롯 지정용)
float BulgeRadialRatio;  // Radial vs Axial 방향 비율 (0.0~1.0, 기본 0.7)
float UpperBulgeStrength;  // 상단(축 양수) Bulge 강도 배수
float LowerBulgeStrength;  // 하단(축 음수) Bulge 강도 배수
uint bUseSDFInfluence;   // 0 = Manual (Component Space 직접), 1 = SDF 모드

// Ring Center/Axis (SDF Local Space) - SDF 모드용
float3 SDFLocalRingCenter;
float3 SDFLocalRingAxis;

// Ring Center/Axis (Component Space) - Manual 모드용
float3 RingCenter;
float3 RingAxis;
float RingHeight;

// ===== Debug Point Output =====
// GPU 디버그 렌더링용 포인트 버퍼 출력
struct FDebugPoint
{
    float3 WorldPosition;
    float Influence;
};
RWStructuredBuffer<FDebugPoint> DebugBulgePointBuffer;
uint bOutputDebugBulgePoints;       // 0 = 비활성화, 1 = 활성화
uint DebugBulgePointBaseOffset;     // 다중 링 지원용 오프셋
float4x4 BulgeLocalToWorld;         // Component -> World 변환 행렬

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

static const float SQRT2 = 1.41421356237;

// Position read/write
float3 ReadPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        InputPositions[BaseIndex + 0],
        InputPositions[BaseIndex + 1],
        InputPositions[BaseIndex + 2]
    );
}

void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

float3 TransformToSDFLocal(float3 ComponentPos)
{
    return mul(float4(ComponentPos, 1.0), ComponentToSDFLocal).xyz;
}

float3 TransformDirectionToComponent(float3 LocalDir)
{
    return mul(LocalDir, (float3x3)transpose(ComponentToSDFLocal));
}

struct FRingGeometry
{
    float3 Center;
    float3 Axis;
    float EffectWidth;
};

FRingGeometry ComputeRingGeometry()
{
    FRingGeometry Ring;

    // CPU에서 전달받은 Ring Center/Axis 사용 (바운드 확장 전에 정확한 위치)
    Ring.Center = SDFLocalRingCenter;
    Ring.Axis = SDFLocalRingAxis;

    // EffectWidth: CPUBoundsExpansionRatio에 맞춤
    // t = axialDist / EffectWidth > 1 이면 Bulge 영역 외부
    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;
    float minSize = min(BoundsSize.x, min(BoundsSize.y, BoundsSize.z));
    Ring.EffectWidth = minSize * 0.4;

    return Ring;
}


// 순수 방사 방향 (Ring 축에 수직, 바깥으로)
float3 ComputePureRadialDirection(float3 LocalPos, FRingGeometry Ring)
{
    float3 ToVertex = LocalPos - Ring.Center;
    float axialComponent = dot(ToVertex, Ring.Axis);
    float3 RadialVec = ToVertex - Ring.Axis * axialComponent;

    float radialLen = length(RadialVec);
    if (radialLen < 0.0001)
    {
        float3 arbitrary = abs(Ring.Axis.x) < 0.9 ? float3(1, 0, 0) : float3(0, 1, 0);
        return normalize(cross(Ring.Axis, arbitrary));
    }

    return RadialVec / radialLen;
}

// SDF Gradient 계산 (표면 법선 방향)
float3 ComputeSDFGradient(float3 LocalPos)
{
    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;
    float epsilon = max(BoundsSize.x, max(BoundsSize.y, BoundsSize.z)) / 64.0;

    float3 grad;
    float3 uvX1 = saturate((LocalPos + float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize);
    float3 uvX2 = saturate((LocalPos - float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize);
    grad.x = SDFTexture.SampleLevel(SDFSampler, uvX1, 0).r - SDFTexture.SampleLevel(SDFSampler, uvX2, 0).r;

    float3 uvY1 = saturate((LocalPos + float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize);
    float3 uvY2 = saturate((LocalPos - float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize);
    grad.y = SDFTexture.SampleLevel(SDFSampler, uvY1, 0).r - SDFTexture.SampleLevel(SDFSampler, uvY2, 0).r;

    float3 uvZ1 = saturate((LocalPos + float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize);
    float3 uvZ2 = saturate((LocalPos - float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize);
    grad.z = SDFTexture.SampleLevel(SDFSampler, uvZ1, 0).r - SDFTexture.SampleLevel(SDFSampler, uvZ2, 0).r;

    float len = length(grad);
    return (len > 0.0001) ? (grad / len) : float3(0, 0, 1);
}

// 살이 링을 덮는 방향 계산 (Radial + Axial, 비율은 BulgeRadialRatio로 조절)
// 링 위쪽 부분은 위로, 아랫부분은 아래로 밀려나는 느낌
// SDF 모드 (SDF Local Space)
float3 ComputeFleshCoveringDirection(float3 LocalPos, FRingGeometry Ring)
{
    float3 ToVertex = LocalPos - Ring.Center;
    float axialComponent = dot(ToVertex, Ring.Axis);

    // 방사 방향 (바깥으로)
    float3 RadialDir = ComputePureRadialDirection(LocalPos, Ring);

    // 축 방향 (위/아래): 버텍스가 위면 위로, 아래면 아래로
    float3 AxialDir = Ring.Axis * sign(axialComponent);

    // BulgeRadialRatio만큼 Radial, 나머지(1-ratio)만큼 Axial
    float3 CombinedDir = RadialDir * BulgeRadialRatio + AxialDir * (1.0 - BulgeRadialRatio);

    float len = length(CombinedDir);
    return (len > 0.0001) ? (CombinedDir / len) : RadialDir;
}

// Manual 모드 방향 계산 (Component Space에서 직접, SDF 변환 없음)
float3 ComputeFleshCoveringDirection_Manual(float3 ComponentPos)
{
    float3 ToVertex = ComponentPos - RingCenter;
    float axialComponent = dot(ToVertex, RingAxis);

    // 방사 방향 (바깥으로)
    float3 RadialVec = ToVertex - RingAxis * axialComponent;
    float radialLen = length(RadialVec);
    float3 RadialDir;
    if (radialLen < 0.0001)
    {
        // 축 위에 있는 경우: 임의의 수직 방향
        float3 arbitrary = abs(RingAxis.x) < 0.9 ? float3(1, 0, 0) : float3(0, 1, 0);
        RadialDir = normalize(cross(RingAxis, arbitrary));
    }
    else
    {
        RadialDir = RadialVec / radialLen;
    }

    // 축 방향 (위/아래): 버텍스가 위면 위로, 아래면 아래로
    float3 AxialDir = RingAxis * sign(axialComponent);

    // BulgeRadialRatio만큼 Radial, 나머지(1-ratio)만큼 Axial
    float3 CombinedDir = RadialDir * BulgeRadialRatio + AxialDir * (1.0 - BulgeRadialRatio);

    float len = length(CombinedDir);
    return (len > 0.0001) ? (CombinedDir / len) : RadialDir;
}

// Debug
#define DEBUG_FORCE_BULGE 0
#define DEBUG_IGNORE_VOLUME 0
#define DEBUG_FIXED_STRENGTH 2.0

// 무효 디버그 포인트 쓰기 헬퍼 (early return 시 호출)
// Influence = -1은 "이 포인트는 무효/스킵" 마커
void WriteInvalidDebugPoint(uint ThreadIndex)
{
    if (bOutputDebugBulgePoints != 0)
    {
        FDebugPoint InvalidPoint;
        InvalidPoint.WorldPosition = float3(0, 0, 0);
        InvalidPoint.Influence = -1.0;  // 무효 마커
        DebugBulgePointBuffer[DebugBulgePointBaseOffset + ThreadIndex] = InvalidPoint;
    }
}

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    if (ThreadIndex >= NumBulgeVertices)
        return;

    uint VertexIndex = BulgeVertexIndices[ThreadIndex];

    if (VertexIndex >= NumTotalVertices)
    {
        WriteInvalidDebugPoint(ThreadIndex);
        return;
    }

    float3 Pos = ReadPosition(VertexIndex);

#if DEBUG_FORCE_BULGE
    {
        float3 LocalPos = TransformToSDFLocal(Pos);
        FRingGeometry Ring = ComputeRingGeometry();
        float3 BulgeDir = ComputeFleshCoveringDirection(LocalPos, Ring);
        float3 BulgeDirComponent = normalize(TransformDirectionToComponent(BulgeDir));
        WritePosition(VertexIndex, Pos + BulgeDirComponent * 5.0);
        return;
    }
#endif

    float CPUInfluence = BulgeInfluences[ThreadIndex];
    if (CPUInfluence < 0.001)
    {
        WriteInvalidDebugPoint(ThreadIndex);
        WritePosition(VertexIndex, Pos);
        return;
    }

    // Volume Loss (TightnessCS에서 Ring별 Atomic 누적)
    uint VolumeAccumFixed = VolumeAccumBuffer[RingIndex];
    float VolumeLoss = float(VolumeAccumFixed) * FixedPointScale;

    if (VolumeLoss < 0.001)
    {
        WriteInvalidDebugPoint(ThreadIndex);
        WritePosition(VertexIndex, Pos);
        return;
    }

    // ===== 방향 필터링 및 Bulge 방향 계산: SDF 모드 vs Manual 모드 분기 =====
    float3 BulgeDirComponent;
    float axialComponentForAsymmetric = 0.0;  // 비대칭 Bulge 강도용

    if (bUseSDFInfluence != 0)
    {
        // ===== SDF 모드: SDF Local Space에서 계산 후 Component Space로 변환 =====
        float3 LocalPos = TransformToSDFLocal(Pos);
        FRingGeometry Ring = ComputeRingGeometry();

        // 축방향 거리 계산 (방향 필터링용)
        float3 ToVertex = LocalPos - Ring.Center;
        float axialComponent = dot(ToVertex, Ring.Axis);
        axialComponentForAsymmetric = axialComponent;  // 비대칭 강도 계산용

        // 방향 필터링 (BulgeAxisDirection != 0이면 한쪽만 처리)
        if (BulgeAxisDirection != 0)
        {
            int vertexSide = (axialComponent > 0.0) ? 1 : -1;
            if (vertexSide != BulgeAxisDirection)
            {
                WriteInvalidDebugPoint(ThreadIndex);
                WritePosition(VertexIndex, Pos);
                return;
            }
        }

        // Bulge 방향: SDF Local Space에서 계산 후 Component Space로 변환
        float3 BulgeDirLocal = ComputeFleshCoveringDirection(LocalPos, Ring);
        BulgeDirComponent = TransformDirectionToComponent(BulgeDirLocal);
    }
    else
    {
        // ===== Manual 모드: Component Space에서 직접 계산 (SDF 변환 없음) =====

        // 축방향 거리 계산 (방향 필터링용)
        float3 ToVertex = Pos - RingCenter;
        float axialComponent = dot(ToVertex, RingAxis);
        axialComponentForAsymmetric = axialComponent;  // 비대칭 강도 계산용

        // 방향 필터링 (BulgeAxisDirection != 0이면 한쪽만 처리)
        if (BulgeAxisDirection != 0)
        {
            int vertexSide = (axialComponent > 0.0) ? 1 : -1;
            if (vertexSide != BulgeAxisDirection)
            {
                WriteInvalidDebugPoint(ThreadIndex);
                WritePosition(VertexIndex, Pos);
                return;
            }
        }

        // Bulge 방향: Component Space에서 직접 계산
        BulgeDirComponent = ComputeFleshCoveringDirection_Manual(Pos);
    }

    // 방향 벡터 정규화 및 유효성 검사
    float dirLen = length(BulgeDirComponent);
    if (dirLen < 0.0001 || isnan(dirLen) || isinf(dirLen))
    {
        WriteInvalidDebugPoint(ThreadIndex);
        WritePosition(VertexIndex, Pos);
        return;
    }
    BulgeDirComponent = BulgeDirComponent / dirLen;

    // Bulge 계산
    // CPUInfluence = BulgeMask × DistInfluence (CPU에서 사전 계산)
#if DEBUG_IGNORE_VOLUME
    float BulgeAmount = DEBUG_FIXED_STRENGTH * CPUInfluence;
#else
    float VolumeFactor = VolumeLoss / max(float(NumBulgeVertices), 1.0);
    float BulgeAmount = VolumeFactor * CPUInfluence * BulgeStrength;
#endif

    // Asymmetric Bulge: 상단/하단 강도 배수 적용
    float asymmetricMultiplier = (axialComponentForAsymmetric > 0.0) ? UpperBulgeStrength : LowerBulgeStrength;
    BulgeAmount *= asymmetricMultiplier;

    BulgeAmount = clamp(BulgeAmount, 0.0, MaxBulgeDistance);

    // 위치 업데이트
    float3 PosDelta = BulgeDirComponent * BulgeAmount;

    if (any(isnan(PosDelta)) || any(isinf(PosDelta)))
    {
        WriteInvalidDebugPoint(ThreadIndex);
        WritePosition(VertexIndex, Pos);
        return;
    }

    float deltaLen = length(PosDelta);
    if (deltaLen > MaxBulgeDistance)
    {
        PosDelta = PosDelta * (MaxBulgeDistance / deltaLen);
    }

    // ===== Debug Point Output =====
    // GPU 디버그 렌더링용 포인트 버퍼 출력
    if (bOutputDebugBulgePoints != 0)
    {
        FDebugPoint DebugPoint;
        // 변형된 위치를 월드 공간으로 변환
        DebugPoint.WorldPosition = mul(float4(Pos + PosDelta, 1.0), BulgeLocalToWorld).xyz;
        DebugPoint.Influence = CPUInfluence;
        DebugBulgePointBuffer[DebugBulgePointBaseOffset + ThreadIndex] = DebugPoint;
    }

    WritePosition(VertexIndex, Pos + PosDelta);
}
