// Purpose: Pull vertices toward Ring center axis (Tightness effect)
// 목적: 버텍스를 링 중심축 방향으로 안쪽으로 당김 (조이기 효과)
// This shader processes only AffectedVertices (not all mesh vertices) for performance optimization.
// 성능 최적화를 위해 영향받는 버텍스만 처리 (전체 메시 버텍스 X)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/GpuSkinCommon.ush"
#include "FleshRingSDFSampling.ush"

/**
 * Buffer Declarations
 */
Buffer<float> SourcePositions;              // 메시의 원본 정점 위치(바인드 포즈 컴포넌트 스페이스)
StructuredBuffer<uint> AffectedIndices;     // 영향받는 정점 인덱스
StructuredBuffer<float> Influences;         // 정점별 영향도 (0~1, 감쇠 계산에서 산출)
RWBuffer<float> OutputPositions;            // 출력: 변형된 정점 위치
RWBuffer<uint> VolumeAccumBuffer;           // 출력: Bulge 패스용 부피 누적 버퍼 (Atomic 연산)

// ============================================================================
// Skinning Data (from GpuSkinCommon.ush pattern)
// 스키닝 데이터 (GpuSkinCommon.ush 패턴)
// ============================================================================

// Bone matrices buffer (3 float4 per bone = 3x4 matrix)
// 본 행렬 버퍼 (본당 3개의 float4 = 3x4 행렬)
Buffer<float4> BoneMatrices;

// Packed bone indices + weights (LOD-wide)
// 패킹된 본 인덱스 + 웨이트 (LOD 전체)
Buffer<uint> InputWeightStream;

// Skinning parameters
// 스키닝 파라미터
uint InputWeightStride;     // Stride in bytes / 바이트 단위 스트라이드
uint InputWeightIndexSize;  // BoneIndexByteSize | (BoneWeightByteSize << 8)
uint NumBoneInfluences;     // Number of bone influences per vertex / 버텍스당 본 영향 수

// Flag to enable/disable skinning (0 = bind pose, 1 = skinned)
// 스키닝 활성화 플래그 (0 = 바인드 포즈, 1 = 스키닝 적용)
uint bEnableSkinning;

// ============================================================================
// Ring Parameters
// 링 파라미터
// ============================================================================

float3 RingCenter;          // Ring center position (component space)
                            // 링 중심 위치 (컴포넌트 스페이스)
float3 RingAxis;            // Ring axis direction (normalized)
                            // 링 축 방향 (정규화됨)
float TightnessStrength;    // 조이기 변형 강도

// ============================================================================
// SDF Parameters
// ============================================================================

Texture3D<float> SDFTexture;
SamplerState SDFSampler;
float3 SDFBoundsMin;
float3 SDFBoundsMax;
uint bUseSDFInfluence;              // 0 = Manual, 1 = SDF
float4x4 ComponentToSDFLocal;       // Component → SDF Local (row vector 곱셈 사용)

// ============================================================================
// Counts & Volume Accumulation
// ============================================================================

uint NumAffectedVertices;
uint NumTotalVertices;
uint bAccumulateVolume;     // Bulge용 부피 누적 활성화
float FixedPointScale;      // float → uint 변환 스케일
uint RingIndex;             // VolumeAccumBuffer 슬롯

// Thread Group Size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Skinning Helper Functions (from FleshRingWave.usf)
// 스키닝 헬퍼 함수 (FleshRingWave.usf에서 가져옴)
// ============================================================================

// Get bone matrix from buffer (3 float4 = 3x4 matrix)
// 버퍼에서 본 행렬 가져오기 (3 float4 = 3x4 행렬)
float3x4 GetBoneMatrix(uint BoneIndex)
{
    uint BufferIndex = BoneIndex * 3;
    return float3x4(
        BoneMatrices[BufferIndex],
        BoneMatrices[BufferIndex + 1],
        BoneMatrices[BufferIndex + 2]
    );
}

// Transform position by 3x4 matrix
// 3x4 행렬로 위치 변환
float3 TransformByMatrix(float3x4 Matrix, float3 Position)
{
    float4 Pos4 = float4(Position, 1.0f);
    return float3(
        dot(Matrix[0], Pos4),
        dot(Matrix[1], Pos4),
        dot(Matrix[2], Pos4)
    );
}

// Compute blended skinning matrix for a vertex
// 버텍스의 블렌딩된 스키닝 행렬 계산
float3x4 ComputeSkinnedMatrix(uint VertexIndex)
{
    // Calculate stream offset for this vertex
    // 이 버텍스의 스트림 오프셋 계산
    uint StreamOffset = VertexIndex * (InputWeightStride / 4);

    // Initialize indices and weights
    // 인덱스와 웨이트 초기화
    FGPUSkinIndexAndWeight IndicesAndWeights = (FGPUSkinIndexAndWeight)0;

    // Get first 4 bone influences
    // 첫 4개 본 영향 가져오기
    if (NumBoneInfluences > 0)
    {
        IndicesAndWeights.BlendIndices = GetBlendIndices(InputWeightStream, StreamOffset, 0);
        IndicesAndWeights.BlendWeights = GetBlendWeights(InputWeightStream, StreamOffset, 0, NumBoneInfluences);
    }

    // Get additional 4 bone influences (if 8-bone skinning)
    // 추가 4개 본 영향 가져오기 (8본 스키닝인 경우)
    if (NumBoneInfluences > 4)
    {
        IndicesAndWeights.BlendIndices2 = GetBlendIndices(InputWeightStream, StreamOffset, 1);
        IndicesAndWeights.BlendWeights2 = GetBlendWeights(InputWeightStream, StreamOffset, 1, NumBoneInfluences);
    }

    // Compute blended bone matrix
    // 블렌딩된 본 행렬 계산
    return ComputeBoneMatrixWithLimitedInfluences(BoneMatrices, IndicesAndWeights, NumBoneInfluences > 4);
}

// ============================================================================
// Position Read/Write Helper Functions
// 위치 읽기/쓰기 헬퍼 함수
// ============================================================================

// Read vertex position from buffer (3 floats per vertex)
// 버퍼에서 버텍스 위치 읽기 (버텍스당 3 float)
float3 ReadPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        SourcePositions[BaseIndex + 0],
        SourcePositions[BaseIndex + 1],
        SourcePositions[BaseIndex + 2]
    );
}

// Write vertex position to buffer (3 floats per vertex)
// 버퍼에 버텍스 위치 쓰기 (버텍스당 3 float)
void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

// ============================================================================
// Tightness Deformation Functions
// ============================================================================

// Manual 모드: 단순 반경 방향 내부 변위
float3 ApplyTightnessDeformation(float3 Pos, float3 Center, float3 Axis, float Influence, float Strength)
{
    float3 ToVertex = Pos - Center;
    float AxisDist = dot(ToVertex, Axis);
    float3 RadialVec = ToVertex - Axis * AxisDist;
    float RadialDist = length(RadialVec);

    if (RadialDist < 0.001)
        return Pos;

    float3 InwardDir = -RadialVec / RadialDist;
    return Pos + InwardDir * Strength * Influence;
}

// SDF 모드: 방사형 투영 기반 변형
float3 ApplyTightnessDeformation_SDF(float3 Pos, float3 BindPos, float Strength)
{
    // STEP 1: Component → SDF Local 좌표 변환
    float3 LocalPos = mul(float4(BindPos, 1.0), ComponentToSDFLocal).xyz;
    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;
    float3 UV = (LocalPos - SDFBoundsMin) / BoundsSize;

    // STEP 2: 조기 종료 (이미 내부면 패스)
    float Distance = SDFTexture.SampleLevel(SDFSampler, saturate(UV), 0).r;
    if (Distance <= 0.0)
        return Pos;

    // STEP 3: Z 범위 체크 (링 위/아래 버텍스 필터링)
    float originalZ_UV = (LocalPos.z - SDFBoundsMin.z) / BoundsSize.z;
    if (originalZ_UV < -0.1 || originalZ_UV > 1.1)
        return Pos;

    // STEP 4: 방사형 레이마칭 (Radial Projection)
    float3 CurrentPos = LocalPos;
    float epsilon = max(BoundsSize.x, max(BoundsSize.y, BoundsSize.z)) / 64.0;
    float3 lastDir = float3(0, 0, 0);

    // 바운드에서 링 중심/축 추론 (가장 얇은 축 = 구멍의 축 방향)
    float3 LocalRingCenter = (SDFBoundsMin + SDFBoundsMax) * 0.5;
    float3 LocalRingAxis;
    if (BoundsSize.z < BoundsSize.x && BoundsSize.z < BoundsSize.y)
        LocalRingAxis = float3(0, 0, 1);
    else if (BoundsSize.y < BoundsSize.x)
        LocalRingAxis = float3(0, 1, 0);
    else
        LocalRingAxis = float3(1, 0, 0);

    // 방사형 레이마칭: 축을 향해 이동하며 구멍(SDF < 0) 찾기
    // Gradient 방식 대신 방사형 사용 이유: 링 바깥면에 붙는 현상 방지
    for (int i = 0; i < 47; i++)
    {
        float3 CurUV = saturate((CurrentPos - SDFBoundsMin) / BoundsSize);
        float CurDist = SDFTexture.SampleLevel(SDFSampler, CurUV, 0).r;

        if (CurDist < 0.0)
            break;

        // 방사형 방향: 축 성분 제거 후 안쪽으로
        float3 fromCenter = CurrentPos - LocalRingCenter;
        float axialDist = dot(fromCenter, LocalRingAxis);
        float3 outwardRadial = fromCenter - LocalRingAxis * axialDist;

        float radialLen = length(outwardRadial);
        if (radialLen < 0.0001)
            break;

        float3 dir = -outwardRadial / radialLen;
        lastDir = dir;

        // omega ∈ [1, 2): over-relaxation factor로 수렴 속도 향상
        // Reference: Keinert et al. 2014, Bálint & Valasek 2018
        // Over-relaxation (omega=1.3)으로 수렴 가속
        CurrentPos += dir * CurDist * 1.3;
    }

    // STEP 5: 사후 검증
    if (length(lastDir) <= 0.0001)
        return Pos;

    // Probe 체크: 표면 너머가 구멍인지 확인
    // - 구멍으로 가는 입구 vs 링 옆면 구분
    // - probePos에서 SDF < 0.6이면 구멍, 아니면 외부
    float3 probePos = CurrentPos + lastDir * epsilon * 8.0;
    float3 probeUV = saturate((probePos - SDFBoundsMin) / BoundsSize);
    float probeSDF = SDFTexture.SampleLevel(SDFSampler, probeUV, 0).r;
    if (probeSDF > 0.6)
        return Pos;

    // STEP 6: 변위 계산 및 적용
    float3 DisplacementLocal = CurrentPos - LocalPos;

    // Z축 변위 제한 (링 위/아래 버텍스가 구멍으로 들어가는 것 방지)
    if (abs(DisplacementLocal.z) > BoundsSize.z * 0.5)
        return Pos;

    // Local → Component 변환 (transpose = 역행렬)
    float3 DisplacementComponent = mul(DisplacementLocal, (float3x3)transpose(ComponentToSDFLocal));
    return Pos + DisplacementComponent * Strength;
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    // Bounds check: Only process affected vertices
    // 범위 체크: 영향받는 버텍스만 처리
    if (ThreadIndex >= NumAffectedVertices)
    {
        return;
    }

    // Get the actual vertex index from AffectedIndices buffer
    // AffectedIndices 버퍼에서 실제 버텍스 인덱스 가져오기
    uint VertexIndex = AffectedIndices[ThreadIndex];

    // Safety check: Ensure vertex index is valid
    // 안전 체크: 버텍스 인덱스 유효성 확인
    if (VertexIndex >= NumTotalVertices)
    {
        return;
    }

    // Read bind pose position (bind pose component space)
    // 바인드 포즈 위치 읽기 (바인드 포즈 컴포넌트 스페이스)
    float3 BindPos = ReadPosition(VertexIndex);

    // ========================================
    // Step 1: Apply GPU Skinning (if enabled)
    // 1단계: GPU 스키닝 적용 (활성화된 경우)
    // ========================================
    float3 Pos;
    if (bEnableSkinning != 0)
    {
        // Apply skinning: BindPos → SkinnedPos (animated component space)
        // 스키닝 적용: 바인드 포즈 → 스킨된 포즈 (애니메이션된 컴포넌트 스페이스)
        float3x4 SkinMatrix = ComputeSkinnedMatrix(VertexIndex);
        Pos = TransformByMatrix(SkinMatrix, BindPos);
    }
    else
    {
        // No skinning: use bind pose directly
        // 스키닝 없음: 바인드 포즈 직접 사용
        Pos = BindPos;
    }

    // Step 2: Apply Tightness Deformation
    float3 NewPos;
    
    if(bUseSDFInfluence != 0)
    {
        // SDF 모드 : Gradient 기반 변형
        //float3 LocalPos = TransformToSDFLocal(BindPos);
        NewPos = ApplyTightnessDeformation_SDF(Pos, BindPos, TightnessStrength);
    }
    else
    {
        // ===== Manual 모드: 기존 로직 =====
        float Influence = Influences[ThreadIndex];
        
        // Skip if influence is negligible
        if (Influence < 0.001)
        {
            WritePosition(VertexIndex, Pos);
            return;
        }
        
        NewPos = ApplyTightnessDeformation(
            Pos,
            RingCenter,
            RingAxis,
            Influence,
            TightnessStrength
        );
    }
    
    // ========================================
    // Step 3: Volume Accumulation (for Bulge pass)
    // 3단계: 부피 누적 (Bulge 패스용)
    // ========================================
    // Tightness로 눌린 양을 Atomic으로 Ring별 누적
    // 각 Ring의 압축량이 VolumeAccumBuffer[RingIndex]에 저장됨
    // BulgeCS에서 자신의 Ring 슬롯을 읽어서 Bulge 적용
    if (bAccumulateVolume != 0)
    {
        // 압축량 = 이동 거리
        float compressionAmount = length(NewPos - Pos);

        // 압축량이 있을 때만 누적 (성능 최적화)
        if (compressionAmount > 0.0001)
        {
            // Float → Fixed-point (예: 0.5 * 1000 = 500)
            uint compressedFixed = uint(compressionAmount * FixedPointScale);

            // Atomic 연산으로 Ring별 슬롯에 누적
            InterlockedAdd(VolumeAccumBuffer[RingIndex], compressedFixed);
        }
    }

    // ========================================
    // Step 4: Write Output
    // 4단계: 출력 쓰기
    // ========================================
    WritePosition(VertexIndex, NewPos);
}
