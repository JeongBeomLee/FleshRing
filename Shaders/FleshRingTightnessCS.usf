// Purpose: Pull vertices toward Ring center axis (Tightness effect)
// 목적: 버텍스를 링 중심축 방향으로 안쪽으로 당김 (조이기 효과)
// This shader processes only AffectedVertices (not all mesh vertices) for performance optimization.
// 성능 최적화를 위해 영향받는 버텍스만 처리 (전체 메시 버텍스 X)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/GpuSkinCommon.ush"
#include "FleshRingSDFSampling.ush"
// ============================================================================
// Buffer Declarations
// 버퍼 선언
// ============================================================================

// Input: All mesh vertex positions (bind pose component space)
// 입력: 메시의 원본 정점 위치 (바인드 포즈 컴포넌트 스페이스)
Buffer<float> SourcePositions;

// Input: Indices of affected vertices to process
// 입력: 처리할 영향받는 정점 인덱스
StructuredBuffer<uint> AffectedIndices;

// Input: Per-vertex influence weights (0-1, from falloff calculation)
// 입력: 정점별 영향도 (0~1, 감쇠 계산에서 산출)
StructuredBuffer<float> Influences;

// Output: Deformed vertex positions
// 출력: 변형된 정점 위치
RWBuffer<float> OutputPositions;

// ============================================================================
// Skinning Data (from GpuSkinCommon.ush pattern)
// 스키닝 데이터 (GpuSkinCommon.ush 패턴)
// ============================================================================

// Bone matrices buffer (3 float4 per bone = 3x4 matrix)
// 본 행렬 버퍼 (본당 3개의 float4 = 3x4 행렬)
Buffer<float4> BoneMatrices;

// Packed bone indices + weights (LOD-wide)
// 패킹된 본 인덱스 + 웨이트 (LOD 전체)
Buffer<uint> InputWeightStream;

// Skinning parameters
// 스키닝 파라미터
uint InputWeightStride;     // Stride in bytes / 바이트 단위 스트라이드
uint InputWeightIndexSize;  // BoneIndexByteSize | (BoneWeightByteSize << 8)
uint NumBoneInfluences;     // Number of bone influences per vertex / 버텍스당 본 영향 수

// Flag to enable/disable skinning (0 = bind pose, 1 = skinned)
// 스키닝 활성화 플래그 (0 = 바인드 포즈, 1 = 스키닝 적용)
uint bEnableSkinning;

// ============================================================================
// Ring Parameters
// 링 파라미터
// ============================================================================

float3 RingCenter;          // Ring center position (component space)
                            // 링 중심 위치 (컴포넌트 스페이스)
float3 RingAxis;            // Ring axis direction (normalized)
                            // 링 축 방향 (정규화됨)
float TightnessStrength;    // Tightness deformation strength
                            // 조이기 변형 강도
float RingRadius;           // Ring inner radius
                            // 링 내부 반지름
float RingWidth;            // Ring height along axis
                            // 링 높이 (축 방향)

// ============================================================================
// SDF Parameters (OBB Design)
// SDF 파라미터 (OBB 설계)
// ============================================================================
//
// Design: SDF in Ring Local Space (OBB)
// 설계: SDF를 Ring 로컬 스페이스에서 생성 (OBB)
//
// ┌─────────────────────────────────────────────────────────────────────┐
// │ SDF Generation:                                                     │
// │   Ring Mesh는 로컬 스페이스에서 SDF 생성 (회전 적용 X)               │
// │   → 바운딩 박스가 AABB로 유지되어 효율적                             │
// │                                                                     │
// │ Shader Sampling:                                                    │
// │   BindPos (Component Space) → ComponentToSDFLocal 역변환            │
// │   → LocalPos로 SDF 샘플링                                           │
// └─────────────────────────────────────────────────────────────────────┘
//
// Benefit: OBB 지원, Ring 회전 시에도 효율적인 바운딩 유지
//

// SDF 3D texture (Ring 로컬 스페이스)
// SDF 3D 텍스처
Texture3D<float> SDFTexture;

// Trilinear sampler for smooth SDF interpolation
// 부드러운 SDF 보간용 삼선형 샘플러
SamplerState SDFSampler;

// SDF volume bounds (Ring 로컬 스페이스)
// SDF 볼륨 바운드
float3 SDFBoundsMin;        // Volume minimum corner / 볼륨 최소 코너
float3 SDFBoundsMax;        // Volume maximum corner / 볼륨 최대 코너

// Flag: 0 = Use Influences buffer (Manual), 1 = Use SDF sampling (Auto)
// 플래그: 0 = Influences 버퍼 사용 (수동), 1 = SDF 샘플링 사용 (자동)
uint bUseSDFInfluence;

// Component space → SDF local space transform matrix (OBB support)
// 컴포넌트 스페이스 → SDF 로컬 스페이스 변환 행렬 (OBB 지원)
// BindPos를 로컬로 역변환 후 SDF 샘플링에 사용
float4x4 ComponentToSDFLocal;

// ============================================================================
// Counts
// 버텍스 수
// ============================================================================

uint NumAffectedVertices;   // Number of affected vertices to process
                            // 처리할 영향받는 버텍스 수
uint NumTotalVertices;      // Total mesh vertex count (for bounds check)
                            // 전체 메시 버텍스 수 (범위 체크용)

// Thread Group Size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Skinning Helper Functions (from FleshRingWave.usf)
// 스키닝 헬퍼 함수 (FleshRingWave.usf에서 가져옴)
// ============================================================================

// Get bone matrix from buffer (3 float4 = 3x4 matrix)
// 버퍼에서 본 행렬 가져오기 (3 float4 = 3x4 행렬)
float3x4 GetBoneMatrix(uint BoneIndex)
{
    uint BufferIndex = BoneIndex * 3;
    return float3x4(
        BoneMatrices[BufferIndex],
        BoneMatrices[BufferIndex + 1],
        BoneMatrices[BufferIndex + 2]
    );
}

// Transform position by 3x4 matrix
// 3x4 행렬로 위치 변환
float3 TransformByMatrix(float3x4 Matrix, float3 Position)
{
    float4 Pos4 = float4(Position, 1.0f);
    return float3(
        dot(Matrix[0], Pos4),
        dot(Matrix[1], Pos4),
        dot(Matrix[2], Pos4)
    );
}

// Compute blended skinning matrix for a vertex
// 버텍스의 블렌딩된 스키닝 행렬 계산
float3x4 ComputeSkinnedMatrix(uint VertexIndex)
{
    // Calculate stream offset for this vertex
    // 이 버텍스의 스트림 오프셋 계산
    uint StreamOffset = VertexIndex * (InputWeightStride / 4);

    // Initialize indices and weights
    // 인덱스와 웨이트 초기화
    FGPUSkinIndexAndWeight IndicesAndWeights = (FGPUSkinIndexAndWeight)0;

    // Get first 4 bone influences
    // 첫 4개 본 영향 가져오기
    if (NumBoneInfluences > 0)
    {
        IndicesAndWeights.BlendIndices = GetBlendIndices(InputWeightStream, StreamOffset, 0);
        IndicesAndWeights.BlendWeights = GetBlendWeights(InputWeightStream, StreamOffset, 0, NumBoneInfluences);
    }

    // Get additional 4 bone influences (if 8-bone skinning)
    // 추가 4개 본 영향 가져오기 (8본 스키닝인 경우)
    if (NumBoneInfluences > 4)
    {
        IndicesAndWeights.BlendIndices2 = GetBlendIndices(InputWeightStream, StreamOffset, 1);
        IndicesAndWeights.BlendWeights2 = GetBlendWeights(InputWeightStream, StreamOffset, 1, NumBoneInfluences);
    }

    // Compute blended bone matrix
    // 블렌딩된 본 행렬 계산
    return ComputeBoneMatrixWithLimitedInfluences(BoneMatrices, IndicesAndWeights, NumBoneInfluences > 4);
}

// ============================================================================
// Position Read/Write Helper Functions
// 위치 읽기/쓰기 헬퍼 함수
// ============================================================================

// Read vertex position from buffer (3 floats per vertex)
// 버퍼에서 버텍스 위치 읽기 (버텍스당 3 float)
float3 ReadPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        SourcePositions[BaseIndex + 0],
        SourcePositions[BaseIndex + 1],
        SourcePositions[BaseIndex + 2]
    );
}

// Write vertex position to buffer (3 floats per vertex)
// 버퍼에 버텍스 위치 쓰기 (버텍스당 3 float)
void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

// ============================================================================
// SDF Sampling Helper Functions
// SDF 샘플링 헬퍼 함수
// ============================================================================
//
// OBB Design: Transform vertex to local space before sampling
// OBB 설계: SDF 샘플링 전에 버텍스를 로컬 스페이스로 변환
//
// SDF는 Ring 로컬 스페이스에서 생성됨
// BindPos(컴포넌트 스페이스)를 ComponentToSDFLocal로 역변환 후 샘플링
//

// Transform component space position to SDF local space
// 컴포넌트 스페이스 위치를 SDF 로컬 스페이스로 변환
float3 TransformToSDFLocal(float3 ComponentPos)
{
    //float4 LocalPos = mul(float4(ComponentPos, 1.0f), ComponentToSDFLocal);
    float4 LocalPos = mul(ComponentToSDFLocal, float4(ComponentPos, 1.0f));
    return LocalPos.xyz;
}

// Convert local position to SDF UV coordinates [0, 1]
// 로컬 위치를 SDF UV 좌표 [0, 1]로 변환
float3 PositionToSDFUV(float3 LocalPos)
{
    float3 Range = SDFBoundsMax - SDFBoundsMin;

    // Avoid division by zero / 0으로 나누기 방지
    Range = max(Range, float3(0.001, 0.001, 0.001));

    return (LocalPos - SDFBoundsMin) / Range;
}

// Sample SDF distance at local position
// 로컬 위치에서 SDF 거리 샘플링
// Returns: Signed distance (negative = inside, positive = outside)
// 반환: 부호 있는 거리 (음수 = 내부, 양수 = 외부)
float SampleSDFDistance(float3 LocalPos)
{
    float3 UV = PositionToSDFUV(LocalPos);

    // Clamp to valid range / 유효 범위로 클램프
    UV = saturate(UV);

    // Trilinear sampling / 삼선형 샘플링
    return SDFTexture.SampleLevel(SDFSampler, UV, 0).r;
}

// Calculate influence from SDF distance (OBB version)
// SDF 거리에서 영향도 계산 (OBB 버전)
// Input: ComponentPos (컴포넌트 스페이스 위치)
// Returns: Influence [0, 1] / 반환: 영향도 [0, 1]
//
// SDF 부호 (시각화 기준):
//   파란색 (SDF < 0): 링 구멍 내부 → 영향 없음
//   빨간색 (SDF > 0): 링 바깥 튀어나옴 → 밀어내야 함
//
float CalculateInfluenceFromSDF(float3 ComponentPos)
{
    float3 LocalPos = TransformToSDFLocal(ComponentPos);
    float Distance = SampleSDFDistance(LocalPos);

    // SDF < 0: 링 구멍 내부 (파란색) → 영향 없음
    if (Distance < 0.0)
    {
        return 0.0;
    }

    // SDF >= 0: 링 바깥 (빨간색) → 밀어내야 함
    // 일단 최대 영향 1.0 반환
    return 1.0;
}

// ============================================================================
// Tightness Deformation Function
// 조이기 변형 함수
// ============================================================================

// [FLEXIBLE] Deformation Formula
// This function can be modified to implement different deformation algorithms
// (e.g., volume-preserving deformation based on research papers)
// 이 함수는 다양한 변형 알고리즘으로 수정 가능
// (예: 부피 보존 변형, 라플라시안 제약 등)

// Current implementation: Simple radial inward displacement
// 현재 구현: 단순 반경 방향 내부 변위
float3 ApplyTightnessDeformation(
    float3 Pos,
    float3 Center,
    float3 Axis,
    float Influence,
    float Strength)
{
    // Ring center to vertex
    // 링 중심에서 버텍스까지
    float3 ToVertex = Pos - Center;

    // Project onto ring axis to find axial distance
    // 축에 투영하여 축 방향 거리 계산
    float AxisDist = dot(ToVertex, Axis);

    // Calculate radial vector (perpendicular to axis)
    // 반경 벡터 계산 (축에 수직)
    float3 RadialVec = ToVertex - Axis * AxisDist;
    float RadialDist = length(RadialVec);

    // Safety check for vertices on the axis
    // 축 위에 있는 버텍스 안전 체크
    if (RadialDist < 0.001)
    {
        return Pos;
    }

    // Calculate inward direction (toward ring axis)
    // 안쪽 방향 계산 (링 축을 향해)
    float3 InwardDir = -RadialVec / RadialDist;

    // [CHANGEABLE] Calculate displacement amount
    // Current: Linear displacement based on strength and influence
    // Future: Can be modified for volume preservation
    // [변경 가능] 변위량 계산
    // 현재: 강도와 영향도 기반 선형 변위
    // 미래: 부피 보존용으로 수정 가능
    float Displacement = Strength * Influence;

    // Apply inward displacement
    // 안쪽 변위 적용
    float3 NewPos = Pos + InwardDir * Displacement;

    return NewPos;
}
// Component Space에서 직접 Gradient 계산
float3 SampleSDFGradient_ComponentSpace(float3 ComponentPos)
{
    float epsilon = 0.5f;
    
    float3 gradient;
    
    // X 방향 - SampleSDFDistance 사용!
    float3 LocalPosX1 = TransformToSDFLocal(ComponentPos + float3(epsilon, 0, 0));
    float3 LocalPosX2 = TransformToSDFLocal(ComponentPos - float3(epsilon, 0, 0));
    gradient.x = SampleSDFDistance(LocalPosX1) - SampleSDFDistance(LocalPosX2);
    
    // Y 방향
    float3 LocalPosY1 = TransformToSDFLocal(ComponentPos + float3(0, epsilon, 0));
    float3 LocalPosY2 = TransformToSDFLocal(ComponentPos - float3(0, epsilon, 0));
    gradient.y = SampleSDFDistance(LocalPosY1) - SampleSDFDistance(LocalPosY2);
    
    // Z 방향
    float3 LocalPosZ1 = TransformToSDFLocal(ComponentPos + float3(0, 0, epsilon));
    float3 LocalPosZ2 = TransformToSDFLocal(ComponentPos - float3(0, 0, epsilon));
    gradient.z = SampleSDFDistance(LocalPosZ1) - SampleSDFDistance(LocalPosZ2);
    
    float len = length(gradient);
    if (len < 0.0001f)
        return float3(0, 0, 1);
    
    return gradient / len;
}
// SDF 변형 함수
float3 ApplyTightnessDeformation_SDF(float3 Pos, float3 BindPos, float Strength)
{
    //// Local Space에서 SDF 샘플링
    //float3 LocalPos = TransformToSDFLocal(BindPos);
    
    //// ===== 범위 체크: SDF 볼륨 밖이면 변형 없음 =====
    //float3 UV = PositionToSDFUV(LocalPos);
    //if (any(UV < 0.0) || any(UV > 1.0))
        //return Pos;
    
    //float Distance = SampleSDFDistance(LocalPos);
    
    //// 내부 = 변형 없음
    //if (Distance <= 0.0)
        //return Pos;
    
    //// Component Space에서 Gradient 계산
    //float3 PushDir = -SampleSDFGradient_ComponentSpace(BindPos);
    //float PushAmount = Distance*10; // Strength 들어오는 값이 3이라 너무 세서 Distance만 사용하도록 바꿔놓음
    ////float PushAmount = Distance * Strength;
    
    //return Pos + PushDir * PushAmount;
    
//    // ===== Position 변환: Component → Local =====
//    float4x4 PosMatrix = transpose(ComponentToSDFLocal);
//    float3 LocalPos = mul(PosMatrix, float4(BindPos, 1.0)).xyz;

//// UV 계산
//    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;
//    float3 UV = (LocalPos - SDFBoundsMin) / BoundsSize;

//    if (any(UV < 0.0) || any(UV > 1.0))
//        return Pos;

//// SDF 샘플링
//    float Distance = SDFTexture.SampleLevel(SDFSampler, UV, 0).r;

//    if (Distance <= 0.0)
//        return Pos;

//    Distance = min(Distance, 2.0);

//// Gradient 계산 (Local Space)
//    float epsilon = max(BoundsSize.x, max(BoundsSize.y, BoundsSize.z)) / 64.0;
//    float3 gradient;

//    float3 uvX1 = (LocalPos + float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize;
//    float3 uvX2 = (LocalPos - float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize;
//    gradient.x = SDFTexture.SampleLevel(SDFSampler, saturate(uvX1), 0).r
//           - SDFTexture.SampleLevel(SDFSampler, saturate(uvX2), 0).r;

//    float3 uvY1 = (LocalPos + float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize;
//    float3 uvY2 = (LocalPos - float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize;
//    gradient.y = SDFTexture.SampleLevel(SDFSampler, saturate(uvY1), 0).r
//           - SDFTexture.SampleLevel(SDFSampler, saturate(uvY2), 0).r;

//    float3 uvZ1 = (LocalPos + float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize;
//    float3 uvZ2 = (LocalPos - float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize;
//    gradient.z = SDFTexture.SampleLevel(SDFSampler, saturate(uvZ1), 0).r
//           - SDFTexture.SampleLevel(SDFSampler, saturate(uvZ2), 0).r;

//    float len = length(gradient);
//    if (len < 0.0001)
//        return Pos;

//    float3 gradientLocal = gradient / len;

//// ===== Direction 변환: Local → Component =====
//// Direction은 transpose 안 함 (inverse-transpose 관계)
//    float3 gradientComponent = mul((float3x3) ComponentToSDFLocal, gradientLocal);
//    gradientComponent = normalize(gradientComponent);

//// -Gradient 방향 = SDF 감소 방향 = 표면 방향
//    float3 PushDir = -gradientComponent;

//    return Pos + PushDir * Distance * Strength;
    
    
    //// 되는 버전 
    //float4x4 ToLocal = transpose(ComponentToSDFLocal);
    //float3 LocalPos = mul(ToLocal, float4(BindPos, 1.0)).xyz;

    //float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;
    //float3 UV = (LocalPos - SDFBoundsMin) / BoundsSize;

    //if (any(UV < 0.0) || any(UV > 1.0))
    //    return Pos;

    //float Distance = SDFTexture.SampleLevel(SDFSampler, UV, 0).r;

    //if (Distance <= 0.0)
    //    return Pos;

    //// ===== 레이마칭: 매 스텝마다 gradient 재계산 =====
    //float3 CurrentPos = LocalPos;
    //float epsilon = max(BoundsSize.x, max(BoundsSize.y, BoundsSize.z)) / 64.0;

    //for (int i = 0; i < 8; i++)
    //{
    //    float3 CurUV = (CurrentPos - SDFBoundsMin) / BoundsSize;
    //    float CurDist = SDFTexture.SampleLevel(SDFSampler, saturate(CurUV), 0).r;

    //    if (CurDist <= 0.0)
    //        break;

    //    // 현재 위치에서 gradient 계산
    //    float3 grad;
    //    float3 uvX1 = (CurrentPos + float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize;
    //    float3 uvX2 = (CurrentPos - float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize;
    //    grad.x = SDFTexture.SampleLevel(SDFSampler, saturate(uvX1), 0).r
    //       - SDFTexture.SampleLevel(SDFSampler, saturate(uvX2), 0).r;

    //    float3 uvY1 = (CurrentPos + float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize;
    //    float3 uvY2 = (CurrentPos - float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize;
    //    grad.y = SDFTexture.SampleLevel(SDFSampler, saturate(uvY1), 0).r
    //       - SDFTexture.SampleLevel(SDFSampler, saturate(uvY2), 0).r;

    //    float3 uvZ1 = (CurrentPos + float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize;
    //    float3 uvZ2 = (CurrentPos - float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize;
    //    grad.z = SDFTexture.SampleLevel(SDFSampler, saturate(uvZ1), 0).r
    //       - SDFTexture.SampleLevel(SDFSampler, saturate(uvZ2), 0).r;

    //    float len = length(grad);
    //    if (len < 0.0001)
    //        break;

    //    // -gradient 방향으로 CurDist만큼 이동
    //    float3 dir = -grad / len;
    //    CurrentPos += dir * CurDist;
    //}

    //// ===== Local Space 변위 계산 =====
    //float3 DisplacementLocal = CurrentPos - LocalPos;

    //// ===== Local → Component 변환 =====
    //float3 DisplacementComponent = mul((float3x3) ComponentToSDFLocal, DisplacementLocal);

    //return Pos + DisplacementComponent * Strength;
    
    float4x4 ToLocal = transpose(ComponentToSDFLocal);
    float3 LocalPos = mul(ToLocal, float4(BindPos, 1.0)).xyz;

    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;
    float3 UV = (LocalPos - SDFBoundsMin) / BoundsSize;

// ===== 바운드 밖이면 경계로 클램프해서 샘플링 =====
    float3 ClampedUV = saturate(UV);
    float3 ClampedLocalPos = SDFBoundsMin + ClampedUV * BoundsSize;

    float Distance = SDFTexture.SampleLevel(SDFSampler, ClampedUV, 0).r;

// 바운드 밖인 경우, 바운드까지의 거리도 추가
    float3 OutsideDist = float3(0, 0, 0);
    if (UV.x < 0.0)
        OutsideDist.x = (SDFBoundsMin.x - LocalPos.x);
    if (UV.x > 1.0)
        OutsideDist.x = (LocalPos.x - SDFBoundsMax.x);
    if (UV.y < 0.0)
        OutsideDist.y = (SDFBoundsMin.y - LocalPos.y);
    if (UV.y > 1.0)
        OutsideDist.y = (LocalPos.y - SDFBoundsMax.y);
    if (UV.z < 0.0)
        OutsideDist.z = (SDFBoundsMin.z - LocalPos.z);
    if (UV.z > 1.0)
        OutsideDist.z = (LocalPos.z - SDFBoundsMax.z);
    float ExtraDistance = length(OutsideDist);

// 총 거리 = 바운드 밖 거리 + 경계에서의 SDF 값
    float TotalDistance = ExtraDistance + max(Distance, 0.0);

    if (TotalDistance <= 0.0)
        return Pos;

// ===== 레이마칭: 경계 위치에서 시작 =====
    float3 CurrentPos = ClampedLocalPos;
    float epsilon = max(BoundsSize.x, max(BoundsSize.y, BoundsSize.z)) / 64.0;

    for (int i = 0; i < 8; i++)
    {
        float3 CurUV = saturate((CurrentPos - SDFBoundsMin) / BoundsSize);
        float CurDist = SDFTexture.SampleLevel(SDFSampler, CurUV, 0).r;

        if (CurDist <= 0.0)
            break;

    // gradient 계산
        float3 grad;
        float3 uvX1 = saturate((CurrentPos + float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize);
        float3 uvX2 = saturate((CurrentPos - float3(epsilon, 0, 0) - SDFBoundsMin) / BoundsSize);
        grad.x = SDFTexture.SampleLevel(SDFSampler, uvX1, 0).r
           - SDFTexture.SampleLevel(SDFSampler, uvX2, 0).r;

        float3 uvY1 = saturate((CurrentPos + float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize);
        float3 uvY2 = saturate((CurrentPos - float3(0, epsilon, 0) - SDFBoundsMin) / BoundsSize);
        grad.y = SDFTexture.SampleLevel(SDFSampler, uvY1, 0).r
           - SDFTexture.SampleLevel(SDFSampler, uvY2, 0).r;

        float3 uvZ1 = saturate((CurrentPos + float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize);
        float3 uvZ2 = saturate((CurrentPos - float3(0, 0, epsilon) - SDFBoundsMin) / BoundsSize);
        grad.z = SDFTexture.SampleLevel(SDFSampler, uvZ1, 0).r
           - SDFTexture.SampleLevel(SDFSampler, uvZ2, 0).r;

        float len = length(grad);
        if (len < 0.0001)
            break;

        float3 dir = -grad / len;
        CurrentPos += dir * CurDist;
    }

// ===== 최종 위치에서 원래 위치까지의 변위 =====
// 바운드 밖 버텍스: LocalPos → ClampedLocalPos → CurrentPos
// 변위 = CurrentPos - LocalPos
    float3 DisplacementLocal = CurrentPos - LocalPos;

    float3 DisplacementComponent = mul((float3x3) ComponentToSDFLocal, DisplacementLocal);

    return Pos + DisplacementComponent * Strength;
}

// ============================================================================
// Main Compute Shader
// 메인 컴퓨트 셰이더
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    // Bounds check: Only process affected vertices
    // 범위 체크: 영향받는 버텍스만 처리
    if (ThreadIndex >= NumAffectedVertices)
    {
        return;
    }

    // Get the actual vertex index from AffectedIndices buffer
    // AffectedIndices 버퍼에서 실제 버텍스 인덱스 가져오기
    uint VertexIndex = AffectedIndices[ThreadIndex];

    // Safety check: Ensure vertex index is valid
    // 안전 체크: 버텍스 인덱스 유효성 확인
    if (VertexIndex >= NumTotalVertices)
    {
        return;
    }

    // Read bind pose position (bind pose component space)
    // 바인드 포즈 위치 읽기 (바인드 포즈 컴포넌트 스페이스)
    float3 BindPos = ReadPosition(VertexIndex);

    // ========================================
    // Step 1: Apply GPU Skinning (if enabled)
    // 1단계: GPU 스키닝 적용 (활성화된 경우)
    // ========================================
    float3 Pos;
    if (bEnableSkinning != 0)
    {
        // Apply skinning: BindPos → SkinnedPos (animated component space)
        // 스키닝 적용: 바인드 포즈 → 스킨된 포즈 (애니메이션된 컴포넌트 스페이스)
        float3x4 SkinMatrix = ComputeSkinnedMatrix(VertexIndex);
        Pos = TransformByMatrix(SkinMatrix, BindPos);
    }
    else
    {
        // No skinning: use bind pose directly
        // 스키닝 없음: 바인드 포즈 직접 사용
        Pos = BindPos;
    }

    // Step 2: Apply Tightness Deformation
    float3 NewPos;
    
    if(bUseSDFInfluence != 0)
    {
        // SDF 모드 : Gradient 기반 변형
        //float3 LocalPos = TransformToSDFLocal(BindPos);
        NewPos = ApplyTightnessDeformation_SDF(Pos, BindPos, TightnessStrength);
    }
    else
    {
        // ===== Manual 모드: 기존 로직 =====
        float Influence = Influences[ThreadIndex];
        
        // Skip if influence is negligible
        if (Influence < 0.001)
        {
            WritePosition(VertexIndex, Pos);
            return;
        }
        
        NewPos = ApplyTightnessDeformation(
            Pos,
            RingCenter,
            RingAxis,
            Influence,
            TightnessStrength
        );
    }
    
    // ========================================
    // Step 3: Write Output
    // 3단계: 출력 쓰기
    // ========================================
    WritePosition(VertexIndex, NewPos);
}
