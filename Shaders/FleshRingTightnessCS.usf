// Copyright 2026 LgThx. All Rights Reserved.

// Purpose: Pull vertices toward Ring center axis (Tightness effect)
// This shader processes only AffectedVertices (not all mesh vertices) for performance optimization.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/GpuSkinCommon.ush"
#include "FleshRingSDFSampling.ush"

/**
 * Buffer Declarations
 */
Buffer<float> SourcePositions;              // Original vertex positions (bind pose, component space)
StructuredBuffer<uint> AffectedIndices;     // Affected vertex indices (for output)
// Influence is computed directly on GPU (CalculateVirtualRingInfluence, CalculateVirtualBandInfluence)
StructuredBuffer<uint> RepresentativeIndices; // Representative vertex indices for UV seam welding (input)
RWBuffer<float> OutputPositions;            // Output: deformed vertex positions
RWBuffer<uint> VolumeAccumBuffer;           // Output: volume accumulation buffer for Bulge pass (atomic ops)
RWBuffer<float> DebugInfluences;            // Output: debug Influence values (1 float per ThreadIndex)
// DebugPointBuffer is output in DebugPointOutputCS based on final positions

// ============================================================================
// Skinning Data (from GpuSkinCommon.ush pattern)
// ============================================================================

// Bone matrices buffer (3 float4 per bone = 3x4 matrix)
Buffer<float4> BoneMatrices;

// Packed bone indices + weights (LOD-wide)
Buffer<uint> InputWeightStream;

// Skinning parameters
uint InputWeightStride;     // Stride in bytes
uint InputWeightIndexSize;  // BoneIndexByteSize | (BoneWeightByteSize << 8)
uint NumBoneInfluences;     // Number of bone influences per vertex

// Flag to enable/disable skinning (0 = bind pose, 1 = skinned)
uint bEnableSkinning;

// ============================================================================
// Ring Parameters
// ============================================================================

float3 RingCenter;          // Ring center position (component space)
float3 RingAxis;            // Ring axis direction (normalized)
float TightnessStrength;    // Tightness deformation strength

// VirtualRing mode GPU Influence calculation parameters
float RingRadius;           // Ring inner radius
float RingHeight;           // Ring height (axial direction)
float RingThickness;        // Ring thickness (radial falloff range)
uint FalloffType;           // Falloff type (0=Linear, 1=Quadratic, 2=Hermite)
uint InfluenceMode;         // Influence mode (0=Auto/SDF, 1=VirtualRing, 2=VirtualBand)

// ============================================================================
// VirtualBand Parameters - Variable radius GPU Influence calculation
// ============================================================================
float LowerRadius;          // Lower end radius
float MidLowerRadius;       // Band lower radius
float MidUpperRadius;       // Band upper radius
float UpperRadius;          // Upper end radius
float LowerHeight;          // Lower Section height
float BandSectionHeight;    // Band Section height
float UpperHeight;          // Upper Section height

// ============================================================================
// SDF Parameters
// ============================================================================

Texture3D<float> SDFTexture;
SamplerState SDFSampler;
float3 SDFBoundsMin;
float3 SDFBoundsMax;
uint bUseSDFInfluence;              // 0 = VirtualRing, 1 = SDF
float4x4 ComponentToSDFLocal;       // Component -> SDF Local (row vector multiplication)
float4x4 SDFLocalToComponent;       // SDF Local -> Component (exact inverse with scale)

// Ring Center/Axis (SDF Local Space) - Accurate position even with bounds expansion
float3 SDFLocalRingCenter;
float3 SDFLocalRingAxis;

// ============================================================================
// Counts & Volume Accumulation
// ============================================================================

uint NumAffectedVertices;
uint NumTotalVertices;
uint bAccumulateVolume;     // Enable volume accumulation for Bulge
float FixedPointScale;      // float -> uint conversion scale
uint RingIndex;             // VolumeAccumBuffer slot
uint bOutputDebugInfluences; // Enable debug Influence output
uint DebugPointBaseOffset;   // Debug buffer offset (multi-ring support, used for DebugInfluences)
// DebugPoint output is handled in DebugPointOutputCS

// Z-axis top expansion distance (absolute, cm) - for smoothing region expansion
float BoundsZTop;

// Z-axis bottom expansion distance (absolute, cm) - for smoothing region expansion
float BoundsZBottom;

// Thread Group Size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Skinning Helper Functions (from FleshRingWave.usf)
// ============================================================================

// Get bone matrix from buffer (3 float4 = 3x4 matrix)
float3x4 GetBoneMatrix(uint BoneIndex)
{
    uint BufferIndex = BoneIndex * 3;
    return float3x4(
        BoneMatrices[BufferIndex],
        BoneMatrices[BufferIndex + 1],
        BoneMatrices[BufferIndex + 2]
    );
}

// Transform position by 3x4 matrix
float3 TransformByMatrix(float3x4 Matrix, float3 Position)
{
    float4 Pos4 = float4(Position, 1.0f);
    return float3(
        dot(Matrix[0], Pos4),
        dot(Matrix[1], Pos4),
        dot(Matrix[2], Pos4)
    );
}

// Compute blended skinning matrix for a vertex
float3x4 ComputeSkinnedMatrix(uint VertexIndex)
{
    // Calculate stream offset for this vertex
    uint StreamOffset = VertexIndex * (InputWeightStride / 4);

    // Initialize indices and weights
    FGPUSkinIndexAndWeight IndicesAndWeights = (FGPUSkinIndexAndWeight)0;

    // Get first 4 bone influences
    if (NumBoneInfluences > 0)
    {
        IndicesAndWeights.BlendIndices = GetBlendIndices(InputWeightStream, StreamOffset, 0);
        IndicesAndWeights.BlendWeights = GetBlendWeights(InputWeightStream, StreamOffset, 0, NumBoneInfluences);
    }

    // Get additional 4 bone influences (if 8-bone skinning)
    if (NumBoneInfluences > 4)
    {
        IndicesAndWeights.BlendIndices2 = GetBlendIndices(InputWeightStream, StreamOffset, 1);
        IndicesAndWeights.BlendWeights2 = GetBlendWeights(InputWeightStream, StreamOffset, 1, NumBoneInfluences);
    }

    // Compute blended bone matrix
    return ComputeBoneMatrixWithLimitedInfluences(BoneMatrices, IndicesAndWeights, NumBoneInfluences > 4);
}

// ============================================================================
// Position Read/Write Helper Functions
// ============================================================================

// Read vertex position from buffer (3 floats per vertex)
float3 ReadPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        SourcePositions[BaseIndex + 0],
        SourcePositions[BaseIndex + 1],
        SourcePositions[BaseIndex + 2]
    );
}

// Write vertex position to buffer (3 floats per vertex)
void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

// ============================================================================
// VirtualRing Mode GPU Influence Calculation Functions
// ============================================================================

// Same logic as CPU CalculateFalloff()
// Falloff calculation: returns weight between 0~1 based on distance
float CalculateFalloff(float Distance, float MaxDistance, uint InFalloffType)
{
    if (MaxDistance <= 0.0)
        return 1.0;

    float NormalizedDist = saturate(Distance / MaxDistance);
    float T = 1.0 - NormalizedDist;  // Closer = higher influence

    switch (InFalloffType)
    {
    case 1:  // Quadratic
        return T * T;
    case 2:  // Hermite (Smoothstep)
        return T * T * (3.0 - 2.0 * T);
    case 0:  // Linear
    default:
        return T;
    }
}

// ============================================================================
// VirtualRing Mode GPU Influence Calculation
// Same logic as CPU FDistanceBasedVertexSelector::SelectVertices() VirtualRing branch
// ============================================================================
//
// [Influence Calculation Flow]
//
//  1. Vertex position -> decompose relative to ring center
//     - AxisDist: axial distance (how far above/below the ring)
//     - RadialDist: radial distance (how far from ring axis)
//
//  2. Range check (Zone)
//     - RadialDist > MaxDistance or AxisDist > HalfWidth -> outside influence
//
//  3. Falloff calculation
//     - RadialInfluence: decreases with distance from ring surface (RingRadius)
//     - AxialInfluence: decreases with distance from ring center height
//
//  4. Final Influence = RadialInfluence * AxialInfluence
//
// [Known Issue]
//  - Skin/Stocking have different Influence based on ring inner surface (RingRadius) position
//  - If ring is at Stocking position -> Stocking is closer to inner surface -> higher Influence
//  - -> Stocking moves more -> layer inversion!
//
// ============================================================================
float CalculateVirtualRingInfluence(float3 VertexPos)
{
    // Step 1: Decompose vertex position in ring coordinate system
    float3 ToVertex = VertexPos - RingCenter;

    // Axial component (up/down direction relative to ring)
    float AxisDist = dot(ToVertex, RingAxis);

    // Radial vector (perpendicular to axis, outward direction)
    float3 RadialVec = ToVertex - RingAxis * AxisDist;
    float RadialDist = length(RadialVec);

    // Step 2: Influence zone check
    float MaxDistance = RingRadius + RingThickness;     // Horizontal range
    float HalfHeight = RingHeight * 0.5;                // Vertical range

    // Outside horizontal or vertical range -> influence = 0
    // TODO: No check for RadialDist < RingRadius (inside ring hole). Low priority
    if (RadialDist > MaxDistance || abs(AxisDist) > HalfHeight)
        return 0.0;

    // Step 3: Falloff calculation
    // Distance from ring inner surface (RingRadius = inner radius)
    // -> 0 if on inner surface, increases with distance
    // TODO: Due to abs(), vertices inside hole also get high Influence if close to inner surface. May need fix
    float DistFromSurface = abs(RadialDist - RingRadius);

    // RadialInfluence: 1.0 at inner surface, 0.0 at RingThickness distance
    float RadialInfluence = CalculateFalloff(DistFromSurface, RingThickness, FalloffType);

    // AxialInfluence: 1.0 at ring center height, 0.0 at HalfHeight distance
    float AxialInfluence = CalculateFalloff(abs(AxisDist), HalfHeight, FalloffType);

    // ========================================
    // Step 4: Final Influence (multiplicative)
    // ========================================
    return RadialInfluence * AxialInfluence;
}

// ============================================================================
// VirtualBand Mode GPU Influence Calculation Functions
// ============================================================================

// Same logic as CPU FVirtualBandSettings::GetRadiusAtHeight()
// Calculate radius at height using Catmull-Rom spline
// New coordinate system: Z=0 is Mid Band center
float GetRadiusAtHeight_VirtualBand(float LocalZ)
{
    float TotalHeight = LowerHeight + BandSectionHeight + UpperHeight;
    if (TotalHeight <= 0.0001)
        return MidLowerRadius;

    // New coordinate system -> internal coordinate system conversion
    // Internal: Z=0 is Lower bottom, Z=TotalHeight is Upper top
    float MidOffset = LowerHeight + BandSectionHeight * 0.5;
    float InternalZ = LocalZ + MidOffset;

    // 4 control points (height, radius) - internal coordinate system
    float H[4];
    H[0] = 0.0;
    H[1] = LowerHeight;
    H[2] = LowerHeight + BandSectionHeight;
    H[3] = TotalHeight;

    float R[4];
    R[0] = LowerRadius;
    R[1] = MidLowerRadius;
    R[2] = MidUpperRadius;
    R[3] = UpperRadius;

    // Clamp InternalZ (internal coordinate system range)
    float Z = clamp(InternalZ, 0.0, TotalHeight);

    // Find which segment (0: H0~H1, 1: H1~H2, 2: H2~H3)
    int Segment = 0;
    if (Z >= H[2]) Segment = 2;
    else if (Z >= H[1]) Segment = 1;

    // Calculate normalized t within segment
    float SegmentLength = H[Segment + 1] - H[Segment];
    float t = (SegmentLength > 0.0001) ? (Z - H[Segment]) / SegmentLength : 0.0;

    // 4 radii needed for Catmull-Rom (P0, P1, P2, P3)
    // Interpolate P1~P2 segment, P0 and P3 are neighbor control points (endpoints duplicated)
    float P0, P1, P2, P3;
    if (Segment == 0)      { P0 = R[0]; P1 = R[0]; P2 = R[1]; P3 = R[2]; }
    else if (Segment == 1) { P0 = R[0]; P1 = R[1]; P2 = R[2]; P3 = R[3]; }
    else                   { P0 = R[1]; P1 = R[2]; P2 = R[3]; P3 = R[3]; }

    // Catmull-Rom spline calculation
    float t2 = t * t;
    float t3 = t2 * t;
    float Result = 0.5 * (
        (2.0 * P1) +
        (-P0 + P2) * t +
        (2.0 * P0 - 5.0 * P1 + 4.0 * P2 - P3) * t2 +
        (-P0 + 3.0 * P1 - 3.0 * P2 + P3) * t3
    );

    // Clamp to prevent overshoot
    float MinR = min(min(R[0], R[1]), min(R[2], R[3]));
    float MaxR = max(max(R[0], R[1]), max(R[2], R[3]));
    return clamp(Result, MinR, MaxR);
}

// VirtualBand mode GPU Influence calculation
// Similar logic to CPU FVirtualBandVertexSelector (Tightness region calculation)
// New coordinate system: Z=0 is Mid Band center
float CalculateVirtualBandInfluence(float3 VertexPos)
{
    float3 ToVertex = VertexPos - RingCenter;
    float AxisDist = dot(ToVertex, RingAxis);
    float3 RadialVec = ToVertex - RingAxis * AxisDist;
    float RadialDist = length(RadialVec);

    float TotalHeight = LowerHeight + BandSectionHeight + UpperHeight;

    // Band Section range (Tightness application region)
    // New coordinate system: Z=0 is Mid Band center, so BandSection is -BandHeight/2 ~ +BandHeight/2
    float BandZMin = -BandSectionHeight * 0.5;
    float BandZMax = BandSectionHeight * 0.5;

    // Outside Band Section = no Tightness
    if (AxisDist < BandZMin || AxisDist > BandZMax)
        return 0.0;

    // Band radius at this height (Catmull-Rom)
    float BandRadius = GetRadiusAtHeight_VirtualBand(AxisDist);

    // Inside band surface = no influence
    if (RadialDist <= BandRadius)
        return 0.0;

    // Distance from band surface
    float DistFromSurface = RadialDist - BandRadius;

    // TightnessFalloffRange: derived from radius difference (similar to Bulge region)
    float UpperBulge = UpperRadius - MidUpperRadius;
    float LowerBulge = LowerRadius - MidLowerRadius;
    float FalloffRange = max(max(UpperBulge, LowerBulge), 1.0);

    if (DistFromSurface > FalloffRange)
        return 0.0;

    // Radial Falloff
    float RadialInfluence = CalculateFalloff(DistFromSurface, FalloffRange, FalloffType);

    // Axial Falloff (attenuate near band boundary)
    float AxialFalloffRange = BandSectionHeight * 0.2;
    float AxialInfluence = 1.0;
    if (AxisDist < BandZMin + AxialFalloffRange)
    {
        float Dist = BandZMin + AxialFalloffRange - AxisDist;
        AxialInfluence = CalculateFalloff(Dist, AxialFalloffRange, FalloffType);
    }
    else if (AxisDist > BandZMax - AxialFalloffRange)
    {
        float Dist = AxisDist - (BandZMax - AxialFalloffRange);
        AxialInfluence = CalculateFalloff(Dist, AxialFalloffRange, FalloffType);
    }

    return RadialInfluence * AxialInfluence;
}

// ============================================================================
// Tightness Deformation Functions
// ============================================================================

// VirtualRing mode: simple radial inward displacement
float3 ApplyTightnessDeformation(float3 Pos, float3 Center, float3 Axis, float Influence, float Strength)
{
    float3 ToVertex = Pos - Center;
    float AxisDist = dot(ToVertex, Axis);
    float3 RadialVec = ToVertex - Axis * AxisDist;
    float RadialDist = length(RadialVec);

    if (RadialDist < 0.001)
        return Pos;

    float3 InwardDir = -RadialVec / RadialDist;
    return Pos + InwardDir * Strength * Influence;
}

// ============================================================================
// Ray-AABB Intersection (Slab Method)
// ============================================================================
// Check if ray intersects AABB and return entry point
// Reference: "An Efficient and Robust Ray-Box Intersection Algorithm" (Williams et al.)
//
// RayOrigin: ray start point
// RayDir: ray direction (must be normalized)
// BoundsMin/Max: AABB bounds
// OutEntryPoint: [out] entry point if intersection occurs
// Returns: whether intersection occurred
bool RayAABBIntersection(float3 RayOrigin, float3 RayDir, float3 BoundsMin, float3 BoundsMax, out float3 OutEntryPoint)
{
    OutEntryPoint = RayOrigin;

    // Prevent division by zero (use vector select)
    float3 SafeDir = select(abs(RayDir) > 0.0001, RayDir, sign(RayDir) * 0.0001 + 0.0001);
    float3 InvDir = 1.0 / SafeDir;

    // Calculate entry/exit t values for each axis
    float3 t1 = (BoundsMin - RayOrigin) * InvDir;
    float3 t2 = (BoundsMax - RayOrigin) * InvDir;

    // Sort min/max for each axis
    float3 tMin = min(t1, t2);
    float3 tMax = max(t1, t2);

    // Overall entry/exit t values
    float tEnter = max(max(tMin.x, tMin.y), tMin.z);
    float tExit = min(min(tMax.x, tMax.y), tMax.z);

    // Intersection condition: tEnter < tExit && tExit > 0
    // If tEnter < 0, ray origin is already inside the box
    if (tEnter > tExit || tExit < 0.0)
        return false;

    // Calculate entry point (if tEnter is negative, already inside -> return origin)
    float t = max(tEnter, 0.0);
    OutEntryPoint = RayOrigin + RayDir * t;

    return true;
}

// Check if vertex is inside SDF bounds
bool IsInsideBounds(float3 LocalPos, float3 BoundsMin, float3 BoundsMax)
{
    return all(LocalPos >= BoundsMin) && all(LocalPos <= BoundsMax);
}

// SDF mode: Two-Phase radial raymarching
// Phase 1: Vertex outside bounds -> find entry point via Ray-Box intersection
// Phase 2: Raymarch from entry point to SDF surface
float3 ApplyTightnessDeformation_SDF(float3 Pos, float3 BindPos, float Strength)
{
    // STEP 1: Component -> SDF Local coordinate transform
    float3 LocalPos = mul(float4(BindPos, 1.0), ComponentToSDFLocal).xyz;
    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;

    // Ring Center/Axis passed from CPU (SDF Local Space)
    float3 LocalRingCenter = SDFLocalRingCenter;
    float3 LocalRingAxis = SDFLocalRingAxis;

    // STEP 2: Calculate radial direction (inward)
    float3 fromCenter = LocalPos - LocalRingCenter;
    float axialDist = dot(fromCenter, LocalRingAxis);
    float3 outwardRadial = fromCenter - LocalRingAxis * axialDist;
    float radialLen = length(outwardRadial);

    if (radialLen < 0.0001)
        return Pos;

    float3 inwardDir = -outwardRadial / radialLen;  // Inward direction

    // STEP 2.5: Z range check (filter before entry point search)
    // Vertices outside Z range won't hit AABB with XY radial ray, so early exit
    // Check exactly against AABB Z range (no margin, Ray-AABB would fail anyway)
    float originalZ_UV = (LocalPos.z - SDFBoundsMin.z) / BoundsSize.z;
    if (originalZ_UV < 0.0 || originalZ_UV > 1.0)
        return Pos;

    // STEP 3: Determine raymarch start point (Two-Phase)
    float3 RaymarchStart;
    bool bOutsideBounds = !IsInsideBounds(LocalPos, SDFBoundsMin, SDFBoundsMax);

    if (bOutsideBounds)
    {
        // Phase 1: Outside bounds -> find entry point via Ray-Box Intersection
        // Since Z range check passed, XY radial ray must intersect AABB
        float3 EntryPoint;
        bool bHit = RayAABBIntersection(LocalPos, inwardDir, SDFBoundsMin, SDFBoundsMax, EntryPoint);

        if (!bHit)
        {
            // Z range passed but still failed -> theoretically impossible, safety fallback
            return Pos;
        }
        RaymarchStart = EntryPoint;
    }
    else
    {
        // Inside bounds -> start from current position
        RaymarchStart = LocalPos;
    }

    // STEP 4: Check SDF at start point (skip if already inside)
    // Use <: proceed with raymarching even when SDF == 0 (exactly on surface)
    // Handles tangent regions (where bounds edge meets ring surface)
    float3 StartUV = (RaymarchStart - SDFBoundsMin) / BoundsSize;
    float StartDist = SDFTexture.SampleLevel(SDFSampler, saturate(StartUV), 0).r;
    if (StartDist < 0.0)
    {
        // Already inside SDF -> no deformation needed (or entry point is already surface)
        if (bOutsideBounds)
        {
            // Was outside bounds but entry point already inside = move only to entry point
            float3 DisplacementLocal = RaymarchStart - LocalPos;

            // SDF Local -> Component Space transform (using SDFLocalToComponent)
            float3 DisplacementComponent = mul(DisplacementLocal, (float3x3)SDFLocalToComponent);

            return Pos + DisplacementComponent * Strength;
        }
        return Pos;
    }

    // STEP 5: Phase 2 - SDF raymarching (from entry point to surface)
    // (Z range check moved to STEP 2.5)
    float3 CurrentPos = RaymarchStart;
    float epsilon = max(BoundsSize.x, max(BoundsSize.y, BoundsSize.z)) / 64.0;
    float3 lastDir = inwardDir;

    // ========================================================================
    // Coarse Phase: Existing raymarching to quickly approach boundary
    // ========================================================================
    bool bEnteredBounds = false;  // Track bounds entry
    float3 LastPositivePos = RaymarchStart;  // Last positive (SDF >= 0) position
    float LastPositiveSDF = StartDist;       // Last positive SDF value
    bool bFoundBoundary = false;             // Whether boundary (negative) was found

    for (int i = 0; i < 47; i++)
    {
        float3 CurUV = (CurrentPos - SDFBoundsMin) / BoundsSize;
        bool bInsideBounds = all(CurUV >= 0.0) && all(CurUV <= 1.0);

        if (bInsideBounds)
            bEnteredBounds = true;
        else if (bEnteredBounds)
            break;  // Was inside then went outside = penetrated through, stop

        // Recalculate radial direction (based on current position)
        float3 curFromCenter = CurrentPos - LocalRingCenter;
        float curAxialDist = dot(curFromCenter, LocalRingAxis);
        float3 curOutwardRadial = curFromCenter - LocalRingAxis * curAxialDist;
        float curRadialLen = length(curOutwardRadial);

        if (curRadialLen < 0.0001)
            break;

        float3 dir = -curOutwardRadial / curRadialLen;
        lastDir = dir;

        // If outside bounds, skip SDF sampling and just advance direction
        if (!bInsideBounds)
        {
            CurrentPos += dir * epsilon * 2.0;  // Fixed step toward bounds
            continue;
        }

        float CurDist = SDFTexture.SampleLevel(SDFSampler, CurUV, 0).r;

        // Ring hole (negative region) detected -> boundary found
        if (CurDist < 0.0)
        {
            bFoundBoundary = true;
            break;
        }

        // Backup positive position (position just before boundary crossing)
        LastPositivePos = CurrentPos;
        LastPositiveSDF = CurDist;

        // SDF distance-based step + ensure minimum step
        float stepScale = (CurDist < 1.0) ? 1.0 : 1.3;
        float stepSize = max(CurDist * stepScale, epsilon * 0.5);
        CurrentPos += dir * stepSize;
    }

    // ========================================================================
    // Refinement Phase: Binary Search for precise boundary convergence
    // ========================================================================
    if (bFoundBoundary)
    {
        // Binary search interval: [LastPositivePos, CurrentPos]
        // LastPositivePos: SDF >= 0 (outside/surface)
        // CurrentPos: SDF < 0 (inside)
        float3 PosA = LastPositivePos;  // Positive endpoint
        float3 PosB = CurrentPos;       // Negative endpoint

        // 4 iterations of binary search: reduces error to 1/16
        [unroll]
        for (int refineIter = 0; refineIter < 4; refineIter++)
        {
            // Calculate midpoint
            float3 MidPos = (PosA + PosB) * 0.5;
            float3 MidUV = saturate((MidPos - SDFBoundsMin) / BoundsSize);
            float MidSDF = SDFTexture.SampleLevel(SDFSampler, MidUV, 0).r;

            // Narrow interval by half based on midpoint SDF sign
            if (MidSDF >= 0.0)
            {
                // Midpoint is positive -> boundary is in [MidPos, PosB] interval
                PosA = MidPos;
            }
            else
            {
                // Midpoint is negative -> boundary is in [PosA, MidPos] interval
                PosB = MidPos;
            }
        }

        // ====================================================================
        // Final Interpolation: Linear interpolation to find exact SDF=0 point
        // ====================================================================
        // Use SDF values at both endpoints of final interval [PosA, PosB] for linear interpolation
        float3 FinalUV_A = saturate((PosA - SDFBoundsMin) / BoundsSize);
        float3 FinalUV_B = saturate((PosB - SDFBoundsMin) / BoundsSize);
        float FinalSDF_A = SDFTexture.SampleLevel(SDFSampler, FinalUV_A, 0).r;
        float FinalSDF_B = SDFTexture.SampleLevel(SDFSampler, FinalUV_B, 0).r;

        // Linear interpolation factor: calculate t where SDF = 0
        // SDF(t) = SDF_A * (1-t) + SDF_B * t = 0
        // t = SDF_A / (SDF_A - SDF_B)
        float denom = FinalSDF_A - FinalSDF_B;
        if (abs(denom) > 0.0001)
        {
            float t = saturate(FinalSDF_A / denom);
            CurrentPos = lerp(PosA, PosB, t);
        }
        else
        {
            // Interval is nearly flat (SDF gradient ~ 0) -> use midpoint
            CurrentPos = (PosA + PosB) * 0.5;
        }
    }
    // If bFoundBoundary == false:
    // Raymarching terminated without finding boundary (CurrentPos is last valid position)

    // STEP 7: Post-validation
    if (length(lastDir) <= 0.0001)
        return Pos;

    // Probe check: verify if beyond surface is a hole
    // - Distinguish between hole entrance vs ring side surface
    // - If SDF < 0.6 at probePos, it's a hole; otherwise external
    float3 probePos = CurrentPos + lastDir * epsilon * 8.0;
    float3 probeUV = saturate((probePos - SDFBoundsMin) / BoundsSize);
    float probeSDF = SDFTexture.SampleLevel(SDFSampler, probeUV, 0).r;
    if (probeSDF > 0.6)
        return Pos;

    // STEP 8: Calculate and apply displacement
    float3 DisplacementLocal = CurrentPos - LocalPos;

    // Safety validation: verify displacement direction is inward
    float dispLen = length(DisplacementLocal);
    if (dispLen > 0.001)
    {
        float3 dispDir = DisplacementLocal / dispLen;
        float alignment = dot(dispDir, inwardDir);  // Compare with initial inward direction

        // If displacement is outward, something is wrong -> abandon deformation
        if (alignment < 0.0)
            return Pos;

        // Limit movement distance: allow up to 90% of initial radialLen (prevent passing through ring center)
        float maxDispLen = radialLen * 0.9;
        if (dispLen > maxDispLen)
        {
            DisplacementLocal = dispDir * maxDispLen;
        }
    }

    // Limit Z-axis displacement (prevent vertices above/below ring from entering hole)
    if (abs(DisplacementLocal.z) > BoundsSize.z * 0.5)
        return Pos;

    // SDF Local -> Component Space transform (using SDFLocalToComponent)
    float3 DisplacementComponent = mul(DisplacementLocal, (float3x3)SDFLocalToComponent);

    return Pos + DisplacementComponent * Strength;
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    // Bounds check: Only process affected vertices
    if (ThreadIndex >= NumAffectedVertices)
    {
        return;
    }

    // ================================================================
    // UV Seam Welding: Separate read/write based on representative vertex
    // ================================================================
    // - WriteIndex: actual vertex index (used for output)
    // - ReadIndex: representative vertex index (used for input)
    // UV duplicate vertices at same position share the same representative,
    // so they all read from the same position and compute identical deformation
    // ================================================================

    // Get the actual vertex index for writing output
    uint WriteIndex = AffectedIndices[ThreadIndex];

    // Get the representative vertex index for reading input
    uint ReadIndex = RepresentativeIndices[ThreadIndex];

    // Safety check: Ensure vertex indices are valid
    if (WriteIndex >= NumTotalVertices || ReadIndex >= NumTotalVertices)
    {
        return;
    }

    // Read bind pose position from REPRESENTATIVE vertex
    // UV duplicate vertices share same representative, so they read identical position
    float3 BindPos = ReadPosition(ReadIndex);

    // ========================================
    // Step 1: Apply GPU Skinning (if enabled)
    // ========================================
    float3 Pos;
    if (bEnableSkinning != 0)
    {
        // Apply skinning: BindPos -> SkinnedPos (animated component space)
        // NOTE: Skinning uses representative vertex index (ReadIndex)
        //       so UV duplicate vertices receive identical skinning result
        float3x4 SkinMatrix = ComputeSkinnedMatrix(ReadIndex);
        Pos = TransformByMatrix(SkinMatrix, BindPos);
    }
    else
    {
        // No skinning: use bind pose directly
        Pos = BindPos;
    }

    // Step 2: Apply Tightness Deformation
    float3 NewPos;
    float Influence = 0.0;  // Influence value (for debug output)

    if(bUseSDFInfluence != 0)
    {
        // SDF mode: Gradient-based deformation (Auto or VirtualBand + SDF valid)
        //float3 LocalPos = TransformToSDFLocal(BindPos);
        NewPos = ApplyTightnessDeformation_SDF(Pos, BindPos, TightnessStrength);

        // In SDF mode, estimate Influence from displacement magnitude (for debug)
        // Influence ~ displacement / TightnessStrength (clamped to 0~1 range)
        float displacement = length(NewPos - Pos);
        Influence = (TightnessStrength > 0.001) ? saturate(displacement / TightnessStrength) : 0.0;
    }
    else if (InfluenceMode == 2)
    {
        // ===== VirtualBand mode: GPU calculates Influence based on variable radius =====
        // VirtualBand mode without SDF (distance-based Catmull-Rom spline)
        Influence = CalculateVirtualBandInfluence(BindPos);
    }
    else
    {
        // ===== VirtualRing mode: GPU calculates Influence based on fixed radius =====
        // Calculate Influence directly on GPU based on BindPos (no CPU Influences buffer)
        Influence = CalculateVirtualRingInfluence(BindPos);
    }

    // ===== Common processing for non-SDF modes (VirtualRing/VirtualBand) =====
    if (bUseSDFInfluence == 0)
    {

        // Skip if influence is negligible
        if (Influence < 0.001)
        {
            // Debug output: record 0 even for unaffected vertices
            if (bOutputDebugInfluences != 0)
            {
                DebugInfluences[DebugPointBaseOffset + ThreadIndex] = 0.0;
            }
            // DebugPointBuffer is handled in DebugPointOutputCS
            WritePosition(WriteIndex, Pos);
            return;
        }

        // Torus blending test: using _TorusBlend version instead of original function
        // To revert after testing, change to ApplyTightnessDeformation
        NewPos = ApplyTightnessDeformation(
            Pos,
            RingCenter,
            RingAxis,
            Influence,
            TightnessStrength
        );
    }

    // ========================================
    // Debug Output: Record Influence value
    // ========================================
    if (bOutputDebugInfluences != 0)
    {
        DebugInfluences[DebugPointBaseOffset + ThreadIndex] = Influence;
    }

    // ========================================
    // Step 3: Volume Accumulation (for Bulge pass)
    // ========================================
    // Accumulate compression from Tightness using atomics per Ring
    // Each Ring's compression amount stored in VolumeAccumBuffer[RingIndex]
    // BulgeCS reads its own Ring slot to apply Bulge
    if (bAccumulateVolume != 0)
    {
        // Compression amount = movement distance
        float compressionAmount = length(NewPos - Pos);

        // Only accumulate if there's compression (performance optimization)
        if (compressionAmount > 0.0001)
        {
            // Float -> Fixed-point (e.g., 0.5 * 1000 = 500)
            uint compressedFixed = uint(compressionAmount * FixedPointScale);

            // Atomic operation to accumulate in per-Ring slot
            InterlockedAdd(VolumeAccumBuffer[RingIndex], compressedFixed);
        }
    }

    // ========================================
    // Step 4: Write Output to ACTUAL vertex index
    // ========================================
    // UV seam welding: write result computed from representative to own index
    // All UV duplicate vertices write identical result to their respective positions
    WritePosition(WriteIndex, NewPos);
}
