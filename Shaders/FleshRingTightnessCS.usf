// Purpose: Pull vertices toward Ring center axis (Tightness effect)
// 목적: 버텍스를 링 중심축 방향으로 안쪽으로 당김 (조이기 효과)
// This shader processes only AffectedVertices (not all mesh vertices) for performance optimization.
// 성능 최적화를 위해 영향받는 버텍스만 처리 (전체 메시 버텍스 X)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/GpuSkinCommon.ush"
#include "FleshRingSDFSampling.ush"

/**
 * Buffer Declarations
 */
Buffer<float> SourcePositions;              // 메시의 원본 정점 위치(바인드 포즈 컴포넌트 스페이스)
StructuredBuffer<uint> AffectedIndices;     // 영향받는 정점 인덱스 (출력용)
StructuredBuffer<float> Influences;         // 정점별 영향도 (0~1, 감쇠 계산에서 산출)
StructuredBuffer<uint> RepresentativeIndices; // UV seam 용접용 대표 정점 인덱스 (입력용)
RWBuffer<float> OutputPositions;            // 출력: 변형된 정점 위치
RWBuffer<uint> VolumeAccumBuffer;           // 출력: Bulge 패스용 부피 누적 버퍼 (Atomic 연산)

// ============================================================================
// Skinning Data (from GpuSkinCommon.ush pattern)
// 스키닝 데이터 (GpuSkinCommon.ush 패턴)
// ============================================================================

// Bone matrices buffer (3 float4 per bone = 3x4 matrix)
// 본 행렬 버퍼 (본당 3개의 float4 = 3x4 행렬)
Buffer<float4> BoneMatrices;

// Packed bone indices + weights (LOD-wide)
// 패킹된 본 인덱스 + 웨이트 (LOD 전체)
Buffer<uint> InputWeightStream;

// Skinning parameters
// 스키닝 파라미터
uint InputWeightStride;     // Stride in bytes / 바이트 단위 스트라이드
uint InputWeightIndexSize;  // BoneIndexByteSize | (BoneWeightByteSize << 8)
uint NumBoneInfluences;     // Number of bone influences per vertex / 버텍스당 본 영향 수

// Flag to enable/disable skinning (0 = bind pose, 1 = skinned)
// 스키닝 활성화 플래그 (0 = 바인드 포즈, 1 = 스키닝 적용)
uint bEnableSkinning;

// ============================================================================
// Ring Parameters
// 링 파라미터
// ============================================================================

float3 RingCenter;          // Ring center position (component space)
                            // 링 중심 위치 (컴포넌트 스페이스)
float3 RingAxis;            // Ring axis direction (normalized)
                            // 링 축 방향 (정규화됨)
float TightnessStrength;    // 조이기 변형 강도

// ============================================================================
// SDF Parameters
// ============================================================================

Texture3D<float> SDFTexture;
SamplerState SDFSampler;
float3 SDFBoundsMin;
float3 SDFBoundsMax;
uint bUseSDFInfluence;              // 0 = Manual, 1 = SDF
float4x4 ComponentToSDFLocal;       // Component → SDF Local (row vector 곱셈 사용)
float4x4 SDFLocalToComponent;       // SDF Local → Component (스케일 포함 정확한 역변환)

// Ring Center/Axis (SDF Local Space) - 바운드 확장 시에도 정확한 위치 전달
float3 SDFLocalRingCenter;
float3 SDFLocalRingAxis;

// ============================================================================
// Counts & Volume Accumulation
// ============================================================================

uint NumAffectedVertices;
uint NumTotalVertices;
uint bAccumulateVolume;     // Bulge용 부피 누적 활성화
float FixedPointScale;      // float → uint 변환 스케일
uint RingIndex;             // VolumeAccumBuffer 슬롯

// Z축 상단 확장 거리 (절대값, cm) - 스무딩 영역 확장용
float BoundsZTop;

// Z축 하단 확장 거리 (절대값, cm) - 스무딩 영역 확장용
float BoundsZBottom;

// Thread Group Size
#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 64
#endif

// ============================================================================
// Skinning Helper Functions (from FleshRingWave.usf)
// 스키닝 헬퍼 함수 (FleshRingWave.usf에서 가져옴)
// ============================================================================

// Get bone matrix from buffer (3 float4 = 3x4 matrix)
// 버퍼에서 본 행렬 가져오기 (3 float4 = 3x4 행렬)
float3x4 GetBoneMatrix(uint BoneIndex)
{
    uint BufferIndex = BoneIndex * 3;
    return float3x4(
        BoneMatrices[BufferIndex],
        BoneMatrices[BufferIndex + 1],
        BoneMatrices[BufferIndex + 2]
    );
}

// Transform position by 3x4 matrix
// 3x4 행렬로 위치 변환
float3 TransformByMatrix(float3x4 Matrix, float3 Position)
{
    float4 Pos4 = float4(Position, 1.0f);
    return float3(
        dot(Matrix[0], Pos4),
        dot(Matrix[1], Pos4),
        dot(Matrix[2], Pos4)
    );
}

// Compute blended skinning matrix for a vertex
// 버텍스의 블렌딩된 스키닝 행렬 계산
float3x4 ComputeSkinnedMatrix(uint VertexIndex)
{
    // Calculate stream offset for this vertex
    // 이 버텍스의 스트림 오프셋 계산
    uint StreamOffset = VertexIndex * (InputWeightStride / 4);

    // Initialize indices and weights
    // 인덱스와 웨이트 초기화
    FGPUSkinIndexAndWeight IndicesAndWeights = (FGPUSkinIndexAndWeight)0;

    // Get first 4 bone influences
    // 첫 4개 본 영향 가져오기
    if (NumBoneInfluences > 0)
    {
        IndicesAndWeights.BlendIndices = GetBlendIndices(InputWeightStream, StreamOffset, 0);
        IndicesAndWeights.BlendWeights = GetBlendWeights(InputWeightStream, StreamOffset, 0, NumBoneInfluences);
    }

    // Get additional 4 bone influences (if 8-bone skinning)
    // 추가 4개 본 영향 가져오기 (8본 스키닝인 경우)
    if (NumBoneInfluences > 4)
    {
        IndicesAndWeights.BlendIndices2 = GetBlendIndices(InputWeightStream, StreamOffset, 1);
        IndicesAndWeights.BlendWeights2 = GetBlendWeights(InputWeightStream, StreamOffset, 1, NumBoneInfluences);
    }

    // Compute blended bone matrix
    // 블렌딩된 본 행렬 계산
    return ComputeBoneMatrixWithLimitedInfluences(BoneMatrices, IndicesAndWeights, NumBoneInfluences > 4);
}

// ============================================================================
// Position Read/Write Helper Functions
// 위치 읽기/쓰기 헬퍼 함수
// ============================================================================

// Read vertex position from buffer (3 floats per vertex)
// 버퍼에서 버텍스 위치 읽기 (버텍스당 3 float)
float3 ReadPosition(uint VertexIndex)
{
    uint BaseIndex = VertexIndex * 3;
    return float3(
        SourcePositions[BaseIndex + 0],
        SourcePositions[BaseIndex + 1],
        SourcePositions[BaseIndex + 2]
    );
}

// Write vertex position to buffer (3 floats per vertex)
// 버퍼에 버텍스 위치 쓰기 (버텍스당 3 float)
void WritePosition(uint VertexIndex, float3 Pos)
{
    uint BaseIndex = VertexIndex * 3;
    OutputPositions[BaseIndex + 0] = Pos.x;
    OutputPositions[BaseIndex + 1] = Pos.y;
    OutputPositions[BaseIndex + 2] = Pos.z;
}

// ============================================================================
// Tightness Deformation Functions
// ============================================================================

// Manual 모드: 단순 반경 방향 내부 변위
float3 ApplyTightnessDeformation(float3 Pos, float3 Center, float3 Axis, float Influence, float Strength)
{
    float3 ToVertex = Pos - Center;
    float AxisDist = dot(ToVertex, Axis);
    float3 RadialVec = ToVertex - Axis * AxisDist;
    float RadialDist = length(RadialVec);

    if (RadialDist < 0.001)
        return Pos;

    float3 InwardDir = -RadialVec / RadialDist;
    return Pos + InwardDir * Strength * Influence;
}

// ============================================================================
// Ray-AABB Intersection (Slab Method)
// ============================================================================
// Ray가 AABB와 교차하는지 확인하고, 교차점(진입점)을 반환
// Reference: "An Efficient and Robust Ray–Box Intersection Algorithm" (Williams et al.)
//
// RayOrigin: 레이 시작점
// RayDir: 레이 방향 (정규화 필수)
// BoundsMin/Max: AABB 바운드
// OutEntryPoint: [out] 교차 시 진입점
// 반환값: 교차 여부
bool RayAABBIntersection(float3 RayOrigin, float3 RayDir, float3 BoundsMin, float3 BoundsMax, out float3 OutEntryPoint)
{
    OutEntryPoint = RayOrigin;

    // 0으로 나누기 방지 (벡터용 select 사용)
    float3 SafeDir = select(abs(RayDir) > 0.0001, RayDir, sign(RayDir) * 0.0001 + 0.0001);
    float3 InvDir = 1.0 / SafeDir;

    // 각 축별 진입/탈출 t값 계산
    float3 t1 = (BoundsMin - RayOrigin) * InvDir;
    float3 t2 = (BoundsMax - RayOrigin) * InvDir;

    // 각 축별 min/max 정렬
    float3 tMin = min(t1, t2);
    float3 tMax = max(t1, t2);

    // 전체 진입/탈출 t값
    float tEnter = max(max(tMin.x, tMin.y), tMin.z);
    float tExit = min(min(tMax.x, tMax.y), tMax.z);

    // 교차 조건: tEnter < tExit && tExit > 0
    // tEnter < 0이면 레이 시작점이 이미 박스 안에 있음
    if (tEnter > tExit || tExit < 0.0)
        return false;

    // 진입점 계산 (tEnter가 음수면 이미 내부 → 시작점 반환)
    float t = max(tEnter, 0.0);
    OutEntryPoint = RayOrigin + RayDir * t;

    return true;
}

// 버텍스가 SDF 바운드 내부에 있는지 체크
bool IsInsideBounds(float3 LocalPos, float3 BoundsMin, float3 BoundsMax)
{
    return all(LocalPos >= BoundsMin) && all(LocalPos <= BoundsMax);
}

// SDF 모드: Two-Phase 방사형 레이마칭
// Phase 1: 바운드 외부 버텍스 → Ray-Box로 진입점 찾기
// Phase 2: 진입점에서 SDF 표면까지 레이마칭
float3 ApplyTightnessDeformation_SDF(float3 Pos, float3 BindPos, float Strength)
{
    // STEP 1: Component → SDF Local 좌표 변환
    float3 LocalPos = mul(float4(BindPos, 1.0), ComponentToSDFLocal).xyz;
    float3 BoundsSize = SDFBoundsMax - SDFBoundsMin;

    // CPU에서 전달받은 Ring Center/Axis (SDF Local Space)
    float3 LocalRingCenter = SDFLocalRingCenter;
    float3 LocalRingAxis = SDFLocalRingAxis;

    // STEP 2: 방사형 방향 계산 (안쪽으로)
    float3 fromCenter = LocalPos - LocalRingCenter;
    float axialDist = dot(fromCenter, LocalRingAxis);
    float3 outwardRadial = fromCenter - LocalRingAxis * axialDist;
    float radialLen = length(outwardRadial);

    if (radialLen < 0.0001)
        return Pos;

    float3 inwardDir = -outwardRadial / radialLen;  // 안쪽 방향

    // STEP 3: 레이마칭 시작점 결정 (Two-Phase)
    float3 RaymarchStart;
    bool bOutsideBounds = !IsInsideBounds(LocalPos, SDFBoundsMin, SDFBoundsMax);

    if (bOutsideBounds)
    {
        // Phase 1: 바운드 외부 → Ray-Box Intersection으로 진입점 찾기
        float3 EntryPoint;
        bool bHit = RayAABBIntersection(LocalPos, inwardDir, SDFBoundsMin, SDFBoundsMax, EntryPoint);

        if (!bHit)
        {
            // Fallback: 방사형 방향이 빗나가면 바운드 중심 방향으로 재시도
            // 회전된 Ring의 경우, 정점이 Z 범위 밖에 있으면 순수 방사형(XY) 방향이 AABB를 못 맞춤
            // 바운드 중심 방향은 Z 성분을 포함하므로 항상 AABB와 교차
            float3 boundsCenter = (SDFBoundsMin + SDFBoundsMax) * 0.5;
            float3 fallbackDir = normalize(boundsCenter - LocalPos);
            bHit = RayAABBIntersection(LocalPos, fallbackDir, SDFBoundsMin, SDFBoundsMax, EntryPoint);

            if (!bHit)
            {
                // 그래도 실패 → 변형 포기
                return Pos;
            }
            // Fallback 성공 시 inwardDir 업데이트 (레이마칭에서 사용)
            inwardDir = fallbackDir;
        }
        // EntryPoint 찾았으면 레이마칭 시작점으로 삼기
        RaymarchStart = EntryPoint;
    }
    else
    {
        // 바운드 내부 → 현재 위치에서 시작
        RaymarchStart = LocalPos;
    }

    // STEP 4: 시작점의 SDF 체크 (이미 내부면 패스)
    // < 사용: SDF == 0 (표면 정확히)일 때도 레이마칭 진행
    // 탄젠트 영역(바운드 경계와 링 표면이 맞닿는 부분) 대응
    float3 StartUV = (RaymarchStart - SDFBoundsMin) / BoundsSize;
    float StartDist = SDFTexture.SampleLevel(SDFSampler, saturate(StartUV), 0).r;
    if (StartDist < 0.0)
    {
        // 이미 SDF 내부 → 변형 불필요 (또는 진입점이 이미 표면)
        if (bOutsideBounds)  
        {
            // 바운드 외부였는데 진입점이 이미 내부 = 진입점까지만 이동
            float3 DisplacementLocal = RaymarchStart - LocalPos;

            // SDF Local → Component Space 변환
            // [기존 방식 - 주석 처리: transpose + 스케일 보정은 Shear 미대응]
            // float3 DisplacementComponent = mul(DisplacementLocal, (float3x3)transpose(ComponentToSDFLocal));
            // float3 invScaleSq = float3(
            //     dot(ComponentToSDFLocal[0].xyz, ComponentToSDFLocal[0].xyz),
            //     dot(ComponentToSDFLocal[1].xyz, ComponentToSDFLocal[1].xyz),
            //     dot(ComponentToSDFLocal[2].xyz, ComponentToSDFLocal[2].xyz)
            // );
            // DisplacementComponent /= max(invScaleSq, 0.0001);

            // [신규 방식] SDFLocalToComponent 직접 사용 (C++에서 FMatrix::Inverse로 정확한 역행렬 전달)
            float3 DisplacementComponent = mul(DisplacementLocal, (float3x3)SDFLocalToComponent);

            return Pos + DisplacementComponent * Strength;
        }
        return Pos;
    }

    // STEP 5: Z 범위 체크 (링 위/아래 버텍스 필터링)
    float originalZ_UV = (LocalPos.z - SDFBoundsMin.z) / BoundsSize.z;
    if (originalZ_UV < -0.1 || originalZ_UV > 1.1)
        return Pos;

    // STEP 6: Phase 2 - SDF 레이마칭 (진입점에서 표면까지)
    float3 CurrentPos = RaymarchStart;
    float epsilon = max(BoundsSize.x, max(BoundsSize.y, BoundsSize.z)) / 64.0;
    float3 lastDir = inwardDir;

    // ========================================================================
    // Coarse Phase: 기존 레이마칭으로 경계 근처까지 빠르게 접근
    // ========================================================================
    bool bEnteredBounds = false;  // 바운드 진입 여부 추적
    float3 LastPositivePos = RaymarchStart;  // 마지막 양수(SDF >= 0) 위치
    float LastPositiveSDF = StartDist;       // 마지막 양수 SDF 값
    bool bFoundBoundary = false;             // 경계(음수) 발견 여부

    for (int i = 0; i < 47; i++)
    {
        float3 CurUV = (CurrentPos - SDFBoundsMin) / BoundsSize;
        bool bInsideBounds = all(CurUV >= 0.0) && all(CurUV <= 1.0);

        if (bInsideBounds)
            bEnteredBounds = true;
        else if (bEnteredBounds)
            break;  // 바운드 안에 있다가 밖으로 나감 = 관통, 멈춤

        // 방사형 방향 재계산 (현재 위치 기준)
        float3 curFromCenter = CurrentPos - LocalRingCenter;
        float curAxialDist = dot(curFromCenter, LocalRingAxis);
        float3 curOutwardRadial = curFromCenter - LocalRingAxis * curAxialDist;
        float curRadialLen = length(curOutwardRadial);

        if (curRadialLen < 0.0001)
            break;

        float3 dir = -curOutwardRadial / curRadialLen;
        lastDir = dir;

        // 바운드 밖이면 SDF 샘플링 건너뛰고 방향만 진행
        if (!bInsideBounds)
        {
            CurrentPos += dir * epsilon * 2.0;  // 고정 스텝으로 바운드 쪽으로 이동
            continue;
        }

        float CurDist = SDFTexture.SampleLevel(SDFSampler, CurUV, 0).r;

        // 링 구멍(음수 영역) 감지 → 경계 발견
        if (CurDist < 0.0)
        {
            bFoundBoundary = true;
            break;
        }

        // 양수 위치 백업 (경계 교차 직전 위치)
        LastPositivePos = CurrentPos;
        LastPositiveSDF = CurDist;

        // SDF 거리 기반 스텝 + 최소 스텝 보장
        float stepScale = (CurDist < 1.0) ? 1.0 : 1.3;
        float stepSize = max(CurDist * stepScale, epsilon * 0.5);
        CurrentPos += dir * stepSize;
    }

    // ========================================================================
    // Refinement Phase: Binary Search로 정밀 경계 수렴
    // ========================================================================
    if (bFoundBoundary)
    {
        // Binary search 구간: [LastPositivePos, CurrentPos]
        // LastPositivePos: SDF >= 0 (외부/표면)
        // CurrentPos: SDF < 0 (내부)
        float3 PosA = LastPositivePos;  // 양수 끝점
        float3 PosB = CurrentPos;       // 음수 끝점

        // 4회 이분 탐색: 오차를 1/16로 감소
        [unroll]
        for (int refineIter = 0; refineIter < 4; refineIter++)
        {
            // 중간점 계산
            float3 MidPos = (PosA + PosB) * 0.5;
            float3 MidUV = saturate((MidPos - SDFBoundsMin) / BoundsSize);
            float MidSDF = SDFTexture.SampleLevel(SDFSampler, MidUV, 0).r;

            // 중간점의 SDF 부호에 따라 구간 절반으로 축소
            if (MidSDF >= 0.0)
            {
                // 중간점이 양수 → 경계는 [MidPos, PosB] 구간에 존재
                PosA = MidPos;
            }
            else
            {
                // 중간점이 음수 → 경계는 [PosA, MidPos] 구간에 존재
                PosB = MidPos;
            }
        }

        // ====================================================================
        // Final Interpolation: Linear interpolation으로 정확히 SDF=0 지점 계산
        // ====================================================================
        // 최종 구간 [PosA, PosB]에서 양 끝점의 SDF 값을 이용하여 선형 보간
        float3 FinalUV_A = saturate((PosA - SDFBoundsMin) / BoundsSize);
        float3 FinalUV_B = saturate((PosB - SDFBoundsMin) / BoundsSize);
        float FinalSDF_A = SDFTexture.SampleLevel(SDFSampler, FinalUV_A, 0).r;
        float FinalSDF_B = SDFTexture.SampleLevel(SDFSampler, FinalUV_B, 0).r;

        // Linear interpolation factor: SDF = 0을 만족하는 t 계산
        // SDF(t) = SDF_A * (1-t) + SDF_B * t = 0
        // t = SDF_A / (SDF_A - SDF_B)
        float denom = FinalSDF_A - FinalSDF_B;
        if (abs(denom) > 0.0001)
        {
            float t = saturate(FinalSDF_A / denom);
            CurrentPos = lerp(PosA, PosB, t);
        }
        else
        {
            // 구간이 거의 평평 (SDF gradient ≈ 0) → 중간점 사용
            CurrentPos = (PosA + PosB) * 0.5;
        }
    }
    // bFoundBoundary == false인 경우:
    // 레이마칭이 경계를 찾지 못하고 종료 (CurrentPos는 마지막 유효 위치)

    // STEP 7: 사후 검증
    if (length(lastDir) <= 0.0001)
        return Pos;

    // Probe 체크: 표면 너머가 구멍인지 확인
    // - 구멍으로 가는 입구 vs 링 옆면 구분
    // - probePos에서 SDF < 0.6이면 구멍, 아니면 외부
    float3 probePos = CurrentPos + lastDir * epsilon * 8.0;
    float3 probeUV = saturate((probePos - SDFBoundsMin) / BoundsSize);
    float probeSDF = SDFTexture.SampleLevel(SDFSampler, probeUV, 0).r;
    if (probeSDF > 0.6)
        return Pos;

    // STEP 8: 변위 계산 및 적용
    float3 DisplacementLocal = CurrentPos - LocalPos;

    // 안전 검증: 변위 방향이 안쪽(inward)인지 확인
    float dispLen = length(DisplacementLocal);
    if (dispLen > 0.001)
    {
        float3 dispDir = DisplacementLocal / dispLen;
        float alignment = dot(dispDir, inwardDir);  // 시작 시점의 inward 방향과 비교

        // 변위가 바깥쪽(outward)이면 잘못된 것 → 변형 포기
        if (alignment < 0.0)
            return Pos;

        // 이동 거리 제한: 초기 radialLen의 90%까지만 허용 (링 중심 통과 방지)
        float maxDispLen = radialLen * 0.9;
        if (dispLen > maxDispLen)
        {
            DisplacementLocal = dispDir * maxDispLen;
        }
    }

    // Z축 변위 제한 (링 위/아래 버텍스가 구멍으로 들어가는 것 방지)
    if (abs(DisplacementLocal.z) > BoundsSize.z * 0.5)
        return Pos;

    // SDF Local → Component Space 변환
    // [기존 방식 - 주석 처리: transpose + 스케일 보정은 Shear 미대응]
    // transpose(ComponentToSDFLocal)은 R × S^-1 (스케일 역수 적용됨)
    // 올바른 변환(R × S)을 위해 S^2 보정 필요
    // float3 DisplacementComponent = mul(DisplacementLocal, (float3x3)transpose(ComponentToSDFLocal));
    // float3 invScaleSq = float3(
    //     dot(ComponentToSDFLocal[0].xyz, ComponentToSDFLocal[0].xyz),
    //     dot(ComponentToSDFLocal[1].xyz, ComponentToSDFLocal[1].xyz),
    //     dot(ComponentToSDFLocal[2].xyz, ComponentToSDFLocal[2].xyz)
    // );
    // DisplacementComponent /= max(invScaleSq, 0.0001);

    // [신규 방식] SDFLocalToComponent 직접 사용 (C++에서 FMatrix::Inverse로 정확한 역행렬 전달)
    float3 DisplacementComponent = mul(DisplacementLocal, (float3x3)SDFLocalToComponent);

    return Pos + DisplacementComponent * Strength;
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ThreadIndex = DispatchThreadId.x;

    // Bounds check: Only process affected vertices
    // 범위 체크: 영향받는 버텍스만 처리
    if (ThreadIndex >= NumAffectedVertices)
    {
        return;
    }

    // ================================================================
    // UV Seam Welding: 대표 버텍스 기반 읽기/쓰기 분리
    // ================================================================
    // - WriteIndex: 실제 버텍스 인덱스 (출력에 사용)
    // - ReadIndex: 대표 버텍스 인덱스 (입력에 사용)
    // 같은 위치의 UV 중복 버텍스들은 동일한 대표를 공유하므로
    // 모두 동일한 위치를 읽어서 동일한 변형 결과를 계산함
    // ================================================================

    // Get the actual vertex index for writing output
    // 출력 쓰기용 실제 버텍스 인덱스 가져오기
    uint WriteIndex = AffectedIndices[ThreadIndex];

    // Get the representative vertex index for reading input
    // 입력 읽기용 대표 버텍스 인덱스 가져오기
    uint ReadIndex = RepresentativeIndices[ThreadIndex];

    // Safety check: Ensure vertex indices are valid
    // 안전 체크: 버텍스 인덱스 유효성 확인
    if (WriteIndex >= NumTotalVertices || ReadIndex >= NumTotalVertices)
    {
        return;
    }

    // Read bind pose position from REPRESENTATIVE vertex
    // 대표 버텍스에서 바인드 포즈 위치 읽기
    // UV 중복 버텍스들은 같은 대표를 공유하므로 동일한 위치를 읽음
    float3 BindPos = ReadPosition(ReadIndex);

    // ========================================
    // Step 1: Apply GPU Skinning (if enabled)
    // 1단계: GPU 스키닝 적용 (활성화된 경우)
    // ========================================
    float3 Pos;
    if (bEnableSkinning != 0)
    {
        // Apply skinning: BindPos → SkinnedPos (animated component space)
        // 스키닝 적용: 바인드 포즈 → 스킨된 포즈 (애니메이션된 컴포넌트 스페이스)
        // NOTE: 스키닝은 대표 버텍스 인덱스(ReadIndex)를 사용하여
        //       UV 중복 버텍스들이 동일한 스키닝 결과를 받도록 함
        float3x4 SkinMatrix = ComputeSkinnedMatrix(ReadIndex);
        Pos = TransformByMatrix(SkinMatrix, BindPos);
    }
    else
    {
        // No skinning: use bind pose directly
        // 스키닝 없음: 바인드 포즈 직접 사용
        Pos = BindPos;
    }

    // Step 2: Apply Tightness Deformation
    float3 NewPos;
    
    if(bUseSDFInfluence != 0)
    {
        // SDF 모드 : Gradient 기반 변형
        //float3 LocalPos = TransformToSDFLocal(BindPos);
        NewPos = ApplyTightnessDeformation_SDF(Pos, BindPos, TightnessStrength);
    }
    else
    {
        // ===== Manual 모드: 기존 로직 =====
        float Influence = Influences[ThreadIndex];
        
        // Skip if influence is negligible
        if (Influence < 0.001)
        {
            WritePosition(WriteIndex, Pos);
            return;
        }
        
        NewPos = ApplyTightnessDeformation(
            Pos,
            RingCenter,
            RingAxis,
            Influence,
            TightnessStrength
        );
    }
    
    // ========================================
    // Step 3: Volume Accumulation (for Bulge pass)
    // 3단계: 부피 누적 (Bulge 패스용)
    // ========================================
    // Tightness로 눌린 양을 Atomic으로 Ring별 누적
    // 각 Ring의 압축량이 VolumeAccumBuffer[RingIndex]에 저장됨
    // BulgeCS에서 자신의 Ring 슬롯을 읽어서 Bulge 적용
    if (bAccumulateVolume != 0)
    {
        // 압축량 = 이동 거리
        float compressionAmount = length(NewPos - Pos);

        // 압축량이 있을 때만 누적 (성능 최적화)
        if (compressionAmount > 0.0001)
        {
            // Float → Fixed-point (예: 0.5 * 1000 = 500)
            uint compressedFixed = uint(compressionAmount * FixedPointScale);

            // Atomic 연산으로 Ring별 슬롯에 누적
            InterlockedAdd(VolumeAccumBuffer[RingIndex], compressedFixed);
        }
    }

    // ========================================
    // Step 4: Write Output to ACTUAL vertex index
    // 4단계: 실제 버텍스 인덱스에 출력 쓰기
    // ========================================
    // UV seam welding: 대표에서 계산한 결과를 자신의 인덱스에 기록
    // 모든 UV 중복 버텍스가 동일한 결과를 각자의 위치에 기록함
    WritePosition(WriteIndex, NewPos);
}
